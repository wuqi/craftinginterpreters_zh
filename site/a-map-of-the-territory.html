<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>A Map of the Territory &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="contents">
<h3><a href="#top">A Map of the Territory<small>2</small></a></h3>

<ul>
    <li><a href="#语言的组成部分"><small>2.1</small> 语言的组成部分</a></li>
    <li><a href="#捷径和备用路线"><small>2.2</small> 捷径和备用路线</a></li>
    <li><a href="#编译器和解释器"><small>2.3</small> 编译器和解释器</a></li>
    <li><a href="#我们的旅程"><small>2.4</small> 我们的旅程</a></li>
    <li><a href="#挑战"><small>2.5</small> 挑战</a></li>
</ul>


<div class="prev-next">
    <a href="introduction.html" title="Introduction" class="left">&larr;&nbsp;Previous</a>
    <a href="welcome.html" title="Welcome">&uarr;&nbsp;Up</a>
    <a href="the-lox-language.html" title="The Lox Language" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
<a href="introduction.html" title="Introduction" class="prev">←</a>
<a href="the-lox-language.html" title="The Lox Language" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<h3><a href="#top">A Map of the Territory<small>2</small></a></h3>

<ul>
    <li><a href="#语言的组成部分"><small>2.1</small> 语言的组成部分</a></li>
    <li><a href="#捷径和备用路线"><small>2.2</small> 捷径和备用路线</a></li>
    <li><a href="#编译器和解释器"><small>2.3</small> 编译器和解释器</a></li>
    <li><a href="#我们的旅程"><small>2.4</small> 我们的旅程</a></li>
    <li><a href="#挑战"><small>2.5</small> 挑战</a></li>
</ul>


<div class="prev-next">
    <a href="introduction.html" title="Introduction" class="left">&larr;&nbsp;Previous</a>
    <a href="welcome.html" title="Welcome">&uarr;&nbsp;Up</a>
    <a href="the-lox-language.html" title="The Lox Language" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">2</div>
  <h1>A Map of the Territory</h1>

<blockquote>
<p>你必须有一张地图，无论多么粗糙。否则你只能到处乱逛。在《指环王》中，我从未让任何人在某一天走得比他能走得更远。</p>
<p><cite>J. R. R. Tolkien</cite></p>
</blockquote>
<p>我们不想到处乱逛，所以在出发之前，让我们扫描一下以前的语言实现者绘制的地图。它将帮助我们了解我们要去哪里，以及其他人走过的替代路线。</p>
<p>首先，我需要一些术语缩写。本书的大部分内容都是关于语言的实现，它与柏拉图式的理想形式语言本身不同。像 &ldquo;堆栈&ldquo;、&ldquo;字节码 &ldquo;和 &ldquo;递归下降 &ldquo;这样的东西，是一个特定的实现可能使用的螺母和螺栓。从用户的角度来看，只要所产生的装置忠实地遵循语言的规范，那他就是实现细节。</p>
<p>我们要在这些细节上花很多时间，所以如果我每次提到这些细节都要写 &ldquo;语言实现 &ldquo;的话，我会把我的手指磨断的。相反，我会用 &ldquo;语言 &ldquo;来指代一种语言或它的实现，或者两者都指代，除非这种区别很重要。</p>
<h2><a href="#语言的组成部分" id="语言的组成部分"><small>2&#8202;.&#8202;1</small>语言的组成部分</a></h2>
<p>自计算机的黑暗时代以来，工程师们一直在构建编程语言。一旦我们可以与电脑交谈，我们发现这样做太难了，我们征求他们的帮助。尽管今天的机器速度比以前快了一百万倍，存储数量级也比以前大了一百万倍，但我们构建编程语言的方式实际上并没有改变。</p>
<p>虽然语言设计者探索的领域很广，但他们在其中开辟的小径却<span name="dead">很少</span>。并非每一种语言都走完全相同的道路--有些语言走了一两条捷径--但除此之外，它们都有令人欣慰的相似性，从海军少将格雷斯-霍珀的第一个COBOL编译器一直到一些热门的、新的、转译成JavaScript的语言，其 &ldquo;文档&rdquo; 完全由某个Git仓库中的一个编辑不善的README组成。</p>
<aside name="dead">
<p>当然，也有一些死胡同，即引用率为零的CS论文和现在已经被遗忘的优化，这些优化只有在内存以单个字节为单位时才有意义。</p>
</aside>
<p>我将可实现的路径网络可视化为攀登一座山峰。你从底部开始，程序是原始的源文本，实际上只是一串字符。每个阶段都会分析程序，并将其转换为更高层次的表述，在这里，语义--作者希望计算机做什么--变得更加明显。</p>
<p>最终我们到达了顶峰。我们对用户的程序有了一个鸟瞰图，可以看到他们的代码意味着什么。我们开始从山的另一边下山。我们把这个最高级别的表示方法逐次转化为较低级别的形式，以便越来越接近我们知道如何让CPU实际执行的东西。</p><img src="image/a-map-of-the-territory/mountain.png" alt="The branching paths a language may take over the mountain." class="wide" />
<p>让我们追踪每一条线索和感兴趣的地点。我们的旅程从左边的用户源代码的文本开始:</p><img src="image/a-map-of-the-territory/string.png" alt="var average = (min + max) / 2;" />
<h3><a href="#scanning扫描器" id="scanning扫描器"><small>2&#8202;.&#8202;1&#8202;.&#8202;1</small>Scanning(扫描器)</a></h3>
<p>第一步是扫描 <strong>scanning</strong> ，也被称为词法  <strong>lexing</strong> ，或(如果你想给某人留下深刻印象)词法分析 <strong>lexical analysis</strong> 。它们的意思都差不多。我喜欢 <code>lexing</code> ，因为它听起来像邪恶的超级反派会做的事情，但我会用 <code>scanning</code> ，因为它似乎更加常见。</p>
<p>一个 <strong>扫描器</strong> (或 <strong>词法分析器</strong> )接收字符的输入流，并将它们组合在一起，形成一系列更类似于<span name="word">&ldquo;单词&ldquo;</span>的东西。在编程语言中，这些单词中的每一个都称为标记。有些标记是单个字符，如( <code>and</code> <code>,</code> <code>.</code> 其他的可能是几个字符长，比如数字(123) ，字符串文字(  <code>"hi!"</code> )和标识符( <code>min</code> )。</p>
<aside name="word">
<p>“Lexical” 来自希腊语词根  “lex”, 意思是 “word” (单词). </p>
</aside>
<p>源文件中的某些字符实际上没有任何意义。空白通常是微不足道的，根据定义，注释被语言忽略。扫描器通常会丢弃这些标记，留下一系列有意义的标记。</p><img src="image/a-map-of-the-territory/tokens.png" alt="[var] [average] [=] [(] [min] [+] [max] [)] [/] [2] [;]" />
<h3><a href="#parsing-解析" id="parsing-解析"><small>2&#8202;.&#8202;1&#8202;.&#8202;2</small>Parsing (解析)</a></h3>
<p>下一步是解析 <strong>parsing</strong> 。这就是我们的语法获得语法 <strong>grammar</strong> 的地方ーー能够用较小的部分组成较大的表达式和语句。你在英语课上画过句子分词图吗？如果是这样，那么您已经完成了解析器的工作，只不过英语有成千上万的“关键字”和泛滥的歧义。编程语言要简单得多。</p>
<p><strong>解析器</strong> 获取标记的平面序列，并构建反映文法嵌套特性的树结构。这些树有几个不同的名称ーー <strong>解析树</strong> 或 <strong>抽象语法树</strong> ーー 这取决于它们与源语言的纯语法结构的接近程度。在实践中，语言黑客通常称之为 <strong>语法树</strong> 、 <strong>AST</strong> 或者就称为 <strong>树</strong> 。</p><img src="image/a-map-of-the-territory/ast.png" alt="An abstract syntax tree." />
<p>解析在计算机科学中有着悠久而丰富的历史，与人工智能界紧密相连。今天用于解析编程语言的许多技术，最初是由试图让计算机与我们对话的人工智能研究人员为解析人类语言而构想的。</p>
<p>事实证明，人类语言对于那些解析器所能处理的僵化语法来说太混乱了，但对于编程语言的较简单的人工语法来说，它们是完美的。唉，我们这些有缺陷的人类仍然设法错误地使用这些简单的语法，所以解析器的工作也包括通过报告 <strong>语法错误</strong> 来让我们知道何时使用这些语法。</p>
<h3><a href="#static-analysis-静态分析" id="static-analysis-静态分析"><small>2&#8202;.&#8202;1&#8202;.&#8202;3</small>Static analysis (静态分析)</a></h3>
<p>前两个阶段在所有实现中都非常相似。现在，每种语言的个性特征开始发挥作用。此时，我们已经知道了代码的语法结构ーー比如哪些表达式嵌套在哪些表达式中ーー但除此之外，我们所知不多。</p>
<p>在 <code>a + b</code> 这样的表达式中，我们知道要加上 <code>a</code> 和 <code>b</code> ，但我们不知道这些名字指的是什么。它们是局部变量吗？还是全局变量？它们在哪里被定义？</p>
<p>大多数语言所做的第一项分析被称为绑定( <strong>binding</strong> )或解析( <strong>resolution</strong> )。对于每个标识符( <strong>identifier</strong> )，我们要找出这个名字的定义位置，并将两者连接起来。这就是范围( <strong>scope</strong> )的作用--源代码中某个名字可以用来指代某个声明的区域。</p>
<p>如果语言是<span name="type">静态类型</span>的，这就是我们进行类型检查的时候。一旦我们知道 <code>a</code> 和 <code>b</code> 是在哪里声明的，我们也可以弄清它们的类型。然后，如果这些类型不支持彼此相加，我们就报告一个 <strong>类型错误</strong> 。</p>
<aside name="type">
<p>我们将在本书中构建的语言是动态类型的，所以它将在以后的运行时进行类型检查。</p>
</aside>
<p>深呼吸。我们已经到达了山顶，并对用户的程序有了全面的了解。所有这些从分析中可见的语义表现都需要存储在某个地方。有几个地方我们可以储藏起来:</p>
<ul>
<li>
<p>通常，它被直接存储为语法树本身的属性(  <strong>attributes</strong>  )--节点中的额外字段，这些字段在解析过程中并没有被初始化，而是在之后被填入。</p>
</li>
<li>
<p>其他时候，我们可能将数据存储在旁边的查找表中。通常，此表的键是标识符ーー变量和声明的名称。在这种情况下，我们称之为符号表(  <strong>symbol table</strong>  )，它与每个键关联的值告诉我们该标识符指的是什么。</p>
</li>
<li>
<p>最强大的簿记工具是将树转换成一个全新的数据结构，以更直接地表达代码的语义。那是下一部分。</p>
</li>
</ul>
<p>到目前为止的一切都被认为是实现的前端。你可能会猜到这之后的一切都是后端，但不是。在“前端”( <strong>front end</strong> )和“后端”( <strong>back end</strong> )出现的年代，编译器要简单得多。后来的研究人员发明了新的阶段，以塞进这两部分之间。威廉-伍尔夫和他的公司没有抛弃旧的术语，而是将这些新的阶段归纳为迷人的但在空间上自相矛盾的名字--中间端( <strong>middle end</strong> )。</p>
<h3><a href="#intermediate-representations中间表示" id="intermediate-representations中间表示"><small>2&#8202;.&#8202;1&#8202;.&#8202;4</small>Intermediate representations(中间表示)</a></h3>
<p>您可以将编译器视为一个管道，其中每个阶段的工作都是组织表示用户代码的数据，使得下一个阶段的实现更加简单。管道的前端特定于用来编写程序的源语言。后端关注的是程序运行的最终体系结构。</p>
<p>在中间，代码可能存储在一些<span name="ir">中间表示 <strong>intermediate
representation</strong></span>(<strong>IR</strong>)中，这些中间表示(IR)与源表单或目标表单都没有紧密联系(因此是“中间”)。相反，IR 充当这两种语言之间的接口。</p>
<aside name="ir">
<p>现在有几种成熟的IRs风格。点击你所选择的搜索引擎，寻找 &ldquo;控制流图&ldquo;、&ldquo;静态单赋值&ldquo;、&ldquo;延体传递风格 &ldquo;和 &ldquo;三地址码&ldquo;(&ldquo;control flow graph&rdquo;, &ldquo;static single-assignment&rdquo;, &ldquo;continuation-passing style&rdquo;,  &ldquo;three-address code&rdquo;)。</p>
</aside>
<p>这使您可以更轻松地支持多种源语言和目标平台。假设您希望实现 Pascal、 C 和 Fortran 编译器，并且希望以 x86、 ARM 和(我不知道的) SPARC 为目标。通常，这意味着您要注册编写九个完整的编译器: Pascal&rarr;x86，C&rarr;ARM，以及其他所有组合。</p>
<p><span name="gcc">共享</span>的中间表示极大地减少了这种情况。您可以为生成 IR 的每种源语言编写 <em>一个</em> 前端。然后为每个目标体系结构设置 <em>一个</em> 后端。现在你可以混合和匹配这些得到每个组合。</p>
<aside name="gcc">
<p>如果你曾经想知道 <a href="https://en.wikipedia.org/wiki/GNU_Compiler_Collection">GCC</a> 是如何支持这么多疯狂的语言和架构的，比如摩托罗拉68k上的Modula-3，现在你知道了。语言前端的目标是少数几个IR中的一个，主要是 <a href="https://gcc.gnu.org/onlinedocs/gccint/GIMPLE.html">GIMPLE</a> 和 <a href="https://gcc.gnu.org/onlinedocs/gccint/RTL.html">RTL</a> 。目标后端，如68k的后端，然后采用这些IRs并产生本地代码。</p>
</aside>
<p>还有一个很重要的原因，我们可能希望将代码转换成一种使语义更加明显的形式<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span></p>
<h3><a href="#optimization-优化" id="optimization-优化"><small>2&#8202;.&#8202;1&#8202;.&#8202;5</small>Optimization 优化</a></h3>
<p>一旦我们理解了用户程序的含义，我们就可以自由地将其与具有相同语义但实现效率更高的不同程序交换ーー我们可以对其进行 <strong>优化</strong>。</p>
<p>举个简单的例子, <strong>常数折叠</strong> : 如果某个表达式的求值总是完全相同，我们可以在编译时求值，并用结果替换表达式的代码。如果用户键入以下内容:</p>
<div class="codehilite"><pre><span class="i">pennyArea</span> = <span class="n">3.14159</span> * (<span class="n">0.75</span> / <span class="n">2</span>) * (<span class="n">0.75</span> / <span class="n">2</span>);
</pre></div>
<p>我们可以在编译器中做所有这些算术，然后把代码改为:</p>
<div class="codehilite"><pre><span class="i">pennyArea</span> = <span class="n">0.4417860938</span>;
</pre></div>
<p>优化是编程语言业务的一个巨大部分。许多语言黑客在这里度过了他们的整个职业生涯，从他们的编译器中榨取每一滴性能，以使他们的基准速度提高百分之零点一。这可以上瘾。</p>
<p>在本书中，我们主要是要跳过这个<span name="rathole">老鼠洞</span>。许多成功的语言的编译时优化都少得令人吃惊。例如，Lua和CPython生成的代码相对来说没有优化，它们的大部分性能努力都集中在运行时。</p>
<aside name="rathole">
<p>如果你忍不住把脚伸进那个洞里，一些关键词可以让你开始行动，它们是 &ldquo;常量传播&ldquo;、&ldquo;公共子表达式删除&ldquo;、&ldquo;循环不变式外提&ldquo;、&ldquo;全局值编号优化&ldquo;、&ldquo;强度折减&ldquo;、&ldquo;标量替换&ldquo;、&ldquo;死码消除 &ldquo;和 &ldquo;循环展开&ldquo;。(&ldquo;constant propagation&rdquo;, &ldquo;common subexpression elimination&rdquo;, &ldquo;loop invariant code motion&rdquo;, &ldquo;global value numbering&rdquo;, &ldquo;strength reduction&rdquo;, &ldquo;scalar replacement of aggregates&rdquo;, &ldquo;dead code elimination&rdquo;, and &ldquo;loop unrolling&rdquo;)</p>
</aside>
<h3><a href="#code-generation-代码生成" id="code-generation-代码生成"><small>2&#8202;.&#8202;1&#8202;.&#8202;6</small>Code generation 代码生成</a></h3>
<p>我们已经将所有我们能想到的优化应用到用户的程序中。最后一步是将其转换为计算机实际可以运行的形式。换句话说， <strong>生成代码</strong> (或者 <strong>代码生成器</strong>) ，这里的“代码”通常指的是 CPU 运行的那种类似汇编的原始指令，而不是人类可能想要读取的那种“源代码”。</p>
<p>最后，我们到了山的后端( <strong>back end</strong> )，从山的另一边下山。从现在开始，我们对代码的表示变得越来越原始，就像进化倒着运行一样，因为我们越来越接近我们头脑简单的机器所能理解的东西。</p>
<p>我们有一个决定要做。我们是为真实的CPU生成指令还是为虚拟的CPU生成指令？如果我们生成真正的机器代码，我们就会得到一个可执行文件，操作系统可以直接加载到芯片上。原生代码的速度快如闪电，但生成它的工作却很繁重。今天的架构有成堆的指令，复杂的流水线，以及足以填满747行李舱的<span name="aad">历史包袱</span>。</p>
<p>使用芯片的语言也意味着你的编译器被捆绑在一个特定的架构上。如果你的编译器以 <a href="https://en.wikipedia.org/wiki/X86">x86</a> 机器代码为目标，那么它就不能在 <a href="https://en.wikipedia.org/wiki/ARM_architecture">ARM</a> 设备上运行。早在60年代，在计算机体系结构的寒武纪爆炸期间，缺乏可移植性是一个真正的障碍。</p>
<aside name="aad">
<p>例如， <a href="http://www.felixcloutier.com/x86/AAD.html">AAD</a> （&ldquo;ASCII调整AX除法前&ldquo;）指令让你进行除法，这听起来很有用。只是这条指令的操作数是两个二进制编码的十进制数字，装入一个16位寄存器。你上次在16位机器上需要BCD是什么时候？</p>
</aside>
<p>为了避免这种情况，像 Martin Richards 和 Niklaus Wirth 这样分别以 BCPL 和 Pascal 闻名的黑客，让他们的编译器产生虚拟机代码。他们不是为某个真实的芯片编写指令，而是为一个假想的、理想化的机器编写代码。Wirth称这种代码为可移植代码( <strong>p-code</strong> for <em>portable</em>)，但今天，我们通常称它为 <strong>字节码</strong> ，因为每条指令通常只有一个字节长。</p>
<p>这些合成指令的设计目的是更贴近语言的语义，而不是与任何一种计算机体系结构的特性及其累积的历史残渣绑定在一起。您可以把它看作是语言低级操作的一种密集的二进制编码。</p>
<h3><a href="#virtual-machine-虚拟机" id="virtual-machine-虚拟机"><small>2&#8202;.&#8202;1&#8202;.&#8202;7</small>Virtual machine 虚拟机</a></h3>
<p>如果你的编译器产生字节码，一旦完成，你的工作还没有结束。由于没有芯片能说这种字节码，你的工作就是翻译。同样，你有两个选择。你可以为每个目标架构写一个小的迷你编译器，将字节码转换为该机器的本地代码。你仍然要为你支持的<span name="shared">每一个</span>芯片做工作，但最后一个阶段是非常简单的，你可以在你支持的所有机器上重复使用编译器的其余管道。你基本上是把字节码作为IR。</p>
<aside name="shared" class="bottom">
<p>这里的基本原则是，你把特定架构的工作在管道中推得越远，你就可以在不同的架构中分享更多的早期阶段的内容。</p>
<p>不过，有一个矛盾。许多优化，如寄存器分配和指令选择，在了解特定芯片的优势和能力时效果最好。弄清楚你的编译器中哪些部分可以共享，哪些部分应该是针对特定目标的，是一门艺术。</p>
</aside>
<p>或者你可以写一个<span name="vm"><strong>虚拟机</strong></span> （ <strong>VM</strong> ），一个在运行时模拟支持你的虚拟架构的假想芯片的程序。在虚拟机中运行字节码比提前将其翻译成本地代码要慢，因为每条指令在每次执行时都必须在运行时进行模拟。作为回报，你可以获得简单性和可移植性。用C语言实现你的虚拟机，你可以在任何有C编译器的平台上运行你的语言。这就是我们在本书中构建的第二个解释器的工作方式。</p>
<aside name="vm">
<p>术语 &ldquo;虚拟机 &ldquo;也是指一种不同的抽象概念。一个 <strong>system virtual machine</strong>  在软件中模拟了整个硬件平台和操作系统。这就是为什么你可以在你的Linux机器上玩Windows游戏，以及云供应商如何给客户提供控制他们自己的 &ldquo;服务器 &ldquo;的用户体验，而不需要为每个用户分配单独的计算机。</p>
<p>我们在本书中要讨论的那种虚拟机是 <strong>language virtual machines</strong> ，如果你不想搞混的话，更准确的说是 <strong>process virtual machines</strong>。</p>
</aside>
<h3><a href="#runtime-运行时" id="runtime-运行时"><small>2&#8202;.&#8202;1&#8202;.&#8202;8</small>Runtime 运行时</a></h3>
<p>我们终于把用户的程序打造成了一种可以执行的形式。最后一步是运行它。如果我们将它编译成机器代码，我们只需告诉操作系统加载可执行文件，然后就可以运行了。如果我们将其编译为字节码，则需要启动 VM 并将程序加载到其中。</p>
<p>在这两种情况下，除了最基本的低级语言之外，我们通常都需要在程序运行时语言提供的一些服务。例如，如果语言自动管理内存，我们需要一个垃圾收集器来回收未使用的数据。如果我们的语言支持“实例”测试，这样您就可以看到您拥有什么类型的对象，那么我们需要一些表示来在执行过程中跟踪每个对象的类型。</p>
<p>所有这些东西都是在运行时进行的，因此它被恰当地称为 <strong>运行时</strong> 。在一个完整的编译语言中，实现运行时的代码直接插入到生成的可执行文件中。例如，在 <a href="https://golang.org/">Go</a> 中，每个已编译的应用程序都有自己的 Go 运行时副本直接嵌入其中。如果语言是在解释器或 VM 中运行的，那么运行时就存在于其中。这就是 Java、 Python 和 JavaScript 等语言的大多数实现的工作方式。</p>
<h2><a href="#捷径和备用路线" id="捷径和备用路线"><small>2&#8202;.&#8202;2</small>捷径和备用路线</a></h2>
<p>这是涵盖您可能实现的每个可能阶段的漫长道路。许多语言确实走完了整条道路，但也有一些捷径和替代路径。</p>
<h3><a href="#single-pass-compilers-单程编译器" id="single-pass-compilers-单程编译器"><small>2&#8202;.&#8202;2&#8202;.&#8202;1</small>Single-pass compilers 单程编译器</a></h3>
<p>一些简单的编译器将解析、分析和代码生成交错在一起，以便直接在解析器中生成输出代码，而不需要分配任何语法树或其他 IR。这些<span name="sdt"><strong>单程编译器</strong></span>限制了语言的设计。没有中间数据结构来存储关于程序的全局信息，也不需要重新访问任何以前解析过的代码部分。这意味着一旦看到某个表达式，就需要足够的知识来正确地编译它。</p>
<aside name="sdt">
<p><a href="https://en.wikipedia.org/wiki/Syntax-directed_translation"><strong>Syntax-directed translation</strong></a> 是一种结构化的技术，用于构建这些一次性的编译器。你将一个动作与语法的每一个部分联系起来，通常是产生输出代码的动作。然后，每当解析器与那块语法相匹配时，它就会执行该动作，每次都建立起目标代码的规则。</p>
</aside>
<p>Pascal 和 C 就是围绕这个限制设计的。当时，内存是如此宝贵，以至于编译器甚至不能在内存中保存整个源文件，更不用说整个程序了。这就是 Pascal 语法要求类型声明首先出现在块中的原因。这就是为什么在 C 语言中，你不能在定义函数的代码之上调用函数，除非你有一个明确的前向声明，告诉编译器它需要知道什么来生成调用后面函数的代码。</p>
<h3><a href="#tree-walk-interpreters-树遍历解释器" id="tree-walk-interpreters-树遍历解释器"><small>2&#8202;.&#8202;2&#8202;.&#8202;2</small>Tree-walk interpreters 树遍历解释器</a></h3>
<p>一些编程语言在将代码解析成AST后就开始执行代码（也许还应用了一点静态分析）。为了运行程序，解释器每次都会在语法树上的一个分支和一个叶子上遍历，一边走一边评估每个节点。</p>
<p>这种实现方式在学生项目和小语言中很常见，但在<span name="ruby">通用语言</span>中却没有被广泛使用，因为它往往很慢。有些人用 &ldquo;解释器 &ldquo;只指这类实现，但其他人对这个词的定义更为宽泛，所以我将用无可争辩的明确的 <strong>树遍历解释器</strong> 来指这些。我们的第一个解释器是这样运行的。</p>
<aside name="ruby">
<p>一个值得注意的例外是Ruby的早期版本，它是树形解释器。在1.9版本中，Ruby的典型实现从最初的MRI（Matz&rsquo;s Ruby Interpreter）转向Koichi Sasada的YARV（Yet Another Ruby VM）。YARV是一个字节码虚拟机。</p>
</aside>
<h3><a href="#transpilers-转译器" id="transpilers-转译器"><small>2&#8202;.&#8202;2&#8202;.&#8202;3</small>Transpilers 转译器</a></h3>
<p>为一种语言<span name="gary">编写</span>一个完整的后端可能是一个很大的工作。如果你有一些现有的通用IR作为目标，你可以把你的前端栓在那里。否则，你就会被卡住。但是，如果你把其他的 <strong>源语言</strong> 当作是一种中间表示法呢？</p>
<p>你为你的语言写一个前端。然后，在后端，你不需要做所有的工作来降低语义到一些原始的目标语言，而是产生一串有效的源代码，用于其他一些和你的语言一样高级的语言。然后，你使用该语言的现有编译工具作为你的逃亡路线，从山上下来，变成你可以执行的东西。</p>
<p>他们曾经把这叫做源码到源码的编译器( <strong>source-to-source compiler</strong> )或反编译器( <strong>transcompiler</strong> )。在那些为了在浏览器中运行而编译成JavaScript的语言兴起之后，他们将其昵称为转译器( <strong>transpiler</strong> )。</p>
<aside name="gary">
<p>第一个反编译器，XLT86，将8080汇编翻译成8086汇编。这似乎很简单，但请记住，8080是一个8位的芯片，而8086是一个16位的芯片，可以将每个寄存器作为一对8位的1使用。XLT86做了数据流分析，跟踪源程序中的寄存器使用情况，然后有效地将其映射到8086的寄存器集。</p>
<p>它是由Gary Kildall编写的，如果有的话，他是计算机科学界的一个悲剧性英雄。他是最早认识到微型计算机前景的人之一，他创造了PL/M和CP/M，这是第一个用于微型计算机的高级语言和操作系统。</p>
<p>他是一位船长、企业主、持证飞行员和摩托车手。他是一名电视节目主持人，拥有80年代潇洒的大胡子帅哥所拥有的Kris Kristofferson式的外表。他与比尔-盖茨竞争，和许多人一样，他输了，然后在神秘的情况下在一个摩托车酒吧里结束了自己的生命。他死得太早，但他活过。</p>
</aside>
<p>虽然第一个反编译器将一种汇编语言翻译成另一种语言，但今天，大多数反编译器都是在高级语言上工作。在UNIX病毒性地传播到各种机器上之后，开始了一个长期的编译器传统，将C作为其输出语言。在UNIX存在的地方都有C语言编译器，并能产生高效的代码，所以针对C语言是让你的语言在很多架构上运行的好方法。</p>
<p>网络浏览器是当今的 &ldquo;机器&ldquo;，而它们的 &ldquo;机器代码 &ldquo;是JavaScript，所以这些天，似乎几乎每一种语言都有针对  <a href="https://github.com/jashkenas/coffeescript/wiki/list-of-languages-that-compile-to-js">almost every language out there</a> 的编译器，因为这是让你的代码在浏览器中运行的<span name="js">主要</span>途径。</p>
<aside name="js">
<p>JS曾经是在浏览器中执行代码的唯一方式。由于有了<a href="https://github.com/webassembly/">WebAssembly</a>，编译器现在有了第二种可以在网络上运行的较低级别的语言作为目标。</p>
</aside>
<p>转译器的前端--扫描器和解析器看起来和其他编译器一样。然后，如果源语言只是目标语言的一个简单的句法皮肤，它可能会完全跳过分析，直接输出目标语言的类似句法。</p>
<p>如果这两种语言在语义上有更多的不同，你会看到一个完整的编译器的更多典型阶段，包括分析，甚至可能是优化。然后，当涉及到代码生成时，你不是输出一些像机器码一样的二进制语言，而是在目标语言中产生一串语法正确的源码（嗯，目标语言）。</p>
<p>无论哪种方式，你都可以通过输出语言现有的编译管道运行生成的代码，然后你就可以开始了。</p>
<h3><a href="#just-in-time-compilation-即时编译" id="just-in-time-compilation-即时编译"><small>2&#8202;.&#8202;2&#8202;.&#8202;4</small>Just-in-time compilation 即时编译</a></h3>
<p>这最后一条与其说是捷径，不如说是危险的高山攀登，最好留给专家。执行代码的最快方式是将其编译为机器代码，但你可能不知道你的最终用户的机器支持什么架构。该怎么做呢？</p>
<p>你可以学习HotSpot Java虚拟机（JVM）、微软的通用语言运行时（CLR）和大多数JavaScript解释器所做的同样事情。在终端用户的机器上，当程序被加载时--无论是从JS的源代码，还是JVM和CLR的平台独立字节码--你都要把它编译成他们计算机支持的架构的本地代码。很自然地，这被称为即时编译( <strong>just-in-time compilation</strong> )。大多数黑客只是说 &ldquo;JIT&rdquo;，读起来好像和 &ldquo;fit &ldquo;押韵。</p>
<p>最复杂的JIT在生成的代码中插入剖析钩子，以查看哪些区域是最关键的性能，以及什么样的数据正在流经它们。然后，随着时间的推移，它们会自动用更先进的优化方法重新编译这些<span name="hot">热点</span>区域。</p>
<aside name="hot">
<p>当然，这正是HotSpot JVM的名字来源</p>
</aside>
<h2><a href="#编译器和解释器" id="编译器和解释器"><small>2&#8202;.&#8202;3</small>编译器和解释器</a></h2>
<p>现在，我已经用字典里的编程语言术语塞满了你的脑袋，我们终于可以解决一个自古以来一直困扰着编码者的问题。编译器和解释器之间有什么区别？</p>
<p>事实证明，这就像问水果和蔬菜的区别一样。这似乎是一个二选一的选择，但实际上 &ldquo;水果 &ldquo;是一个植物学术语，而 &ldquo;蔬菜 &ldquo;是烹饪术语。一个并不严格意味着对另一个的否定。有的水果不是蔬菜（苹果），有的蔬菜不是水果（胡萝卜），但也有既是水果又是蔬菜的可食用植物，如西红柿。</p>
<p><span name="veg"></span></p><img src="image/a-map-of-the-territory/plants.png" alt="A Venn diagram of edible plants" />
<aside name="veg">
<p>花生（甚至不是坚果）和小麦等谷物实际上是水果，但我把这个图画错了。我能说什么呢，我是个软件工程师，不是植物学家。我也许应该把这个花生小家伙擦掉，但他太可爱了，我不忍心擦掉。</p>
<p>现在，松子，另一方面，是基于植物的食物，既不是水果也不是蔬菜。至少在我看来是这样。</p>
</aside>
<p>所以，回到语言上。</p>
<ul>
<li>
<p><strong>编译</strong> 是一种 <em>实现技术</em> ，它涉及到将源语言翻译成某种其他的--通常是较低级别的--形式。当你生成字节码或机器码时，你就是在进行编译。当你转译成另一种高级语言时，你也在进行编译。</p>
</li>
<li>
<p>当我们说一个语言实现 &ldquo;是一个编译器 &ldquo;时，我们的意思是它把源代码翻译成其他形式，但不执行它。用户必须拿着输出的结果，自己去运行它。</p>
</li>
<li>
<p>相反，当我们说一个实现 &ldquo;是一个解释器 &ldquo;时，我们的意思是它接受源代码并立即执行它。它 &ldquo;从源头 &ldquo;运行程序。</p>
</li>
</ul>
<p>就像苹果和桔子一样，有些实现显然是编译器而不是解释器。GCC和Clang将你的C语言代码编译成机器代码。终端用户直接运行这个可执行文件，甚至可能不知道是用哪个工具来编译的。所以这些是C语言的编译器。</p>
<p>在Matz的Ruby经典实现的旧版本中，用户从源代码运行Ruby。该实现解析了它，并通过遍历语法树直接执行它。没有其他翻译发生，无论是在内部还是在任何用户可见的形式。所以这绝对是一个Ruby的解释器。</p>
<p>但是CPython呢？当你用它运行你的Python程序时，代码被解析并转换为内部字节码格式，然后在虚拟机内执行。从用户的角度来看，这显然是一个解释器--他们从源代码中运行他们的程序。但如果你看一下CPython的鳞片状皮肤，你会发现肯定有一些编译工作在进行。</p>
<p>答案是，它<span name="go">两者都是</span>。CPython是一个解释器，它也有一个编译器。在实践中，大多数脚本语言都是这样工作的，你可以看到。</p>
<aside name="go">
<p><a href="https://golang.org/">Go tool</a>更是一种园艺上的好奇心。如果你运行 <code>go build</code> ，它会将你的Go源代码编译成机器代码并停止。如果你输入 <code>go run</code> ，它就会这么做，然后立即执行生成的可执行文件。</p>
<p>所以 <code>go</code> 是一个编译器（你可以把它作为一个工具来编译代码，而不运行它），是一个解释器（你可以调用它来立即运行一个源程序），也有一个编译器（当你把它作为一个解释器使用时，它仍然在进行内部编译）。</p>
</aside><img src="image/a-map-of-the-territory/venn.png" alt="A Venn diagram of compilers and interpreters" />
<p>中间重叠的区域也是我们的第二个解释器所在的地方，因为它在内部编译成字节码。所以尽管这本书名义上是关于解释器的，我们也会涉及一些编译。</p>
<h2><a href="#我们的旅程" id="我们的旅程"><small>2&#8202;.&#8202;4</small>我们的旅程</a></h2>
<p>一下子要接受的东西太多了。不要担心。这一章并不期望你理解所有这些碎片和部分。我只是想让你知道它们就在那里，并大致了解它们是如何结合在一起的。</p>
<p>当你在本书的指导下探索其他领域时，这张地图应该对你有帮助。我想让你渴望自己出击，在那座山上到处游荡。</p>
<p>但是，现在，是时候开始我们自己的旅程了。系紧你的鞋带，收紧你的背包，然后一起走吧。从span name=&ldquo;here&rdquo;&gt;现在</span>开始，你所需要关注的是你面前的道路。</p>
<aside name="here">
<p>从今往后，我保证淡化整个山体隐喻的事情。</p>
</aside>
<div class="challenges">
<h2><a href="#挑战" id="挑战"><small>2&#8202;.&#8202;5</small>挑战</a></h2>
<ol>
<li>
<p>选择一种你喜欢的语言的开源实现。下载源代码并在其中探索。尝试找到实现扫描器和解析器的代码。它们是手写的，还是使用Lex和Yacc等工具生成的？(<code>.I</code> 或者 <code>.y</code> 文件通常暗示的是后者。)</p>
</li>
<li>
<p>即时编译往往是实现动态类型语言的最快方式，但并不是所有的语言都使用它。有什么理由不采用JIT呢？</p>
</li>
<li>
<p>大多数编译成C语言的Lisp实现也包含一个解释器，让它们也能在运行中执行Lisp代码。为什么呢？</p>
</li>
</ol>
</div>

<footer>
<a href="the-lox-language.html" class="next">
  Next Chapter: &ldquo;The Lox Language&rdquo; &rarr;
</a>
Handcrafted by Robert Nystrom&ensp;&mdash;&ensp;<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy; 2015&hairsp;&ndash;&hairsp;2021</a>
</footer>
</article>

</div>
</body>
</html>
