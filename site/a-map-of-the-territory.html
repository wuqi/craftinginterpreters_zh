<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>A Map of the Territory &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="contents">
<h3><a href="#top">A Map of the Territory<small>2</small></a></h3>

<ul>
    <li><a href="#语言的组成部分"><small>2.1</small> 语言的组成部分</a></li>
    <li><a href="#捷径和备选路线"><small>2.2</small> 捷径和备选路线</a></li>
    <li><a href="#编译器和解释器"><small>2.3</small> 编译器和解释器</a></li>
    <li><a href="#我们的旅程"><small>2.4</small> 我们的旅程</a></li>
    <li><a href="#挑战"><small>2.5</small> 挑战</a></li>
</ul>


<div class="prev-next">
    <a href="introduction.html" title="Introduction" class="left">&larr;&nbsp;Previous</a>
    <a href="welcome.html" title="Welcome">&uarr;&nbsp;Up</a>
    <a href="the-lox-language.html" title="The Lox Language" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
<a href="introduction.html" title="Introduction" class="prev">←</a>
<a href="the-lox-language.html" title="The Lox Language" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<h3><a href="#top">A Map of the Territory<small>2</small></a></h3>

<ul>
    <li><a href="#语言的组成部分"><small>2.1</small> 语言的组成部分</a></li>
    <li><a href="#捷径和备选路线"><small>2.2</small> 捷径和备选路线</a></li>
    <li><a href="#编译器和解释器"><small>2.3</small> 编译器和解释器</a></li>
    <li><a href="#我们的旅程"><small>2.4</small> 我们的旅程</a></li>
    <li><a href="#挑战"><small>2.5</small> 挑战</a></li>
</ul>


<div class="prev-next">
    <a href="introduction.html" title="Introduction" class="left">&larr;&nbsp;Previous</a>
    <a href="welcome.html" title="Welcome">&uarr;&nbsp;Up</a>
    <a href="the-lox-language.html" title="The Lox Language" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">2</div>
  <h1>A Map of the Territory</h1>

<blockquote>
<p>你必须有一张地图，无论多么粗糙。否则你只能到处乱逛。在《指环王》中，我从未让任何人在某一天走得超出他力所能及的范围。</p>
<p><cite>J. R. R. Tolkien</cite></p>
</blockquote>
<p>我们不想到处乱逛，所以在出发之前，让我们先浏览一下以前的语言实现者绘制的地图。它将帮助我们了解我们要去哪里，以及其他人采用的备选路线。</p>
<p>首先，我做个简单说明。本书的大部分内容都是关于语言的实现，它与<em>语言本身</em>这种柏拉图式的理想形式有所不同。诸如 &ldquo;堆栈&ldquo;、&ldquo;字节码 &ldquo;和 &ldquo;递归下降 &ldquo;这样的东西，是某个特定实现中可能使用的基本要素。从用户的角度来看，只需要最终产生的装置能够忠实地遵循语言规范，其他内部的都是实现细节。</p>
<p>我们要在这些细节上花很多时间，所以如果我每次提到这些细节都要写 &ldquo;语言实现&rdquo; 的话，我会把我的手指磨断的。所以，除非有重大区别，我会用 &ldquo;语言&rdquo; 来指代一种语言或它的实现，或者两者都指代。</p>
<h2><a href="#语言的组成部分" id="语言的组成部分"><small>2&#8202;.&#8202;1</small>语言的组成部分</a></h2>
<p>自计算机的黑暗时代以来，工程师们一直在构建编程语言。当我们可以和计算机交流的时候，我们发现太难了，我们寻求它们的帮助。有趣的是，即使今天的机器速度比以前快了一百万倍，存储数量级也比以前大了几个数量级，但我们构建编程语言的方式几乎没有改变。</p>
<p>尽管语言设计师所探索的领域辽阔，但他们在其中开辟的小径却<span name="dead">很少</span>。并非每种语言都会踏上完全相同的路--有些语言走了一两条捷径--但除此之外，它们都有令人欣慰的相似性，从海军少将格雷斯-霍珀的第一个 COBOL 编译器一直到某些新鲜出炉的JavaScript变种语言（它们的&ldquo;文档&rdquo; 甚至完全由某个Git仓库中的一个写的很烂的README组成）。</p>
<aside name="dead">
<p>当然，也有一些死胡同，即引用率为零的CS论文和现在已经被遗忘的优化，这些优化只有在内存以单个字节为单位来衡量内存时才有意义。</p>
</aside>
<p>我将语言实现的路网可视化为攀登一座山峰。从山底开始，程序是原始的源文本，实际上只是一串字符。每个阶段都会分析程序，并将其转换为更高层次的表现形式，从而使语义--作者希望计算机做什么--变得更加明显。</p>
<p>最终我们到达了顶峰。我们可以鸟瞰用户的程序，可以看到他们的代码有什么含义。我们开始从另一侧下山。我们把这个最高级别的表示形式逐次转化为较低级别的形式，从而接近我们所知道的如何让CPU实际执行的形式。</p><img src="image/a-map-of-the-territory/mountain.png" alt="The branching paths a language may take over the mountain." class="wide" />
<p>让我们沿着每一条路线和每一个感兴趣的地方走一遍。我们的旅程从左边的用户源代码的文本开始:</p><img src="image/a-map-of-the-territory/string.png" alt="var average = (min + max) / 2;" />
<h3><a href="#扫描" id="扫描"><small>2&#8202;.&#8202;1&#8202;.&#8202;1</small>扫描</a></h3>
<p>第一步是扫描 <strong>scanning</strong> ，也被称为词法  <strong>lexing</strong> ，或(如果你想给某人留下深刻印象)词法分析 <strong>lexical analysis</strong> 。它们的意思都差不多。我喜欢 <code>lexing</code> ，因为它听起来像邪恶的超级反派会做的事情，但我还是使用 <code>scanning</code> ，因为它似乎更加常见。</p>
<p><strong>扫描器</strong> (或 <strong>词法分析器</strong> )接收字符的输入流，并将它们组合在一起，形成一系列更类似于<span name="word">&ldquo;单词&ldquo;</span>的东西。在编程语言中，这些单词中的每一个都称为标记（<strong>Token</strong>）。有些标记是单个字符，如( <code>and</code> <code>,</code> <code>.</code> 其他的可能是几个字符，比如数字(123) ，字符串字元(  <code>"hi!"</code> )和标识符( <code>min</code> )。</p>
<aside name="word">
<p>“Lexical” 来自希腊语词根  “lex”, 意思是 “word” (单词). </p>
</aside>
<p>源文件中的某些字符实际上没有任何意义。空白通常是无关紧要的，而注释，从定义就能看出来，会被语言忽略。扫描器通常会丢弃这些标记，留下一系列有意义的标记序列。</p><img src="image/a-map-of-the-territory/tokens.png" alt="[var] [average] [=] [(] [min] [+] [max] [)] [/] [2] [;]" />
<h3><a href="#解析" id="解析"><small>2&#8202;.&#8202;1&#8202;.&#8202;2</small>解析</a></h3>
<p>下一步是解析 <strong>parsing</strong> 。这就是我们从句法获得语法 <strong>grammar</strong> 的地方ーー能够用较小的部分组成较大的表达式和语句。你在英语课上画过句子分词图吗？如果有，那么您已经完成了解析器的工作，只不过英语有成千上万的“关键字”和大量的歧义。编程语言要简单得多。</p>
<p><strong>解析器</strong> 获取标记的平面序列，并构建反映文法嵌套特性的树结构。这些树有几个不同的名称ーー <strong>解析树</strong> 或 <strong>抽象语法树</strong> ーー 这取决于它们与源语言的语法结构有多接近。在实践中，语言黑客通常称之为 <strong>语法树</strong> 、 <strong>AST</strong> 或者干脆直接称作 <strong>树</strong> 。</p><img src="image/a-map-of-the-territory/ast.png" alt="An abstract syntax tree." />
<p>解析在计算机科学中有着悠久而丰富的历史，它与人工智能界紧密相连。今天用于解析编程语言的许多技术，最初是由人工智能研究人员设想的，他们试图让计算机与我们对话，以解析人类语言。</p>
<p>事实证明，相对那些解析器能够处理的严格语法来说，人类语言太混乱了；但对于编程语言中被设计得更简单的语法，解析器便是完美适用的。唉，可惜我们这些有缺陷的人类在使用这些简单的语法时，仍然错漏百出，所以解析器的工作也包括通过报告 <strong>语法错误</strong>，让我们知道哪里错了。</p>
<h3><a href="#static-analysis-静态分析" id="static-analysis-静态分析"><small>2&#8202;.&#8202;1&#8202;.&#8202;3</small>Static analysis (静态分析)</a></h3>
<p>在所有实现中，前两个阶段都非常相似。现在，每种语言的个性特征开始发挥作用。此时，我们已经知道了代码的语法结构ーー比如哪些表达式嵌套在其他表达式中ーー但除此之外，我们所知不多。</p>
<p>在 <code>a + b</code> 这样的表达式中，我们知道要把 <code>a</code> 和 <code>b</code> 相加，但我们不知道这些名字指的是什么。它们是局部变量吗？还是全局变量？它们在哪里被定义的？</p>
<p>大多数语言所做的第一项分析被称为绑定( <strong>binding</strong> )或解析( <strong>resolution</strong> )。对于每个标识符( <strong>identifier</strong> )，我们要找出这个名字的定义位置，并将两者连接起来。这就是作用域( <strong>scope</strong> )的作用--在这个区域中，某个名字可以用来引用某个声明。</p>
<p>如果语言是<span name="type">静态类型</span>的，这时我们就需要进行类型检查。一旦我们知道 <code>a</code> 和 <code>b</code> 是在哪里声明的，我们也可以弄清它们的类型。然后，如果这些类型不支持彼此相加，我们就报告一个 <strong>类型错误</strong> 。</p>
<aside name="type">
<p>我们将在本书中构建的语言是动态类型的，所以它将在以后的运行时进行类型检查。</p>
</aside>
<p>深呼吸。我们已经到达了山顶，并对用户的程序有了全面的了解。所有这些从分析中可见的语义信息都需要存储在某个地方。我们可以把它藏在几个地方：</p>
<ul>
<li>
<p>通常，它被直接存储为语法树本身的属性(  <strong>attributes</strong>  )中--属性是节点中的额外字段，这些字段在解析过程中并没有被初始化，而是在稍后进行填充。</p>
</li>
<li>
<p>有时，我们可能会将数据存储在外部的查找表中。 通常，该表的键(key)是标识符ーー变量和声明的名称。在这种情况下，我们称之为符号表(  <strong>symbol table</strong>  )，其中的键值对告诉我们该标识符指的是什么。</p>
</li>
<li>
<p>最强大的簿记工具是将树转换成全新的数据结构，更直接地表达代码的语义。这是下一节的内容。</p>
</li>
</ul>
<p>到目前为止的一切都被视作实现的前端。你可能会猜到这之后的一切都是后端，其实不是。在“前端”( <strong>front end</strong> )和“后端”( <strong>back end</strong> )出现的年代，编译器要简单得多。后来的研究人员发明了新的阶段，塞进这两部分之间。威廉-沃尔夫和他的公司没有抛弃旧术语，而是将这些新的阶段归纳为迷人的但在空间上自相矛盾的名字--中端( <strong>middle end</strong> )。</p>
<h3><a href="#intermediate-representations中介码中间表示" id="intermediate-representations中介码中间表示"><small>2&#8202;.&#8202;1&#8202;.&#8202;4</small>Intermediate representations(中介码/中间表示)</a></h3>
<p>你可以把编译器看成是一条流水线，每个阶段的工作是把代表用户代码的数据组织起来，使下一阶段的实现更加简单。管道的前端是针对程序所使用的源语言编写的。后端关注的是程序运行的最终架构。</p>
<p>在中间阶段，代码可能被存储在一些<span name="ir">中介码 <strong>intermediate
representation</strong></span>(<strong>IR</strong>)中，这些中间表示(IR)与与源文件或目标文件都没有紧密联系(因此是“中间”)。相反，IR 充当这两种语言之间的接口。</p>
<aside name="ir">
<p>现在有几种成熟的IRs风格。点击你所选择的搜索引擎，寻找 &ldquo;控制流图&ldquo;、&ldquo;静态单赋值&ldquo;、&ldquo;延体传递风格 &ldquo;和 &ldquo;三地址码&ldquo;(&ldquo;control flow graph&rdquo;, &ldquo;static single-assignment&rdquo;, &ldquo;continuation-passing style&rdquo;,  &ldquo;three-address code&rdquo;)。</p>
</aside>
<p>这使您可以更轻松地支持多种源语言和目标平台。假设您希望实现 Pascal、 C 和 Fortran 编译器，并且希望以 x86、 ARM 和(我不知道的) SPARC 为目标。通常，这意味着您要编写九个完整的编译器: Pascal&rarr;x86，C&rarr;ARM，以及其他所有组合。</p>
<p><span name="gcc">共享</span>的中间表示极大地减少了这种情况。您可以为生成 IR 的每种源语言编写 <em>一个</em> 前端。然后为每个目标体系结构设置 <em>一个</em> 后端。现在你可以混合和匹配这些得到每种组合。</p>
<aside name="gcc">
<p>如果你曾经想知道 <a href="https://en.wikipedia.org/wiki/GNU_Compiler_Collection">GCC</a> 是如何支持这么多疯狂的语言和架构的，比如摩托罗拉68k上的Modula-3，现在你知道了。语言前端的目标是少数几个IR中的一个，主要是 <a href="https://gcc.gnu.org/onlinedocs/gccint/GIMPLE.html">GIMPLE</a> 和 <a href="https://gcc.gnu.org/onlinedocs/gccint/RTL.html">RTL</a> 。目标后端，如68k的后端，然后采用这些IRs并产生本地代码。</p>
</aside>
<p>还有一个很重要的原因，我们可能希望将代码转化为某种形式，使语义更加明确<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span></p>
<h3><a href="#优化" id="优化"><small>2&#8202;.&#8202;1&#8202;.&#8202;5</small>优化</a></h3>
<p>一旦我们理解了用户程序的含义，我们就可以自由地用另一个具有相同语义但实现效率更高的程序来交换它ーー我们可以对其进行 <strong>优化</strong>。</p>
<p>举个简单的例子, <strong>常数折叠</strong> : 如果某个表达式求值得到的始终是完全相同的值，我们可以在编译时求值，并用结果替换表达式的代码。如果用户键入以下内容:</p>
<div class="codehilite"><pre><span class="i">pennyArea</span> = <span class="n">3.14159</span> * (<span class="n">0.75</span> / <span class="n">2</span>) * (<span class="n">0.75</span> / <span class="n">2</span>);
</pre></div>
<p>我们可以在编译器中做所有这些算术，然后把代码改为:</p>
<div class="codehilite"><pre><span class="i">pennyArea</span> = <span class="n">0.4417860938</span>;
</pre></div>
<p>优化是编程语言业务的重要组成部分。许多语言黑客把他们的整个职业生涯都花在了这里，竭尽所能地从他们的编译器中榨取每一滴性能，以使他们的基准速度提高百分之零点一。优化容易上瘾。</p>
<p>在本书中，我们通常会跳过这个<span name="rathole">老鼠洞</span>。许多成功的语言的编译时优化都少得令人吃惊。例如，Lua和CPython生成相对未优化的代码，并将其大部分性能工作集中在运行时上。</p>
<aside name="rathole">
<p>如果你忍不住把脚伸进那个洞里，一些关键词可以让你开始行动，它们是 &ldquo;常量传播&ldquo;、&ldquo;公共子表达式删除&ldquo;、&ldquo;循环不变式外提&ldquo;、&ldquo;全局值编号优化&ldquo;、&ldquo;强度折减&ldquo;、&ldquo;标量替换&ldquo;、&ldquo;死码消除 &ldquo;和 &ldquo;循环展开&ldquo;。(&ldquo;constant propagation&rdquo;, &ldquo;common subexpression elimination&rdquo;, &ldquo;loop invariant code motion&rdquo;, &ldquo;global value numbering&rdquo;, &ldquo;strength reduction&rdquo;, &ldquo;scalar replacement of aggregates&rdquo;, &ldquo;dead code elimination&rdquo;, and &ldquo;loop unrolling&rdquo;)</p>
</aside>
<h3><a href="#code-generation-代码生成" id="code-generation-代码生成"><small>2&#8202;.&#8202;1&#8202;.&#8202;6</small>Code generation 代码生成</a></h3>
<p>我们已经将所有我们能想到的优化应用到用户的程序中。最后一步是将其转换为计算机实际可以运行的形式。换句话说， <strong>生成代码</strong> (或者 <strong>代码生成</strong>) ，这里的“代码”通常指的是 CPU 运行的那种类似汇编的原始指令，而不是人类可能想要读取的那种“源代码”。</p>
<p>最后，我们到了后端( <strong>back end</strong> )，从另一侧开始下山。从现在开始，我们对代码的表示变得越来越原始，就像逆向进化，因为我们越来越接近于思维简单的机器可以理解的东西。</p>
<p>我们需要做一个决定。我们是为真实的CPU生成指令还是为虚拟的CPU生成指令？如果我们生成真正的机器代码，则会得到一个可执行文件，操作系统可以直接加载到芯片上。原生代码的速度快如闪电，但生成它需要大量工作。今天的架构有成堆的指令，复杂的管线，以及足以填满747行李舱的<span name="aad">历史包袱</span>。</p>
<p>使用芯片的语言也意味着你的编译器被捆绑在一个特定的架构上。如果你的编译器以 <a href="https://en.wikipedia.org/wiki/X86">x86</a> 机器代码为目标，那么它就不能在 <a href="https://en.wikipedia.org/wiki/ARM_architecture">ARM</a> 设备上运行。早在60年代，在计算机体系结构的寒武纪大爆发期间，缺乏可移植性是一个真正的障碍。</p>
<aside name="aad">
<p>例如， <a href="http://www.felixcloutier.com/x86/AAD.html">AAD</a> （&ldquo;ASCII调整AX除法前&ldquo;）指令让你进行除法，这听起来很有用。只是这条指令的操作数是两个二进制编码的十进制数字，装入一个16位寄存器。你上次在16位机器上需要BCD是什么时候？</p>
</aside>
<p>为了解决这种情况，像 Martin Richards 和 Niklaus Wirth 这样分别以 BCPL 和 Pascal 闻名的黑客，让他们的编译器产生虚拟机代码。他们不是为某个真实的芯片编写指令，而是为一个假想的、理想化的机器编写代码。Wirth称这种代码为可移植代码( <strong>p-code</strong> for <em>portable</em>)，但今天，我们通常称它为 <strong>字节码</strong> ，因为每条指令通常只有一个字节长。</p>
<p>这些合成指令的设计目的是更贴近语言的语义，而不必与任何一种计算机体系结构的特性及其累积的历史残渣绑定在一起。你可以把它想象成语言底层操作的密集二进制编码。</p>
<h3><a href="#virtual-machine-虚拟机" id="virtual-machine-虚拟机"><small>2&#8202;.&#8202;1&#8202;.&#8202;7</small>Virtual machine 虚拟机</a></h3>
<p>如果你的编译器产生字节码，工作还没有结束。由于没有芯片能说这种字节码，你还需要进行翻译。同样，你有两个选择。你可以为每个目标架构写一个小的迷你编译器，将字节码转换为该机器的本地代码。你仍然要为你支持的<span name="shared">每一个</span>芯片做一些工作，但最后一个阶段非常简单，你可以在你支持的所有机器上重复使用编译器管道的其余部分。你基本上是把字节码作为IR在使用。</p>
<aside name="shared" class="bottom">
<p>这里的基本原则是，你把特定架构的工作在管道中推得越靠后，你就可以在不同的架构中分享更多的早期阶段的内容。</p>
<p>不过，这里存在一些矛盾。许多优化，如寄存器分配和指令选择，在了解特定芯片的优势和功能时才能发挥最佳效果。弄清楚你的编译器中哪些部分可以共享，哪些部分应该是针对特定目标的，是一门艺术。</p>
</aside>
<p>或者你可以写一个<span name="vm"><strong>虚拟机</strong></span> （ <strong>VM</strong> ），该程序可在运行时模拟支持虚拟架构的虚拟芯片。在虚拟机中运行字节码比提前将其翻译成本地代码要慢，因为每条指令在每次执行时都必须在运行时进行模拟。作为回报，你获得了简明性和可移植性。比如说用C语言实现你的虚拟机，你就可以在任何有C编译器的平台上运行你的语言。这就是我们在本书中构建的第二个解释器的工作方式。</p>
<aside name="vm">
<p>术语 &ldquo;虚拟机 &ldquo;也是指一种不同的抽象概念。一个 <strong>system virtual machine</strong>  (“系统虚拟机”)在软件中模拟了整个硬件平台和操作系统。这就是为什么你可以在Linux机器上玩Windows游戏，以及云供应商如何给客户提供控制他们自己的 &ldquo;服务器 &ldquo;的用户体验，而不需要为每个用户分配单独的计算机。</p>
<p>我们在本书中要讨论的那种虚拟机是 <strong>language virtual machines</strong> ，如果你不想搞混的话，更准确的说是 <strong>process virtual machines</strong>。</p>
</aside>
<h3><a href="#runtime-运行时" id="runtime-运行时"><small>2&#8202;.&#8202;1&#8202;.&#8202;8</small>Runtime 运行时</a></h3>
<p>我们终于将用户程序锤炼成可以执行的形式。最后一步是运行它。如果我们将它编译成机器代码，我们只需告诉操作系统加载可执行文件，然后就可以运行了。如果我们将其编译为字节码，则需要启动 VM 并将程序加载到其中。</p>
<p>在这两种情况下，除了最基本的低级语言之外，我们通常都需要在程序运行时语言提供的一些服务。例如，如果语言自动管理内存，我们需要一个垃圾收集器来回收未使用的比特位。如果我们的语言支持 instance of 测试(这样您就可以看到您拥有什么类型的对象)，那么我们就需要一些表示方法来跟踪执行过程中每个对象的类型。</p>
<p>所有这些东西都是在运行时进行的，因此它被恰当地称为 <strong>运行时</strong> 。在一个完整的编译语言中，实现运行时的代码会直接插入到生成的可执行文件中。例如，在 <a href="https://golang.org/">Go</a> 中，每个已编译的应用程序都有自己的 Go 运行时副本直接嵌入其中。如果语言是在解释器或 VM 中运行的，那么运行时就将驻留在其中。这就是 Java、 Python 和 JavaScript 等大多数语言实现的工作方式。</p>
<h2><a href="#捷径和备选路线" id="捷径和备选路线"><small>2&#8202;.&#8202;2</small>捷径和备选路线</a></h2>
<p>这是一条漫长的道路，涵盖了你要实现的每个可能的阶段。许多语言确实走完了整条路线，但也有一些捷径和备选路径。</p>
<h3><a href="#单遍编译器" id="单遍编译器"><small>2&#8202;.&#8202;2&#8202;.&#8202;1</small>单遍编译器</a></h3>
<p>一些简单的编译器将解析、分析和代码生成交织在一起，以便直接在解析器中生成输出代码，而不需要分配任何语法树或其他 IR。这些<span name="sdt"><strong>单遍编译器</strong></span>限制了语言的设计。没有中间数据结构来存储程序的全局信息，也不会重新访问任何以前解析过的代码部分。这意味着一旦看到某个表达式，就需要足够的知识来正确地对其进行编译。</p>
<aside name="sdt">
<p><a href="https://en.wikipedia.org/wiki/Syntax-directed_translation"><strong>Syntax-directed translation</strong></a> （语法导向翻译）是一种结构化的技术，用于构建这些一次性的编译器。你您可以将一个操作与语法的每个片段(通常是生成输出代码的语法片段)相关联。然后，每当解析器与那块语法相匹配时，它就会执行对应操作，一次构建一个规则的目标代码。</p>
</aside>
<p>Pascal 和 C 就是围绕这个限制设计的。当时，内存是如此宝贵，以至于编译器可能连整个源文件都无法存放在内存中，更不用说整个程序了。这就是 Pascal 语法要求类型声明块在最前面的原因。这就是为什么在 C 语言中，你不能在定义函数之前调用函数，除非你有一个显式的前向声明，告诉编译器它需要知道什么，以便生成调用后面函数的代码。</p>
<h3><a href="#树遍历解释器" id="树遍历解释器"><small>2&#8202;.&#8202;2&#8202;.&#8202;2</small>树遍历解释器</a></h3>
<p>一些编程语言在将代码解析成 AST 后就开始执行代码（也许还加了点静态分析）。为了运行程序，解释器每次都会遍历语法树的一个分支和叶子，并在运行过程中计算每个节点。</p>
<p>这种实现方式在学生项目和小型语言中很常见，但在<span name="ruby">通用语言</span>中却没有被广泛使用，因为它往往很慢。有些人认为 &ldquo;解释器&rdquo; 仅指这类实现，但其他人对这个词的定义更为宽泛，所以我将用没有歧义的 <strong>树遍历解释器</strong> 来指代这些实现。我们的第一个解释器就是这样工作的。</p>
<aside name="ruby">
<p>一个值得注意的例外是Ruby的早期版本，它使用的是树遍历解释器。在1.9版本中，Ruby的规范实现从最初的MRI（Matz&rsquo;s Ruby Interpreter）转向Koichi Sasada的YARV（Yet Another Ruby VM）。YARV是一个字节码虚拟机。</p>
</aside>
<h3><a href="#transpilers-转译器" id="transpilers-转译器"><small>2&#8202;.&#8202;2&#8202;.&#8202;3</small>Transpilers 转译器</a></h3>
<p>为一种语言<span name="gary">编写</span>一个完整的后端可能需要大量的工作。如果你有一些现有的通用IR作为目标，则可以将前端转换到该IR上。否则，您可能会陷入困境。但是，如果把其他的 <strong>源语言</strong> 视为中间表示呢？</p>
<p>您需要为您的语言编写一个前端。然后，在后端，您可以生成一份与您的语言级别差不多的其他语言的有效源代码字符串，而不是将所有代码<em>降低</em>到某个原始目标语言的语义。然后，可以使用该语言的现有编译工具作为下山的逃亡路线，得到某些可执行的内容。</p>
<p>人们过去把这叫做源到源编译器( <strong>source-to-source compiler</strong> )或转编译器( <strong>transcompiler</strong> )。随着那些为了在浏览器中运行而编译成JavaScript的各类语言的兴起，它们有了一个时髦的名字：转译器( <strong>transpiler</strong> )。</p>
<aside name="gary">
<p>第一个转编译器，XLT86，将8080程序集翻译成8086程序集。这看似简单，但请记住，8080是8位的芯片，而8086是16位的芯片，可以将每个寄存器用作一对8位寄存器。XLT86进行了数据流分析，以跟踪源程序中的寄存器使用情况，然后将其有效地映射到8086的寄存器集中。</p>
<p>计算机科学界的悲剧性英雄Gary Kildall编写了它。他是最早认识到微型计算机前景的人之一，他创造了PL/M和CP/M，这是第一个用于微型计算机的高级语言和操作系统。</p>
<p>他是一位船长、企业主、持证飞行员和摩托车手。他是一名电视节目主持人，拥有80年代潇洒的大胡子帅哥所拥有的Kris Kristofferson式的外表。他与比尔-盖茨竞争，和许多人一样，他输了，然后在神秘的情况下在一个摩托车酒吧里结束了自己的生命。他死得太早，但他活过。</p>
</aside>
<p>虽然第一个转译器是将一种汇编语言翻译成另一种语言，但现今，大多数转译器都适用于高级语言。在UNIX病毒性地传播到各种机器上之后，有了一个悠久的编译器传统，即转译器以C作为其输出语言。在UNIX存在的地方都有C语言编译器，并能产生高效的代码，因此，以C为目标是让语言在许多体系结构上运行的好方法。</p>
<p>网络浏览器是当今的 &ldquo;机器&ldquo;，而它们的 &ldquo;机器代码 &ldquo;是JavaScript，所以这些天，似乎几乎所有语言都有一个以JS为目标 <a href="https://github.com/jashkenas/coffeescript/wiki/list-of-languages-that-compile-to-js">almost every language out there</a> 的编译器，因为这是让你的代码在浏览器中运行的<span name="js">主要</span>途径。</p>
<aside name="js">
<p>JS曾经是在浏览器中执行代码的唯一方式。由于有了<a href="https://github.com/webassembly/">WebAssembly</a>，编译器现在有了第二种可以在网络上运行的较低级别的语言作为目标。</p>
</aside>
<p>转译器的前端--扫描器和解析器看起来和其他编译器一样。 然后，如果源语言只是在目标语言之上包装的简单语法外壳，则它可能会完全跳过分析，直接输出目标语言中的类似语法。</p>
<p>如果两种语言的语义差异较大，你会看到一个完整的编译器的更多典型阶段，包括分析，甚至可能是优化。然后，在代码生成阶段，无需输出一些像机器代码一样的二进制语言，而是在目标语言中产生一串语法正确的源码（嗯，目标代码）。</p>
<p>无论哪种方式，你再通过目标语言已有的编译管道运行生成的代码，就可以了。</p>
<h3><a href="#just-in-time-compilation-即时编译" id="just-in-time-compilation-即时编译"><small>2&#8202;.&#8202;2&#8202;.&#8202;4</small>Just-in-time compilation 即时编译</a></h3>
<p>这最后一条与其说是捷径，不如说是危险的高山争霸赛，最好留给专家。执行代码最快的方法是将代码编译成机器代码，但你可能不知道你的最终用户的机器支持什么架构。该怎么做呢？</p>
<p>你可以学习HotSpot Java虚拟机（JVM）、微软的 CLR 和大多数JavaScript解释器所做的同样事情。在终端用户的机器上，当程序被加载时--无论是从JS的源代码，还是JVM和CLR的平台无关的字节码--都可以将其编译为对应的本地代码，以适应本机支持的体系结构。这就叫即时编译( <strong>just-in-time compilation</strong> )。大多数黑客只是说 &ldquo;JIT&rdquo;，读起来和 &ldquo;fit &ldquo;押韵。</p>
<p>最复杂的JIT将性能分析钩子插入到生成的代码中，以查看哪些区域对性能最为关键，以及哪些类型的数据正在流经其中。 然后，随着时间的推移，它们会自动用更先进的优化方法重新编译这些<span name="hot">热点</span>区域。</p>
<aside name="hot">
<p>当然，这正是HotSpot JVM的名字来源</p>
</aside>
<h2><a href="#编译器和解释器" id="编译器和解释器"><small>2&#8202;.&#8202;3</small>编译器和解释器</a></h2>
<p>现在，我已经用字典里的编程语言术语塞满了你的脑袋，我们终于可以解决一个自古以来一直困扰着程序员的问题。编译器和解释器之间有什么区别？</p>
<p>事实证明，这就像问水果和蔬菜的区别一样。这似乎是一个二选一的选择，但实际上 &ldquo;水果 &ldquo;是一个植物学术语，而 &ldquo;蔬菜 &ldquo;是烹饪术语。严格来说，一个并不意味着对另一个的否定。有的水果不是蔬菜（苹果），有的蔬菜不是水果（胡萝卜），但也有既是水果又是蔬菜的可食用植物，如西红柿。</p>
<p><span name="veg"></span></p><img src="image/a-map-of-the-territory/plants.png" alt="A Venn diagram of edible plants" />
<aside name="veg">
<p>花生（甚至不是坚果）和小麦等谷物实际上是水果，但我把这个图画错了。我能说什么呢，我是个软件工程师，不是植物学家。我也许应该把这个花生小家伙擦掉，但他太可爱了，我不忍心擦掉。</p>
<p>现在，松子，另一方面，是基于植物的食物，既不是水果也不是蔬菜。至少在我看来是这样。</p>
</aside>
<p>所以，回到语言上。</p>
<ul>
<li>
<p><strong>编译</strong> 是一种 <em>实现技术</em> ，它涉及到将源语言翻译成某种其他的--通常是较低级别的语言--形式。当你生成字节码或机器码时，你就是在进行编译。当你转译成另一种高级语言时，你也在进行编译。</p>
</li>
<li>
<p>当我们说语言实现 &ldquo;是编译器&rdquo; 时，是指它把源代码转换成其他形式，但不执行它。用户必须拿着输出的结果，自己去运行它。</p>
</li>
<li>
<p>相反，当我们说一个实现 &ldquo;是解释器 &ldquo;时，是指它接受源代码并立即执行。它 &ldquo;从源代码&ldquo;运行程序。</p>
</li>
</ul>
<p>就像苹果和桔子一样，有些实现显然是编译器而不是解释器。GCC和Clang将你的C语言代码编译成机器代码。终端用户直接运行这个可执行文件，甚至可能不知道是用哪个工具来编译的。所以这些是C语言的编译器。</p>
<p>在Matz的Ruby经典实现的旧版本中，用户从源代码运行Ruby。该实现解析了它，并通过遍历语法树直接执行它。无论是在实现内部还是在任何用户可见的形式，都没有其他转换发生。所以这绝对是一个 Ruby 的解释器。</p>
<p>但是CPython呢？当你用它运行你的Python程序时，代码被解析并转换为内部字节码格式，然后在虚拟机内执行。从用户的角度来看，这显然是一个解释器--他们从源代码中运行他们的程序。但如果你看看CPython的名字，你会发现肯定有一些编译工作在进行。</p>
<p>答案是，它<span name="go">两者都是</span>。CPython是一个解释器，它也有一个编译器。在现实中，大多数脚本语言都是这样工作的，如您所见：</p>
<aside name="go">
<p><a href="https://golang.org/">Go tool</a>更奇葩。如果你运行 <code>go build</code> ，它会将你的Go源代码编译成机器代码，然后停下来啥也不做。如果你输入 <code>go run</code> ，它也会编译，然后立即执行生成的可执行文件。</p>
<p>所以 <code>go</code> 是一个编译器（你可以把它作为一个工具来编译代码，而不运行），是一个解释器（你可以调用它来立即运行一个源程序），包含了编译器（当你把它作为一个解释器使用时，它仍然在进行内部编译）。</p>
</aside><img src="image/a-map-of-the-territory/venn.png" alt="A Venn diagram of compilers and interpreters" />
<p>中间重叠的区域也是我们的第二个解释器所在的地方，因为它在内部编译成字节码。所以尽管这本书名义上是关于解释器的，我们也会涉及一些编译内容。</p>
<h2><a href="#我们的旅程" id="我们的旅程"><small>2&#8202;.&#8202;4</small>我们的旅程</a></h2>
<p>一下子要接受的东西太多了。不过别担心。这一章并不期望你理解所有这些零碎的内容。我只是想让你知道它们的存在，并大致了解它们是如何组合在一起的。</p>
<p>当你在本书的指导下探索其他领域时，这张地图应该对你有所帮助。我希望你主动出击，在那座山上到处闯荡。</p>
<p>但是，现在，是时候开始我们自己的旅程了。系紧你的鞋带，收紧你的背包，然后一起走吧。从span name=&ldquo;here&rdquo;&gt;现在</span>开始，你所需要关注的是你面前的道路。</p>
<aside name="here">
<p>从今往后，我保证淡化整个山体隐喻的事情。</p>
</aside>
<div class="challenges">
<h2><a href="#挑战" id="挑战"><small>2&#8202;.&#8202;5</small>挑战</a></h2>
<ol>
<li>
<p>选择一种你喜欢的语言的开源实现。下载并探索源代码索。尝试找到实现扫描器和解析器的代码。它们是手写的，还是使用Lex和Yacc等工具生成的？(<code>.I</code> 或者 <code>.y</code> 文件通常意味着的是后者。)</p>
</li>
<li>
<p>即时编译往往是实现动态类型语言的最快方式，但并不是所有的语言都使用它。有什么理由不采用JIT呢？</p>
</li>
<li>
<p>大多数编译成C语言的Lisp实现也包含一个解释器，该解释器使它们能够即时执行Lisp代码。为什么呢？</p>
</li>
</ol>
</div>

<footer>
<a href="the-lox-language.html" class="next">
  Next Chapter: &ldquo;The Lox Language&rdquo; &rarr;
</a>
Handcrafted by Robert Nystrom&ensp;&mdash;&ensp;<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy; 2015&hairsp;&ndash;&hairsp;2021</a>
</footer>
</article>

</div>
</body>
</html>
