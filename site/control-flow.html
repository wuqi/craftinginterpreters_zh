<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Control Flow &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="contents">
<h3><a href="#top">Control Flow<small>9</small></a></h3>

<ul>
    <li><a href="#图灵机-简介"><small>9.1</small> 图灵机 (简介)</a></li>
    <li><a href="#条件执行"><small>9.2</small> 条件执行</a></li>
    <li><a href="#logical-operators"><small>9.3</small> Logical Operators</a></li>
    <li><a href="#while-loops"><small>9.4</small> While Loops</a></li>
    <li><a href="#for-loops"><small>9.5</small> For Loops</a></li>
    <li class="divider"></li>
    <li class="end-part"><a href="#challenges">Challenges</a></li>
    <li class="end-part"><a href="#design-note"><small>note</small>Spoonfuls of Syntactic Sugar</a></li>
</ul>


<div class="prev-next">
    <a href="statements-and-state.html" title="Statements and State" class="left">&larr;&nbsp;Previous</a>
    <a href="a-tree-walk-interpreter.html" title="A Tree-Walk Interpreter">&uarr;&nbsp;Up</a>
    <a href="functions.html" title="Functions" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
<a href="statements-and-state.html" title="Statements and State" class="prev">←</a>
<a href="functions.html" title="Functions" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<h3><a href="#top">Control Flow<small>9</small></a></h3>

<ul>
    <li><a href="#图灵机-简介"><small>9.1</small> 图灵机 (简介)</a></li>
    <li><a href="#条件执行"><small>9.2</small> 条件执行</a></li>
    <li><a href="#logical-operators"><small>9.3</small> Logical Operators</a></li>
    <li><a href="#while-loops"><small>9.4</small> While Loops</a></li>
    <li><a href="#for-loops"><small>9.5</small> For Loops</a></li>
    <li class="divider"></li>
    <li class="end-part"><a href="#challenges">Challenges</a></li>
    <li class="end-part"><a href="#design-note"><small>note</small>Spoonfuls of Syntactic Sugar</a></li>
</ul>


<div class="prev-next">
    <a href="statements-and-state.html" title="Statements and State" class="left">&larr;&nbsp;Previous</a>
    <a href="a-tree-walk-interpreter.html" title="A Tree-Walk Interpreter">&uarr;&nbsp;Up</a>
    <a href="functions.html" title="Functions" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">9</div>
  <h1>Control Flow</h1>

<blockquote>
<p>逻辑，犹如威士忌，当过度饮用时，其益处便难以显现。</p>
<p><cite>爱德华·约翰·莫顿·德拉克斯·普兰克特，邓桑尼勋爵</cite></p>
</blockquote>
<p>与<a href="statements-and-state.html">上一章</a>艰苦的马拉松相比，本章就像在雏菊草地上轻快地嬉戏。虽然工作轻松，但回报却出乎意料地丰厚。</p>
<p>眼下，我们的解释器仅仅是一个简单的计算器而已。Lox程序在完成前只能执行有限的任务。要使其运行时间加倍，就必须让源代码变得更长。然而，我们即将改变这一现状。在本章中，我们的解释器将向编程语言的顶级联赛迈出重要一步：<em>图灵完备性</em>。</p>
<h2><a href="#图灵机-简介" id="图灵机-简介"><small>9&#8202;.&#8202;1</small>图灵机 (简介)</a></h2>
<p>在上个世纪初的早期，数学家们陷入了一系列令人困惑的<span name="paradox">悖论</span> 中，这使他们对自己建立工作基础的稳定性产生了怀疑。为了解决这一<a href="https://en.wikipedia.org/wiki/Foundations_of_mathematics#Foundational_crisis">危机</a>，他们回到了原点。他们从少数必要的基本原理、逻辑和集合论出发，希望在坚不可摧的基础上重建数学。</p>
<aside name="paradox">
<p>最有名的就是<a href="https://en.wikipedia.org/wiki/Russell%27s_paradox"><strong>罗素悖论</strong></a>了。一开始，集合论允许你定义任何类型的集合。只要你用英语描述出来，那就是有效的。因为数学家们喜欢自我引用，所以集合可以包含其他集合。于是，淘气的罗素提出了这个问题：</p>
<p><em>R是所有不包含自己的集合的集合。</em></p>
<p>R是不是包含自己呢？如果不包含自己，根据定义的后半部分，它应该包含自己。但如果它包含自己，那它就不再符合定义了。这个问题会让你的脑袋崩溃。</p>
</aside>
<p>他们想要严谨地回答这样的问题：&ldquo;所有真实的陈述都能被证明吗？&ldquo;，&ldquo;我们能<a href="https://en.wikipedia.org/wiki/Computable_function">计算</a>出我们可以定义的所有函数吗？&ldquo;，甚至更普适的问题：&ldquo;当我们声称一个函数是&rsquo;可计算的&rsquo;时，代表什么意思？&ldquo;</p>
<p>他们假设前两个问题的答案是&ldquo;是&ldquo;。剩下的就是证明它。但事实证明，这两个问题的答案都是&ldquo;否&ldquo;，而且令人惊讶的是，这两个问题是深度交织在一起的。这是数学中一个迷人的角落，涉及到关于大脑能够做什么以及宇宙如何运作的基本问题。在这里，我无法充分地解释这个问题。</p>
<p>我想要指出的是，在证明前两个问题的答案是&ldquo;不是&ldquo;的过程中，艾伦·图灵和阿隆佐·邱奇提出了一个精确的答案来回答最后一个问题——什么样的函数是<span name="uncomputable">可计算的</span>。他们各自设计了一个简单的系统，只用了最基本的工具，但仍然足够强大，可以计算出任意超大类函数。</p>
<aside name="uncomputable">
<p>他们通过展示一个返回给定语句真值的函数<em>不是</em>可计算函数来证明第一个问题的答案是&ldquo;否&ldquo;。</p>
</aside>
<p>这些现在被称为&ldquo;可计算函数&ldquo;。图灵的系统被称为<span name="turing"><strong>图灵机</strong></span>。邱奇的系统被称为<strong>λ演算</strong>。这两种系统仍然被广泛用作计算模型的基础，实际上，许多现代的函数式编程语言都以λ演算为核心。</p>
<aside name="turing">
<p>图灵称他的发明为&ldquo;a-machines&rdquo;，意为&ldquo;自动的&ldquo;(automatic)。他并没有过分自夸地将<em>自己的</em>名字放在这些发明上。后来的数学家们替他做了这件事。这就是如何在保持一些谦逊的同时获得名声的方法。</p>
</aside><img src="image/control-flow/turing-machine.png" alt="A Turing machine." />
<p>图灵机在名字上更有知名度——毕竟至今还没有关于阿隆佐·邱奇的好莱坞电影——但这两种形式化方法在能力上是<a href="https://en.wikipedia.org/wiki/Church%E2%80%93Turing_thesis">等效的</a>。实际上，任何具有一定表达能力的编程语言都足够强大，可以计算任何可<em>计算</em>函数。</p>
<p>你可以通过在你的编程语言中编写一个图灵机模拟器来证明这一点。由于图灵证明了他的机器可以计算任何可计算函数，因此可以推断出，你的编程语言也可以。你只需要将函数转换为图灵机，然后在模拟器上运行即可。</p>
<p>如果你的编程语言足够表达力，它被认为是<strong>图灵完备</strong>的。图灵机非常简单，所以并不需要太多的能力来实现这一点。基本上，你只需要算术运算、一些控制流程以及分配和使用（理论上）任意数量的内存的能力。我们已经具备了第一个条件。在本章结束时，我们将具备<span name="memory">第二个条件</span>。</p>
<aside name="memory">
<p>我们<em>几乎</em>也满足了第三个条件。你可以创建和连接任意大小的字符串，因此你可以<em>存储</em>无限的内存。但我们还无法访问字符串的各个部分。</p>
</aside>
<h2><a href="#条件执行" id="条件执行"><small>9&#8202;.&#8202;2</small>条件执行</a></h2>
<p>不再啰嗦历史了，让我们给我们的语言加点料吧。控制流可以大致分为两种类型：</p>
<ul>
<li>
<p><strong>条件</strong>或<strong>分支控制流</strong>用于<em>不</em>执行某段代码。从命令式的角度来看，你可以将其视为<em>跳过</em>一段代码的执行。</p>
</li>
<li>
<p><strong>循环控制流</strong>用于多次执行一段代码。它会跳回到某个位置，以便再次执行相同的操作。由于通常不希望出现<em>无限</em>循环，循环控制流通常会包含一些条件逻辑，以确定何时停止循环。</p>
</li>
</ul>
<p>分支控制流比较简单，所以我们先从这里开始讲解。C语言衍生的语言有两个主要的条件执行特性，<code>if</code> 语句和“条件”<span name="ternary">运算符</span> （<code>?:</code>）。<code>if</code>语句允许您有条件地执行语句，而条件运算符允许您有条件地执行表达式。</p>
<aside name="ternary">
<p>条件运算符也被称为“三元”运算符，因为它是C语言中唯一接受三个操作数的运算符。</p>
</aside>
<p>为了简单起见，Lox没有条件运算符，所以让我们直接开始<code>if</code>语句吧。我们的语句语法需要一个新的生成式。</p>
<p><span name="semicolon"></span></p>
<div class="codehilite"><pre><span class="i">statement</span>      → <span class="i">exprStmt</span>
               | <span class="i">ifStmt</span>
               | <span class="i">printStmt</span>
               | <span class="i">block</span> ;

<span class="i">ifStmt</span>         → <span class="s">&quot;if&quot;</span> <span class="s">&quot;(&quot;</span> <span class="i">expression</span> <span class="s">&quot;)&quot;</span> <span class="i">statement</span>
               ( <span class="s">&quot;else&quot;</span> <span class="i">statement</span> )? ;
</pre></div>
<aside name="semicolon">
<p>The semicolons in the rules aren&rsquo;t quoted, which means they are part of the
grammar metasyntax, not Lox&rsquo;s syntax. A block does not have a <code>;</code> at the end and
an <code>if</code> statement doesn&rsquo;t either, unless the then or else statement happens to
be one that ends in a semicolon.</p>
</aside>
<p>An <code>if</code> statement has an expression for the condition, then a statement to execute
if the condition is truthy. Optionally, it may also have an <code>else</code> keyword and a
statement to execute if the condition is falsey. The <span name="if-ast">syntax
tree node</span> has fields for each of those three pieces.</p>
<div class="codehilite"><pre class="insert-before">      &quot;Expression : Expr expression&quot;,
</pre><div class="source-file"><em>com\craftinginterpreters\tool\GenerateAst.java</em><br>
in <em>main</em>()</div>
<pre class="insert">      <span class="s">&quot;If         : Expr condition, Stmt thenBranch,&quot;</span> +
                  <span class="s">&quot; Stmt elseBranch&quot;</span>,
</pre><pre class="insert-after">      &quot;Print      : Expr expression&quot;,
</pre></div>
<div class="source-file-narrow"><em>com\craftinginterpreters\tool\GenerateAst.java</em>, in <em>main</em>()</div>

<aside name="if-ast">
<p>The generated code for the new node is in <a href="appendix-ii.html#if-statement">Appendix II</a>.</p>
</aside>
<p>Like other statements, the parser recognizes an <code>if</code> statement by the leading
<code>if</code> keyword.</p>
<div class="codehilite"><pre class="insert-before">  private Stmt statement() {
</pre><div class="source-file"><em>com\craftinginterpreters\lox\Parser.java</em><br>
in <em>statement</em>()</div>
<pre class="insert">    <span class="k">if</span> (<span class="i">match</span>(<span class="i">IF</span>)) <span class="k">return</span> <span class="i">ifStatement</span>();
</pre><pre class="insert-after">    if (match(PRINT)) return printStatement();
</pre></div>
<div class="source-file-narrow"><em>com\craftinginterpreters\lox\Parser.java</em>, in <em>statement</em>()</div>

<p>When it finds one, it calls this new method to parse the rest:</p>
<div class="codehilite"><div class="source-file"><em>com\craftinginterpreters\lox\Parser.java</em><br>
add after <em>statement</em>()</div>
<pre>  <span class="k">private</span> <span class="t">Stmt</span> <span class="i">ifStatement</span>() {
    <span class="i">consume</span>(<span class="i">LEFT_PAREN</span>, <span class="s">&quot;Expect &#39;(&#39; after &#39;if&#39;.&quot;</span>);
    <span class="t">Expr</span> <span class="i">condition</span> = <span class="i">expression</span>();
    <span class="i">consume</span>(<span class="i">RIGHT_PAREN</span>, <span class="s">&quot;Expect &#39;)&#39; after if condition.&quot;</span>);<span name="parens"> </span>

    <span class="t">Stmt</span> <span class="i">thenBranch</span> = <span class="i">statement</span>();
    <span class="t">Stmt</span> <span class="i">elseBranch</span> = <span class="k">null</span>;
    <span class="k">if</span> (<span class="i">match</span>(<span class="i">ELSE</span>)) {
      <span class="i">elseBranch</span> = <span class="i">statement</span>();
    }

    <span class="k">return</span> <span class="k">new</span> <span class="t">Stmt</span>.<span class="t">If</span>(<span class="i">condition</span>, <span class="i">thenBranch</span>, <span class="i">elseBranch</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>com\craftinginterpreters\lox\Parser.java</em>, add after <em>statement</em>()</div>

<aside name="parens">
<p>The parentheses around the condition are only half useful. You need some kind of
delimiter <em>between</em> the condition and the then statement, otherwise the parser
can&rsquo;t tell when it has reached the end of the condition expression. But the
<em>opening</em> parenthesis after <code>if</code> doesn&rsquo;t do anything useful. Dennis Ritchie put
it there so he could use <code>)</code> as the ending delimiter without having unbalanced
parentheses.</p>
<p>Other languages like Lua and some BASICs use a keyword like <code>then</code> as the ending
delimiter and don&rsquo;t have anything before the condition. Go and Swift instead
require the statement to be a braced block. That lets them use the <code>{</code> at the
beginning of the statement to tell when the condition is done.</p>
</aside>
<p>As usual, the parsing code hews closely to the grammar. It detects an else
clause by looking for the preceding <code>else</code> keyword. If there isn&rsquo;t one, the
<code>elseBranch</code> field in the syntax tree is <code>null</code>.</p>
<p>That seemingly innocuous optional else has, in fact, opened up an ambiguity in
our grammar. Consider:</p>
<div class="codehilite"><pre><span class="k">if</span> (<span class="i">first</span>) <span class="k">if</span> (<span class="i">second</span>) <span class="i">whenTrue</span>(); <span class="k">else</span> <span class="i">whenFalse</span>();
</pre></div>
<p>Here&rsquo;s the riddle: Which <code>if</code> statement does that else clause belong to? This
isn&rsquo;t just a theoretical question about how we notate our grammar. It actually
affects how the code executes:</p>
<ul>
<li>
<p>If we attach the else to the first <code>if</code> statement, then <code>whenFalse()</code> is
called if <code>first</code> is falsey, regardless of what value <code>second</code> has.</p>
</li>
<li>
<p>If we attach it to the second <code>if</code> statement, then <code>whenFalse()</code> is only
called if <code>first</code> is truthy and <code>second</code> is falsey.</p>
</li>
</ul>
<p>Since else clauses are optional, and there is no explicit delimiter marking the
end of the <code>if</code> statement, the grammar is ambiguous when you nest <code>if</code>s in this
way. This classic pitfall of syntax is called the <strong><a href="https://en.wikipedia.org/wiki/Dangling_else">dangling else</a></strong> problem.</p>
<p><span name="else"></span></p><img class="above" src="image/control-flow/dangling-else.png" alt="Two ways the else can be interpreted." />
<aside name="else">
<p>Here, formatting highlights the two ways the else could be parsed. But note that
since whitespace characters are ignored by the parser, this is only a guide to
the human reader.</p>
</aside>
<p>It <em>is</em> possible to define a context-free grammar that avoids the ambiguity
directly, but it requires splitting most of the statement rules into pairs, one
that allows an <code>if</code> with an <code>else</code> and one that doesn&rsquo;t. It&rsquo;s annoying.</p>
<p>Instead, most languages and parsers avoid the problem in an ad hoc way. No
matter what hack they use to get themselves out of the trouble, they always
choose the same interpretation<span class="em">&mdash;</span>the <code>else</code> is bound to the nearest <code>if</code> that
precedes it.</p>
<p>Our parser conveniently does that already. Since <code>ifStatement()</code> eagerly looks
for an <code>else</code> before returning, the innermost call to a nested series will claim
the else clause for itself before returning to the outer <code>if</code> statements.</p>
<p>Syntax in hand, we are ready to interpret.</p>
<div class="codehilite"><div class="source-file"><em>com\craftinginterpreters\lox\Interpreter.java</em><br>
add after <em>visitExpressionStmt</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitIfStmt</span>(<span class="t">Stmt</span>.<span class="t">If</span> <span class="i">stmt</span>) {
    <span class="k">if</span> (<span class="i">isTruthy</span>(<span class="i">evaluate</span>(<span class="i">stmt</span>.<span class="i">condition</span>))) {
      <span class="i">execute</span>(<span class="i">stmt</span>.<span class="i">thenBranch</span>);
    } <span class="k">else</span> <span class="k">if</span> (<span class="i">stmt</span>.<span class="i">elseBranch</span> != <span class="k">null</span>) {
      <span class="i">execute</span>(<span class="i">stmt</span>.<span class="i">elseBranch</span>);
    }
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>com\craftinginterpreters\lox\Interpreter.java</em>, add after <em>visitExpressionStmt</em>()</div>

<p>The interpreter implementation is a thin wrapper around the self-same Java code.
It evaluates the condition. If truthy, it executes the then branch. Otherwise,
if there is an else branch, it executes that.</p>
<p>If you compare this code to how the interpreter handles other syntax we&rsquo;ve
implemented, the part that makes control flow special is that Java <code>if</code>
statement. Most other syntax trees always evaluate their subtrees. Here, we may
not evaluate the then or else statement. If either of those has a side effect,
the choice not to evaluate it becomes user visible.</p>
<h2><a href="#logical-operators" id="logical-operators"><small>9&#8202;.&#8202;3</small>Logical Operators</a></h2>
<p>Since we don&rsquo;t have the conditional operator, you might think we&rsquo;re done with
branching, but no. Even without the ternary operator, there are two other
operators that are technically control flow constructs<span class="em">&mdash;</span>the logical operators
<code>and</code> and <code>or</code>.</p>
<p>These aren&rsquo;t like other binary operators because they <strong>short-circuit</strong>. If,
after evaluating the left operand, we know what the result of the logical
expression must be, we don&rsquo;t evaluate the right operand. For example:</p>
<div class="codehilite"><pre><span class="k">false</span> <span class="k">and</span> <span class="i">sideEffect</span>();
</pre></div>
<p>For an <code>and</code> expression to evaluate to something truthy, both operands must be
truthy. We can see as soon as we evaluate the left <code>false</code> operand that that
isn&rsquo;t going to be the case, so there&rsquo;s no need to evaluate <code>sideEffect()</code> and it
gets skipped.</p>
<p>This is why we didn&rsquo;t implement the logical operators with the other binary
operators. Now we&rsquo;re ready. The two new operators are low in the precedence
table. Similar to <code>||</code> and <code>&amp;&amp;</code> in C, they each have their <span
name="logical">own</span> precedence with <code>or</code> lower than <code>and</code>. We slot them
right between <code>assignment</code> and <code>equality</code>.</p>
<aside name="logical">
<p>I&rsquo;ve always wondered why they don&rsquo;t have the same precedence, like the various
comparison or equality operators do.</p>
</aside>
<div class="codehilite"><pre><span class="i">expression</span>     → <span class="i">assignment</span> ;
<span class="i">assignment</span>     → <span class="t">IDENTIFIER</span> <span class="s">&quot;=&quot;</span> <span class="i">assignment</span>
               | <span class="i">logic_or</span> ;
<span class="i">logic_or</span>       → <span class="i">logic_and</span> ( <span class="s">&quot;or&quot;</span> <span class="i">logic_and</span> )* ;
<span class="i">logic_and</span>      → <span class="i">equality</span> ( <span class="s">&quot;and&quot;</span> <span class="i">equality</span> )* ;
</pre></div>
<p>Instead of falling back to <code>equality</code>, <code>assignment</code> now cascades to <code>logic_or</code>.
The two new rules, <code>logic_or</code> and <code>logic_and</code>, are <span
name="same">similar</span> to other binary operators. Then <code>logic_and</code> calls
out to <code>equality</code> for its operands, and we chain back to the rest of the
expression rules.</p>
<aside name="same">
<p>The <em>syntax</em> doesn&rsquo;t care that they short-circuit. That&rsquo;s a semantic concern.</p>
</aside>
<p>We could reuse the existing Expr.Binary class for these two new expressions
since they have the same fields. But then <code>visitBinaryExpr()</code> would have to
check to see if the operator is one of the logical operators and use a different
code path to handle the short circuiting. I think it&rsquo;s cleaner to define a <span
name="logical-ast">new class</span> for these operators so that they get their
own visit method.</p>
<div class="codehilite"><pre class="insert-before">      &quot;Literal  : Object value&quot;,
</pre><div class="source-file"><em>com\craftinginterpreters\tool\GenerateAst.java</em><br>
in <em>main</em>()</div>
<pre class="insert">      <span class="s">&quot;Logical  : Expr left, Token operator, Expr right&quot;</span>,
</pre><pre class="insert-after">      &quot;Unary    : Token operator, Expr right&quot;,
</pre></div>
<div class="source-file-narrow"><em>com\craftinginterpreters\tool\GenerateAst.java</em>, in <em>main</em>()</div>

<aside name="logical-ast">
<p>The generated code for the new node is in <a href="appendix-ii.html#logical-expression">Appendix II</a>.</p>
</aside>
<p>To weave the new expressions into the parser, we first change the parsing code
for assignment to call <code>or()</code>.</p>
<div class="codehilite"><pre class="insert-before">  private Expr assignment() {
</pre><div class="source-file"><em>com\craftinginterpreters\lox\Parser.java</em><br>
in <em>assignment</em>()<br>
replace 1 line</div>
<pre class="insert">    <span class="t">Expr</span> <span class="i">expr</span> = <span class="i">or</span>();
</pre><pre class="insert-after">

    if (match(EQUAL)) {
</pre></div>
<div class="source-file-narrow"><em>com\craftinginterpreters\lox\Parser.java</em>, in <em>assignment</em>(), replace 1 line</div>

<p>The code to parse a series of <code>or</code> expressions mirrors other binary operators.</p>
<div class="codehilite"><div class="source-file"><em>com\craftinginterpreters\lox\Parser.java</em><br>
add after <em>assignment</em>()</div>
<pre>  <span class="k">private</span> <span class="t">Expr</span> <span class="i">or</span>() {
    <span class="t">Expr</span> <span class="i">expr</span> = <span class="i">and</span>();

    <span class="k">while</span> (<span class="i">match</span>(<span class="i">OR</span>)) {
      <span class="t">Token</span> <span class="i">operator</span> = <span class="i">previous</span>();
      <span class="t">Expr</span> <span class="i">right</span> = <span class="i">and</span>();
      <span class="i">expr</span> = <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Logical</span>(<span class="i">expr</span>, <span class="i">operator</span>, <span class="i">right</span>);
    }

    <span class="k">return</span> <span class="i">expr</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>com\craftinginterpreters\lox\Parser.java</em>, add after <em>assignment</em>()</div>

<p>Its operands are the next higher level of precedence, the new <code>and</code> expression.</p>
<div class="codehilite"><div class="source-file"><em>com\craftinginterpreters\lox\Parser.java</em><br>
add after <em>or</em>()</div>
<pre>  <span class="k">private</span> <span class="t">Expr</span> <span class="i">and</span>() {
    <span class="t">Expr</span> <span class="i">expr</span> = <span class="i">equality</span>();

    <span class="k">while</span> (<span class="i">match</span>(<span class="i">AND</span>)) {
      <span class="t">Token</span> <span class="i">operator</span> = <span class="i">previous</span>();
      <span class="t">Expr</span> <span class="i">right</span> = <span class="i">equality</span>();
      <span class="i">expr</span> = <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Logical</span>(<span class="i">expr</span>, <span class="i">operator</span>, <span class="i">right</span>);
    }

    <span class="k">return</span> <span class="i">expr</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>com\craftinginterpreters\lox\Parser.java</em>, add after <em>or</em>()</div>

<p>That calls <code>equality()</code> for its operands, and with that, the expression parser
is all tied back together again. We&rsquo;re ready to interpret.</p>
<div class="codehilite"><div class="source-file"><em>com\craftinginterpreters\lox\Interpreter.java</em><br>
add after <em>visitLiteralExpr</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Object</span> <span class="i">visitLogicalExpr</span>(<span class="t">Expr</span>.<span class="t">Logical</span> <span class="i">expr</span>) {
    <span class="t">Object</span> <span class="i">left</span> = <span class="i">evaluate</span>(<span class="i">expr</span>.<span class="i">left</span>);

    <span class="k">if</span> (<span class="i">expr</span>.<span class="i">operator</span>.<span class="i">type</span> == <span class="t">TokenType</span>.<span class="i">OR</span>) {
      <span class="k">if</span> (<span class="i">isTruthy</span>(<span class="i">left</span>)) <span class="k">return</span> <span class="i">left</span>;
    } <span class="k">else</span> {
      <span class="k">if</span> (!<span class="i">isTruthy</span>(<span class="i">left</span>)) <span class="k">return</span> <span class="i">left</span>;
    }

    <span class="k">return</span> <span class="i">evaluate</span>(<span class="i">expr</span>.<span class="i">right</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>com\craftinginterpreters\lox\Interpreter.java</em>, add after <em>visitLiteralExpr</em>()</div>

<p>If you compare this to the <a href="evaluating-expressions.html">earlier chapter&rsquo;s</a> <code>visitBinaryExpr()</code>
method, you can see the difference. Here, we evaluate the left operand first. We
look at its value to see if we can short-circuit. If not, and only then, do we
evaluate the right operand.</p>
<p>The other interesting piece here is deciding what actual value to return. Since
Lox is dynamically typed, we allow operands of any type and use truthiness to
determine what each operand represents. We apply similar reasoning to the
result. Instead of promising to literally return <code>true</code> or <code>false</code>, a logic
operator merely guarantees it will return a value with appropriate truthiness.</p>
<p>Fortunately, we have values with proper truthiness right at hand<span class="em">&mdash;</span>the results
of the operands themselves. So we use those. For example:</p>
<div class="codehilite"><pre><span class="k">print</span> <span class="s">&quot;hi&quot;</span> <span class="k">or</span> <span class="n">2</span>; <span class="c">// &quot;hi&quot;.</span>
<span class="k">print</span> <span class="k">nil</span> <span class="k">or</span> <span class="s">&quot;yes&quot;</span>; <span class="c">// &quot;yes&quot;.</span>
</pre></div>
<p>On the first line, <code>"hi"</code> is truthy, so the <code>or</code> short-circuits and returns
that. On the second line, <code>nil</code> is falsey, so it evaluates and returns the
second operand, <code>"yes"</code>.</p>
<p>That covers all of the branching primitives in Lox. We&rsquo;re ready to jump ahead to
loops. You see what I did there? <em>Jump. Ahead.</em> Get it? See, it&rsquo;s like a
reference to<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>oh, forget it.</p>
<h2><a href="#while-loops" id="while-loops"><small>9&#8202;.&#8202;4</small>While Loops</a></h2>
<p>Lox features two looping control flow statements, <code>while</code> and <code>for</code>. The <code>while</code>
loop is the simpler one, so we&rsquo;ll start there. Its grammar is the same as in C.</p>
<div class="codehilite"><pre><span class="i">statement</span>      → <span class="i">exprStmt</span>
               | <span class="i">ifStmt</span>
               | <span class="i">printStmt</span>
               | <span class="i">whileStmt</span>
               | <span class="i">block</span> ;

<span class="i">whileStmt</span>      → <span class="s">&quot;while&quot;</span> <span class="s">&quot;(&quot;</span> <span class="i">expression</span> <span class="s">&quot;)&quot;</span> <span class="i">statement</span> ;
</pre></div>
<p>We add another clause to the statement rule that points to the new rule for
while. It takes a <code>while</code> keyword, followed by a parenthesized condition
expression, then a statement for the body. That new grammar rule gets a <span
name="while-ast">syntax tree node</span>.</p>
<div class="codehilite"><pre class="insert-before">      &quot;Print      : Expr expression&quot;,
</pre><pre class="insert-before">      <span class="s">&quot;Var        : Token name, Expr initializer&quot;</span><span class="insert-comma">,</span>
</pre><div class="source-file"><em>com\craftinginterpreters\tool\GenerateAst.java</em><br>
in <em>main</em>()<br>
add <em>&ldquo;,&rdquo;</em> to previous line</div>
<pre class="insert">      <span class="s">&quot;While      : Expr condition, Stmt body&quot;</span>
</pre><pre class="insert-after">    ));
</pre></div>
<div class="source-file-narrow"><em>com\craftinginterpreters\tool\GenerateAst.java</em>, in <em>main</em>(), add <em>&ldquo;,&rdquo;</em> to previous line</div>

<aside name="while-ast">
<p>The generated code for the new node is in <a href="appendix-ii.html#while-statement">Appendix II</a>.</p>
</aside>
<p>The node stores the condition and body. Here you can see why it&rsquo;s nice to have
separate base classes for expressions and statements. The field declarations
make it clear that the condition is an expression and the body is a statement.</p>
<p>Over in the parser, we follow the same process we used for <code>if</code> statements.
First, we add another case in <code>statement()</code> to detect and match the leading
keyword.</p>
<div class="codehilite"><pre class="insert-before">    if (match(PRINT)) return printStatement();
</pre><div class="source-file"><em>com\craftinginterpreters\lox\Parser.java</em><br>
in <em>statement</em>()</div>
<pre class="insert">    <span class="k">if</span> (<span class="i">match</span>(<span class="i">WHILE</span>)) <span class="k">return</span> <span class="i">whileStatement</span>();
</pre><pre class="insert-after">    if (match(LEFT_BRACE)) return new Stmt.Block(block());
</pre></div>
<div class="source-file-narrow"><em>com\craftinginterpreters\lox\Parser.java</em>, in <em>statement</em>()</div>

<p>That delegates the real work to this method:</p>
<div class="codehilite"><div class="source-file"><em>com\craftinginterpreters\lox\Parser.java</em><br>
add after <em>varDeclaration</em>()</div>
<pre>  <span class="k">private</span> <span class="t">Stmt</span> <span class="i">whileStatement</span>() {
    <span class="i">consume</span>(<span class="i">LEFT_PAREN</span>, <span class="s">&quot;Expect &#39;(&#39; after &#39;while&#39;.&quot;</span>);
    <span class="t">Expr</span> <span class="i">condition</span> = <span class="i">expression</span>();
    <span class="i">consume</span>(<span class="i">RIGHT_PAREN</span>, <span class="s">&quot;Expect &#39;)&#39; after condition.&quot;</span>);
    <span class="t">Stmt</span> <span class="i">body</span> = <span class="i">statement</span>();

    <span class="k">return</span> <span class="k">new</span> <span class="t">Stmt</span>.<span class="t">While</span>(<span class="i">condition</span>, <span class="i">body</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>com\craftinginterpreters\lox\Parser.java</em>, add after <em>varDeclaration</em>()</div>

<p>The grammar is dead simple and this is a straight translation of it to Java.
Speaking of translating straight to Java, here&rsquo;s how we execute the new syntax:</p>
<div class="codehilite"><div class="source-file"><em>com\craftinginterpreters\lox\Interpreter.java</em><br>
add after <em>visitVarStmt</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitWhileStmt</span>(<span class="t">Stmt</span>.<span class="t">While</span> <span class="i">stmt</span>) {
    <span class="k">while</span> (<span class="i">isTruthy</span>(<span class="i">evaluate</span>(<span class="i">stmt</span>.<span class="i">condition</span>))) {
      <span class="i">execute</span>(<span class="i">stmt</span>.<span class="i">body</span>);
    }
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>com\craftinginterpreters\lox\Interpreter.java</em>, add after <em>visitVarStmt</em>()</div>

<p>Like the visit method for <code>if</code>, this visitor uses the corresponding Java
feature. This method isn&rsquo;t complex, but it makes Lox much more powerful. We can
finally write a program whose running time isn&rsquo;t strictly bound by the length of
the source code.</p>
<h2><a href="#for-loops" id="for-loops"><small>9&#8202;.&#8202;5</small>For Loops</a></h2>
<p>We&rsquo;re down to the last control flow construct, <span name="for">Ye Olde</span>
C-style <code>for</code> loop. I probably don&rsquo;t need to remind you, but it looks like this:</p>
<div class="codehilite"><pre><span class="k">for</span> (<span class="k">var</span> <span class="i">i</span> = <span class="n">0</span>; <span class="i">i</span> &lt; <span class="n">10</span>; <span class="i">i</span> = <span class="i">i</span> + <span class="n">1</span>) <span class="k">print</span> <span class="i">i</span>;
</pre></div>
<p>In grammarese, that&rsquo;s:</p>
<div class="codehilite"><pre><span class="i">statement</span>      → <span class="i">exprStmt</span>
               | <span class="i">forStmt</span>
               | <span class="i">ifStmt</span>
               | <span class="i">printStmt</span>
               | <span class="i">whileStmt</span>
               | <span class="i">block</span> ;

<span class="i">forStmt</span>        → <span class="s">&quot;for&quot;</span> <span class="s">&quot;(&quot;</span> ( <span class="i">varDecl</span> | <span class="i">exprStmt</span> | <span class="s">&quot;;&quot;</span> )
                 <span class="i">expression</span>? <span class="s">&quot;;&quot;</span>
                 <span class="i">expression</span>? <span class="s">&quot;)&quot;</span> <span class="i">statement</span> ;
</pre></div>
<aside name="for">
<p>Most modern languages have a higher-level looping statement for iterating over
arbitrary user-defined sequences. C# has <code>foreach</code>, Java has &ldquo;enhanced for&rdquo;,
even C++ has range-based <code>for</code> statements now. Those offer cleaner syntax than
C&rsquo;s <code>for</code> statement by implicitly calling into an iteration protocol that the
object being looped over supports.</p>
<p>I love those. For Lox, though, we&rsquo;re limited by building up the interpreter a
chapter at a time. We don&rsquo;t have objects and methods yet, so we have no way of
defining an iteration protocol that the <code>for</code> loop could use. So we&rsquo;ll stick
with the old school C <code>for</code> loop. Think of it as &ldquo;vintage&rdquo;. The fixie of control
flow statements.</p>
</aside>
<p>Inside the parentheses, you have three clauses separated by semicolons:</p>
<ol>
<li>
<p>The first clause is the <em>initializer</em>. It is executed exactly once, before
anything else. It&rsquo;s usually an expression, but for convenience, we also
allow a variable declaration. In that case, the variable is scoped to the
rest of the <code>for</code> loop<span class="em">&mdash;</span>the other two clauses and the body.</p>
</li>
<li>
<p>Next is the <em>condition</em>. As in a <code>while</code> loop, this expression controls when
to exit the loop. It&rsquo;s evaluated once at the beginning of each iteration,
including the first. If the result is truthy, it executes the loop body.
Otherwise, it bails.</p>
</li>
<li>
<p>The last clause is the <em>increment</em>. It&rsquo;s an arbitrary expression that does
some work at the end of each loop iteration. The result of the expression is
discarded, so it must have a side effect to be useful. In practice, it
usually increments a variable.</p>
</li>
</ol>
<p>Any of these clauses can be omitted. Following the closing parenthesis is a
statement for the body, which is typically a block.</p>
<h3><a href="#desugaring" id="desugaring"><small>9&#8202;.&#8202;5&#8202;.&#8202;1</small>Desugaring</a></h3>
<p>That&rsquo;s a lot of machinery, but note that none of it does anything you couldn&rsquo;t
do with the statements we already have. If <code>for</code> loops didn&rsquo;t support
initializer clauses, you could just put the initializer expression before the
<code>for</code> statement. Without an increment clause, you could simply put the increment
expression at the end of the body yourself.</p>
<p>In other words, Lox doesn&rsquo;t <em>need</em> <code>for</code> loops, they just make some common code
patterns more pleasant to write. These kinds of features are called <span
name="sugar"><strong>syntactic sugar</strong></span>. For example, the previous <code>for</code> loop
could be rewritten like so:</p>
<aside name="sugar">
<p>This delightful turn of phrase was coined by Peter J. Landin in 1964 to describe
how some of the nice expression forms supported by languages like ALGOL were a
sweetener sprinkled over the more fundamental<span class="em">&mdash;</span>but presumably less palatable<span class="em">&mdash;</span>lambda calculus underneath.</p><img class="above" src="image/control-flow/sugar.png" alt="Slightly more than a spoonful of sugar." />
</aside>
<div class="codehilite"><pre>{
  <span class="k">var</span> <span class="i">i</span> = <span class="n">0</span>;
  <span class="k">while</span> (<span class="i">i</span> &lt; <span class="n">10</span>) {
    <span class="k">print</span> <span class="i">i</span>;
    <span class="i">i</span> = <span class="i">i</span> + <span class="n">1</span>;
  }
}
</pre></div>
<p>This script has the exact same semantics as the previous one, though it&rsquo;s not as
easy on the eyes. Syntactic sugar features like Lox&rsquo;s <code>for</code> loop make a language
more pleasant and productive to work in. But, especially in sophisticated
language implementations, every language feature that requires back-end support
and optimization is expensive.</p>
<p>We can have our cake and eat it too by <span
name="caramel"><strong>desugaring</strong></span>. That funny word describes a process where
the front end takes code using syntax sugar and translates it to a more
primitive form that the back end already knows how to execute.</p>
<aside name="caramel">
<p>Oh, how I wish the accepted term for this was &ldquo;caramelization&rdquo;. Why introduce a
metaphor if you aren&rsquo;t going to stick with it?</p>
</aside>
<p>We&rsquo;re going to desugar <code>for</code> loops to the <code>while</code> loops and other statements the
interpreter already handles. In our simple interpreter, desugaring really
doesn&rsquo;t save us much work, but it does give me an excuse to introduce you to the
technique. So, unlike the previous statements, we <em>won&rsquo;t</em> add a new syntax tree
node. Instead, we go straight to parsing. First, add an import we&rsquo;ll need soon.</p>
<div class="codehilite"><pre class="insert-before">import java.util.ArrayList;
</pre><div class="source-file"><em>com\craftinginterpreters\lox\Parser.java</em></div>
<pre class="insert"><span class="k">import</span> <span class="i">java.util.Arrays</span>;
</pre><pre class="insert-after">import java.util.List;
</pre></div>
<div class="source-file-narrow"><em>com\craftinginterpreters\lox\Parser.java</em></div>

<p>Like every statement, we start parsing a <code>for</code> loop by matching its keyword.</p>
<div class="codehilite"><pre class="insert-before">  private Stmt statement() {
</pre><div class="source-file"><em>com\craftinginterpreters\lox\Parser.java</em><br>
in <em>statement</em>()</div>
<pre class="insert">    <span class="k">if</span> (<span class="i">match</span>(<span class="i">FOR</span>)) <span class="k">return</span> <span class="i">forStatement</span>();
</pre><pre class="insert-after">    if (match(IF)) return ifStatement();
</pre></div>
<div class="source-file-narrow"><em>com\craftinginterpreters\lox\Parser.java</em>, in <em>statement</em>()</div>

<p>Here is where it gets interesting. The desugaring is going to happen here, so
we&rsquo;ll build this method a piece at a time, starting with the opening parenthesis
before the clauses.</p>
<div class="codehilite"><div class="source-file"><em>com\craftinginterpreters\lox\Parser.java</em><br>
add after <em>statement</em>()</div>
<pre>  <span class="k">private</span> <span class="t">Stmt</span> <span class="i">forStatement</span>() {
    <span class="i">consume</span>(<span class="i">LEFT_PAREN</span>, <span class="s">&quot;Expect &#39;(&#39; after &#39;for&#39;.&quot;</span>);

    <span class="c">// More here...</span>
  }
</pre></div>
<div class="source-file-narrow"><em>com\craftinginterpreters\lox\Parser.java</em>, add after <em>statement</em>()</div>

<p>The first clause following that is the initializer.</p>
<div class="codehilite"><pre class="insert-before">    consume(LEFT_PAREN, &quot;Expect '(' after 'for'.&quot;);

</pre><div class="source-file"><em>com\craftinginterpreters\lox\Parser.java</em><br>
in <em>forStatement</em>()<br>
replace 1 line</div>
<pre class="insert">    <span class="t">Stmt</span> <span class="i">initializer</span>;
    <span class="k">if</span> (<span class="i">match</span>(<span class="i">SEMICOLON</span>)) {
      <span class="i">initializer</span> = <span class="k">null</span>;
    } <span class="k">else</span> <span class="k">if</span> (<span class="i">match</span>(<span class="i">VAR</span>)) {
      <span class="i">initializer</span> = <span class="i">varDeclaration</span>();
    } <span class="k">else</span> {
      <span class="i">initializer</span> = <span class="i">expressionStatement</span>();
    }
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>com\craftinginterpreters\lox\Parser.java</em>, in <em>forStatement</em>(), replace 1 line</div>

<p>If the token following the <code>(</code> is a semicolon then the initializer has been
omitted. Otherwise, we check for a <code>var</code> keyword to see if it&rsquo;s a <span
name="variable">variable</span> declaration. If neither of those matched, it
must be an expression. We parse that and wrap it in an expression statement so
that the initializer is always of type Stmt.</p>
<aside name="variable">
<p>In a previous chapter, I said we can split expression and statement syntax trees
into two separate class hierarchies because there&rsquo;s no single place in the
grammar that allows both an expression and a statement. That wasn&rsquo;t <em>entirely</em>
true, I guess.</p>
</aside>
<p>Next up is the condition.</p>
<div class="codehilite"><pre class="insert-before">      initializer = expressionStatement();
    }
</pre><div class="source-file"><em>com\craftinginterpreters\lox\Parser.java</em><br>
in <em>forStatement</em>()</div>
<pre class="insert">

    <span class="t">Expr</span> <span class="i">condition</span> = <span class="k">null</span>;
    <span class="k">if</span> (!<span class="i">check</span>(<span class="i">SEMICOLON</span>)) {
      <span class="i">condition</span> = <span class="i">expression</span>();
    }
    <span class="i">consume</span>(<span class="i">SEMICOLON</span>, <span class="s">&quot;Expect &#39;;&#39; after loop condition.&quot;</span>);
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>com\craftinginterpreters\lox\Parser.java</em>, in <em>forStatement</em>()</div>

<p>Again, we look for a semicolon to see if the clause has been omitted. The last
clause is the increment.</p>
<div class="codehilite"><pre class="insert-before">    consume(SEMICOLON, &quot;Expect ';' after loop condition.&quot;);
</pre><div class="source-file"><em>com\craftinginterpreters\lox\Parser.java</em><br>
in <em>forStatement</em>()</div>
<pre class="insert">

    <span class="t">Expr</span> <span class="i">increment</span> = <span class="k">null</span>;
    <span class="k">if</span> (!<span class="i">check</span>(<span class="i">RIGHT_PAREN</span>)) {
      <span class="i">increment</span> = <span class="i">expression</span>();
    }
    <span class="i">consume</span>(<span class="i">RIGHT_PAREN</span>, <span class="s">&quot;Expect &#39;)&#39; after for clauses.&quot;</span>);
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>com\craftinginterpreters\lox\Parser.java</em>, in <em>forStatement</em>()</div>

<p>It&rsquo;s similar to the condition clause except this one is terminated by the
closing parenthesis. All that remains is the <span name="body">body</span>.</p>
<aside name="body">
<p>Is it just me or does that sound morbid? &ldquo;All that remained<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>was the <em>body</em>&rdquo;.</p>
</aside>
<div class="codehilite"><pre class="insert-before">    consume(RIGHT_PAREN, &quot;Expect ')' after for clauses.&quot;);
</pre><div class="source-file"><em>com\craftinginterpreters\lox\Parser.java</em><br>
in <em>forStatement</em>()</div>
<pre class="insert">    <span class="t">Stmt</span> <span class="i">body</span> = <span class="i">statement</span>();

    <span class="k">return</span> <span class="i">body</span>;
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>com\craftinginterpreters\lox\Parser.java</em>, in <em>forStatement</em>()</div>

<p>We&rsquo;ve parsed all of the various pieces of the <code>for</code> loop and the resulting AST
nodes are sitting in a handful of Java local variables. This is where the
desugaring comes in. We take those and use them to synthesize syntax tree nodes
that express the semantics of the <code>for</code> loop, like the hand-desugared example I
showed you earlier.</p>
<p>The code is a little simpler if we work backward, so we start with the increment
clause.</p>
<div class="codehilite"><pre class="insert-before">    Stmt body = statement();

</pre><div class="source-file"><em>com\craftinginterpreters\lox\Parser.java</em><br>
in <em>forStatement</em>()</div>
<pre class="insert">    <span class="k">if</span> (<span class="i">increment</span> != <span class="k">null</span>) {
      <span class="i">body</span> = <span class="k">new</span> <span class="t">Stmt</span>.<span class="t">Block</span>(
          <span class="t">Arrays</span>.<span class="i">asList</span>(
              <span class="i">body</span>,
              <span class="k">new</span> <span class="t">Stmt</span>.<span class="t">Expression</span>(<span class="i">increment</span>)));
    }

</pre><pre class="insert-after">    return body;
</pre></div>
<div class="source-file-narrow"><em>com\craftinginterpreters\lox\Parser.java</em>, in <em>forStatement</em>()</div>

<p>The increment, if there is one, executes after the body in each iteration of the
loop. We do that by replacing the body with a little block that contains the
original body followed by an expression statement that evaluates the increment.</p>
<div class="codehilite"><pre class="insert-before">    }

</pre><div class="source-file"><em>com\craftinginterpreters\lox\Parser.java</em><br>
in <em>forStatement</em>()</div>
<pre class="insert">    <span class="k">if</span> (<span class="i">condition</span> == <span class="k">null</span>) <span class="i">condition</span> = <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Literal</span>(<span class="k">true</span>);
    <span class="i">body</span> = <span class="k">new</span> <span class="t">Stmt</span>.<span class="t">While</span>(<span class="i">condition</span>, <span class="i">body</span>);

</pre><pre class="insert-after">    return body;
</pre></div>
<div class="source-file-narrow"><em>com\craftinginterpreters\lox\Parser.java</em>, in <em>forStatement</em>()</div>

<p>Next, we take the condition and the body and build the loop using a primitive
<code>while</code> loop. If the condition is omitted, we jam in <code>true</code> to make an infinite
loop.</p>
<div class="codehilite"><pre class="insert-before">    body = new Stmt.While(condition, body);

</pre><div class="source-file"><em>com\craftinginterpreters\lox\Parser.java</em><br>
in <em>forStatement</em>()</div>
<pre class="insert">    <span class="k">if</span> (<span class="i">initializer</span> != <span class="k">null</span>) {
      <span class="i">body</span> = <span class="k">new</span> <span class="t">Stmt</span>.<span class="t">Block</span>(<span class="t">Arrays</span>.<span class="i">asList</span>(<span class="i">initializer</span>, <span class="i">body</span>));
    }

</pre><pre class="insert-after">    return body;
</pre></div>
<div class="source-file-narrow"><em>com\craftinginterpreters\lox\Parser.java</em>, in <em>forStatement</em>()</div>

<p>Finally, if there is an initializer, it runs once before the entire loop. We do
that by, again, replacing the whole statement with a block that runs the
initializer and then executes the loop.</p>
<p>That&rsquo;s it. Our interpreter now supports C-style <code>for</code> loops and we didn&rsquo;t have
to touch the Interpreter class at all. Since we desugared to nodes the
interpreter already knows how to visit, there is no more work to do.</p>
<p>Finally, Lox is powerful enough to entertain us, at least for a few minutes.
Here&rsquo;s a tiny program to print the first 21 elements in the Fibonacci
sequence:</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">a</span> = <span class="n">0</span>;
<span class="k">var</span> <span class="i">temp</span>;

<span class="k">for</span> (<span class="k">var</span> <span class="i">b</span> = <span class="n">1</span>; <span class="i">a</span> &lt; <span class="n">10000</span>; <span class="i">b</span> = <span class="i">temp</span> + <span class="i">b</span>) {
  <span class="k">print</span> <span class="i">a</span>;
  <span class="i">temp</span> = <span class="i">a</span>;
  <span class="i">a</span> = <span class="i">b</span>;
}
</pre></div>
<div class="challenges">
<h2><a href="#challenges" id="challenges">Challenges</a></h2>
<ol>
<li>
<p>A few chapters from now, when Lox supports first-class functions and dynamic
dispatch, we technically won&rsquo;t <em>need</em> branching statements built into the
language. Show how conditional execution can be implemented in terms of
those. Name a language that uses this technique for its control flow.</p>
</li>
<li>
<p>Likewise, looping can be implemented using those same tools, provided our
interpreter supports an important optimization. What is it, and why is it
necessary? Name a language that uses this technique for iteration.</p>
</li>
<li>
<p>Unlike Lox, most other C-style languages also support <code>break</code> and <code>continue</code>
statements inside loops. Add support for <code>break</code> statements.</p>
<p>The syntax is a <code>break</code> keyword followed by a semicolon. It should be a
syntax error to have a <code>break</code> statement appear outside of any enclosing
loop. At runtime, a <code>break</code> statement causes execution to jump to the end of
the nearest enclosing loop and proceeds from there. Note that the <code>break</code>
may be nested inside other blocks and <code>if</code> statements that also need to be
exited.</p>
</li>
</ol>
</div>
<div class="design-note">
<h2><a href="#design-note" id="design-note">Design Note: Spoonfuls of Syntactic Sugar</a></h2>
<p>When you design your own language, you choose how much syntactic sugar to pour
into the grammar. Do you make an unsweetened health food where each semantic
operation maps to a single syntactic unit, or some decadent dessert where every
bit of behavior can be expressed ten different ways? Successful languages
inhabit all points along this continuum.</p>
<p>On the extreme acrid end are those with ruthlessly minimal syntax like Lisp,
Forth, and Smalltalk. Lispers famously claim their language &ldquo;has no syntax&rdquo;,
while Smalltalkers proudly show that you can fit the entire grammar on an index
card. This tribe has the philosophy that the <em>language</em> doesn&rsquo;t need syntactic
sugar. Instead, the minimal syntax and semantics it provides are powerful enough
to let library code be as expressive as if it were part of the language itself.</p>
<p>Near these are languages like C, Lua, and Go. They aim for simplicity and
clarity over minimalism. Some, like Go, deliberately eschew both syntactic sugar
and the kind of syntactic extensibility of the previous category. They want the
syntax to get out of the way of the semantics, so they focus on keeping both the
grammar and libraries simple. Code should be obvious more than beautiful.</p>
<p>Somewhere in the middle you have languages like Java, C#, and Python. Eventually
you reach Ruby, C++, Perl, and D<span class="em">&mdash;</span>languages which have stuffed so much syntax
into their grammar, they are running out of punctuation characters on the
keyboard.</p>
<p>To some degree, location on the spectrum correlates with age. It&rsquo;s relatively
easy to add bits of syntactic sugar in later releases. New syntax is a crowd
pleaser, and it&rsquo;s less likely to break existing programs than mucking with the
semantics. Once added, you can never take it away, so languages tend to sweeten
with time. One of the main benefits of creating a new language from scratch is
it gives you an opportunity to scrape off those accumulated layers of frosting
and start over.</p>
<p>Syntactic sugar has a bad rap among the PL intelligentsia. There&rsquo;s a real fetish
for minimalism in that crowd. There is some justification for that. Poorly
designed, unneeded syntax raises the cognitive load without adding enough
expressiveness to carry its weight. Since there is always pressure to cram new
features into the language, it takes discipline and a focus on simplicity to
avoid bloat. Once you add some syntax, you&rsquo;re stuck with it, so it&rsquo;s smart to be
parsimonious.</p>
<p>At the same time, most successful languages do have fairly complex grammars, at
least by the time they are widely used. Programmers spend a ton of time in their
language of choice, and a few niceties here and there really can improve the
comfort and efficiency of their work.</p>
<p>Striking the right balance<span class="em">&mdash;</span>choosing the right level of sweetness for your
language<span class="em">&mdash;</span>relies on your own sense of taste.</p>
</div>

<footer>
<a href="functions.html" class="next">
  Next Chapter: &ldquo;Functions&rdquo; &rarr;
</a>
Handcrafted by Robert Nystrom&ensp;&mdash;&ensp;<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy; 2015&hairsp;&ndash;&hairsp;2021</a>
</footer>
</article>

</div>
</body>
</html>
