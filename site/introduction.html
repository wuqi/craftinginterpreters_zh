<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Introduction &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="contents">
<h3><a href="#top">Introduction<small>1</small></a></h3>

<ul>
    <li><a href="#为什么要学这些东西？"><small>1.1</small> 为什么要学这些东西？</a></li>
    <li><a href="#本书的组织结构"><small>1.2</small> 本书的组织结构</a></li>
    <li><a href="#第一个解译器"><small>1.3</small> 第一个解译器</a></li>
    <li><a href="#第二个解译器"><small>1.4</small> 第二个解译器</a></li>
    <li><a href="#设计须知-名字里有什么？"><small>1.6</small> 设计须知: 名字里有什么？</a></li>
    <li class="divider"></li>
    <li class="end-part"><a href="#challenges">Challenges</a></li>
</ul>


<div class="prev-next">
    <a href="welcome.html" title="Welcome" class="left">&larr;&nbsp;Previous</a>
    <a href="welcome.html" title="Welcome">&uarr;&nbsp;Up</a>
    <a href="a-map-of-the-territory.html" title="A Map of the Territory" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
<a href="welcome.html" title="Welcome" class="prev">←</a>
<a href="a-map-of-the-territory.html" title="A Map of the Territory" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<h3><a href="#top">Introduction<small>1</small></a></h3>

<ul>
    <li><a href="#为什么要学这些东西？"><small>1.1</small> 为什么要学这些东西？</a></li>
    <li><a href="#本书的组织结构"><small>1.2</small> 本书的组织结构</a></li>
    <li><a href="#第一个解译器"><small>1.3</small> 第一个解译器</a></li>
    <li><a href="#第二个解译器"><small>1.4</small> 第二个解译器</a></li>
    <li><a href="#设计须知-名字里有什么？"><small>1.6</small> 设计须知: 名字里有什么？</a></li>
    <li class="divider"></li>
    <li class="end-part"><a href="#challenges">Challenges</a></li>
</ul>


<div class="prev-next">
    <a href="welcome.html" title="Welcome" class="left">&larr;&nbsp;Previous</a>
    <a href="welcome.html" title="Welcome">&uarr;&nbsp;Up</a>
    <a href="a-map-of-the-territory.html" title="A Map of the Territory" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">1</div>
  <h1>Introduction</h1>

<blockquote>
<p>童话故事不仅仅是真实的: 不是因为它们告诉我们龙的存在，而是因为它们告诉我们龙是可以被打败的</p>
<p><cite>G.K. Chesterton by way of Neil Gaiman, <em>Coraline</em></cite></p>
</blockquote>
<p>我很高兴我们能一起踏上这段旅程。这是一本关于为编程语言实现解释器的书。它也是一本关于如何设计一种值得实现的语言的书。这是我刚开始学习语言时就希望拥有的书，也是我已经在<span
name="head">脑海</span>中写了近十年的书。</p>
<aside name="head">
<p>我的朋友和家人，对不起，我一直都很心不在焉!</p>
</aside>
<p>本书中，我们将一步步为一个全功能的语言实现两个完整的解释器。我假设这是您第一次涉足语言，因此我将介绍构建一个完整的、可用的、快速的语言实现所需的每个概念和每行代码。</p>
<p>为了在一本书中塞进两个完整的实现，而不使它变成一个门挡，这篇文章在理论上比其他文章更轻松。在构建系统的每个部分时，我将介绍其背后的历史和概念。我会尽量让你熟悉这些术语，这样如果你在一个<span name="party">鸡尾酒会</span>上发现自己身边全是 PL (编程语言)研究人员，你就能融入其中。</p>
<aside name="party">
<p>奇怪的是，我曾多次发现自己处于这种情况。你不会相信他们中的一些人这么能喝。</p>
</aside>
<p>但是我们大部分脑子都花在了让语言运行起来上。这并不是说理论不重要。在处理语言时，能够对语法和语义进行精确和<span name="formal">正式</span>的推理是一项至关重要的技能。但是，就我个人而言，我通过实践学习得最好。对于我来说，费力地阅读充满抽象概念的段落并真正理解它们是很困难的。但如果我编码了什么东西，运行它，调试它，那么我就能 <em>掌握</em> 它。</p>
<aside name="formal">
<p>静态类型系统尤其需要严格的形式推理。在一个类型系统上进行黑客攻击与在数学中证明一个定理有同样的感觉。</p>
<p>事实证明，这并不是巧合。在上世纪初，哈斯克-库里和威廉-阿尔文-霍华德表明，它们是同一枚硬币的两面：<a href="https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence">the Curry-Howard isomorphism</a>.</p>
</aside>
<p>这就是我的目的。我希望你们学完后能对一门真正的语言如何生存和呼吸有一个可靠的直觉。我的希望是，当你阅读其他更多的理论书籍后，那些概念会牢牢地扎根在你的脑海里，粘附在这种有形的基质上。</p>
<h2><a href="#为什么要学这些东西？" id="为什么要学这些东西？"><small>1&#8202;.&#8202;1</small>为什么要学这些东西？</a></h2>
<p>每一本编译器书籍的介绍似乎都有这一部分。我不知道为什么编程语言会引起这种存在主义的怀疑。我不认为鸟类学书籍担心证明它们的存在。他们假设读者喜欢鸟类，然后开始教学。</p>
<p>但是编程语言有点不同。我认为，我们中的任何一个人创造一个广泛成功的通用编程语言的可能性确实很小。装载所有世界上广泛使用的语言的设计者们甚至不需要露营车，一辆大众2型公交车足以。如果加入这个精英群体是学习语言的唯一理由，那么难以自圆其说。幸运的是，事实并非如此。</p>
<h3><a href="#小语言无处不在" id="小语言无处不在"><small>1&#8202;.&#8202;1&#8202;.&#8202;1</small>小语言无处不在</a></h3>
<p>每一种成功的通用语言，都对应了上千种成功的小众语言。我们过去称它们为“小语言”，但行话的通货膨胀导致了“特定领域语言”的名称。这些是为特定任务量身定制的混合语言。想想应用程序脚本语言、模板引擎、标记格式和配置文件。</p>
<p><span name="little"></span><img src="image/introduction/little-languages.png" alt="A random selection of little languages." /></p>
<aside name="little">
<p>一些你可能遇到的小语言。</p>
</aside>
<p>几乎每个大型软件项目都需要一些这样的东西。如果可以的话，最好是重用现有的，而不是自己开发。一旦你考虑到文档、调试器、编辑器支持、语法高亮和所有其他的陷阱，自己动手就变得很困难了。</p>
<p>但是，当没有一个现有的库适合你的需要时，你仍然很有可能发现自己需要开发一个分析器或其他工具。即使你在重复使用一些现有的实现，你也不可避免地需要对它进行调试和维护，并在探究它的内部。</p>
<h3><a href="#语言是很好的练习" id="语言是很好的练习"><small>1&#8202;.&#8202;1&#8202;.&#8202;2</small>语言是很好的练习</a></h3>
<p>长跑运动员有时会在脚踝上绑着重物训练，或在大气稀薄的高海拔地区训练。当他们后来卸下负担时，轻盈的四肢和富氧的空气使他们能够跑得更远更快。</p>
<p>实现一种语言是对编程技能的真正考验。代码很复杂，性能很关键。您必须掌握递归、动态数组、树、图和哈希表。您可能至少在日常编程中使用哈希表，但是您真的了解它们吗？好吧，在我们从头开始制作我们自己的哈希表之后，我保证你会明白的。</p>
<p>虽然我打算告诉你，解释器并不像你可能认为的那样令人生畏，但实现一个好的解释器仍然是一个挑战。迎接它，你会成为一个更强大的程序员，并且在你日常工作中更聪明地使用数据结构和算法。</p>
<h3><a href="#one-more-reason" id="one-more-reason"><small>1&#8202;.&#8202;1&#8202;.&#8202;3</small>One more reason</a></h3>
<p>最后一个原因对我来说很难承认，因为它是如此接近我的内心。自从我小时候学习编程以来，我觉得语言有一种神奇的力量。当我第一次一个键一个键地敲出BASIC程序时，我无法想象BASIC本身是如何制作的。</p>
<p>后来，我的大学朋友们在谈论他们的编译器课程时，脸上的敬畏和惊恐的表情足以让我相信语言黑客是一种不同的人类--某种被赋予特权的巫师，可以接触到神秘的艺术。</p>
<p>这是一个迷人的<span name="image">形象</span>，但它有一个黑暗的一面。我不觉得自己是个巫师，所以我觉得自己缺乏一些加入黑暗所需的先天素质。虽然自从我在学校的笔记本上涂抹了一些捏造的关键词后，我就对语言很着迷，但我花了几十年的时间才鼓起勇气去尝试真正学习它们。那种 &ldquo;神奇 &ldquo;的品质，那种排他性的感觉，把我排除在外。</p>
<aside name="image">
<p>而它的从业者也毫不犹豫地渲染这种形象。有两本关于编程语言的开创性书籍的封面上有一条<a href="https://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools">龙</a>和一个<a href="https://mitpress.mit.edu/sites/default/files/sicp/index.html">巫师</a>。</p>
</aside>
<p>当我终于开始攒我自己的小解释器时，我很快就知道，根本就没有什么魔法。它只是代码，而在语言上黑客的人也只是人。</p>
<p>有一些技术 <em>是</em> 你在语言之外不常遇到的，有些部分有点困难。但不会比你所克服的其他障碍更难。我的希望是，如果你对语言感到畏惧，而这本书能帮助你克服这种恐惧，也许我会让你比以前更勇敢一丝。</p>
<p>而且，谁知道呢，也许你 <em>将</em> 会创造出下一个伟大的语言。总得有人去做。</p>
<h2><a href="#本书的组织结构" id="本书的组织结构"><small>1&#8202;.&#8202;2</small>本书的组织结构</a></h2>
<p>这本书分为三部分。你正在读第一部分。这几章是为了让你掌握方向，教你一些语言黑客使用的行话，并向你介绍Lox，我们将要实现的语言。</p>
<p>其他两部分分别构建了一个完整的Lox解释器。在这些部分中，每一章的结构都是一样的。每个章节介绍一个单一的语言特性，教给你它背后的概念，并引导你完成一个实现。</p>
<p>我花了不少时间反复尝试，但我还是设法将两个解释器分割前后无关的章节。从第一章开始，你就有了一个可以运行和使用的工作程序。每过一章，它的功能就会越来越全面，直到你最终拥有一个完整的语言。</p>
<p>除了大量精彩的英文散文外，章节还有其他一些令人愉快的方面:</p>
<h3><a href="#代码" id="代码"><small>1&#8202;.&#8202;2&#8202;.&#8202;1</small>代码</a></h3>
<p>我们是关于 <em>制作</em> 解释器的，所以这本书包含了真正的代码。所需的每一行代码都包括在内，每个片段都告诉你在你不断增长的实现中插入它的位置。</p>
<p>许多其他的语言书籍和语言实现都使用 <a href="https://en.wikipedia.org/wiki/Lex_(software)">Lex</a> 和 <span name="yacc"><a href="https://en.wikipedia.org/wiki/Yacc">Yacc</a></span> 这样的工具，即所谓的 <strong>编译器的编译器</strong> ，它们从一些更高层次的描述中自动生成一些用于实现的源文件。像这样的工具有利有弊，而且双方都有强烈的意见--有人可能说是宗教信仰。</p>
<aside name="yacc">
<p>Yacc是一个工具，它接收一个语法文件并产生一个编译器的源文件，所以它有点像一个输出编译器的 &ldquo;编译器&ldquo;，这也是我们得到 &ldquo;编译器的编译器 &ldquo;一词的原因。</p>
<p>Yacc并不是第一个类似的工具，这就是为什么它被命名为 &ldquo;Yacc&rdquo;-- <em>Yet Another</em> Compiler-Compiler。后来的一个类似工具是 <a href="https://en.wikipedia.org/wiki/GNU_bison">Bison</a> ，它的名字是对Yacc的发音的双关语，就像 &ldquo;yak&rdquo; （牦牛）。</p><img src="image/introduction/yak.png" alt="A yak." />
<p>如果你觉得所有这些小的自我介绍和双关语都很有趣，你会适合这里的。如果不是，那么，也许语言nerd的幽默感是一种后天的味道。</p>
</aside>
<p>我们不会在这里使用它们。我想确保没有黑暗的角落可以隐藏魔法和混乱，所以我们将手写一切。正如您将看到的，这并没有听起来那么糟糕，这意味着您将真正理解每行代码以及两个解释器是如何工作的。</p>
<p>书籍与 &ldquo;现实世界 &ldquo;有不同的限制，因此这里的编码风格可能并不总是反映出编写可维护的生产软件的最佳方式。如果我看起来有点轻率，例如，省略 <code>private</code> 或声明全局变量，请理解我，这样做是为了让你的眼睛更容易看到代码。这里的页面没有你的IDE那么宽，每个字符都很重要。</p>
<p>另外，代码中没有很多注释。这是因为每一行的周围都有几段诚实的散文来解释它。当你写一本书来配合你的程序时，也欢迎你省略注释。否则，你也许应该比我多用一点 <code>//</code>。</p>
<p>虽然书中包含了每一行代码，并讲授了每一行的含义，但它并没有描述编译和运行解释器所需的机器。我认为你可以在你选择的IDE中编写一个makefile或新建一个项目，以便让代码运行。这类说明很快就会过时，我希望这本书像XO白兰地一样陈旧，而不是后院的烈酒。</p>
<h3><a href="#代码片段" id="代码片段"><small>1&#8202;.&#8202;2&#8202;.&#8202;2</small>代码片段</a></h3>
<p>因为这本书包含了实现所需的每一行代码，所以这些代码片段非常精确。此外，因为我试图保持程序在一个可运行的状态，即使主要特性缺失，有时我们添加临时代码，将在以后的代码片段中替换。</p>
<p>一个具有所有附加功能的代码片段看起来像这样:</p>
<div class="codehilite"><pre class="insert-before">
      default:
</pre><div class="source-file"><em>lox/Scanner.java</em><br>
in <em>scanToken</em>()<br>
replace 1 line</div>
<pre class="insert">
        <span class="k">if</span> (<span class="i">isDigit</span>(<span class="i">c</span>)) {
          <span class="i">number</span>();
        } <span class="k">else</span> {
          <span class="t">Lox</span>.<span class="i">error</span>(<span class="i">line</span>, <span class="s">&quot;Unexpected character.&quot;</span>);
        }
</pre><pre class="insert-after">
        break;
</pre></div>
<div class="source-file-narrow"><em>lox/Scanner.java</em>, in <em>scanToken</em>(), replace 1 line</div>
<p>在中间，你有新的代码要添加。它的上方或下方可能有一些淡化的线条，以显示它在现有周边代码中的位置。还有一个小提示，告诉你在哪个文件中，在哪里放置这个片段。如果提示说 &ldquo;replace _ lines&rdquo;（替换行），那么在褪色的行之间有一些现有的代码，你需要删除并替换为新的代码段。</p>
<h3><a href="#旁注" id="旁注"><small>1&#8202;.&#8202;2&#8202;.&#8202;3</small>旁注</a></h3>
<p><span name="joke">旁注</span>包括传记、历史背景、相关主题的参考资料，以及对其他领域的探索建议。为了理解本书后面的部分，你不需要知道这些内容，所以如果你想的话，可以跳过它们。我不会指责你，但我可能会有点难过。</p>
<aside name="joke">
<p>好吧，至少有些旁白是这样的。他们中的大多数只是愚蠢的笑话和业余的绘画。</p>
</aside>
<h3><a href="#挑战" id="挑战"><small>1&#8202;.&#8202;2&#8202;.&#8202;4</small>挑战</a></h3>
<p>每章结尾都有一些练习。与教科书习题集不同，教科书习题集倾向于复习你已经学过的内容，这些习题集可以帮助你学到比本章内容更多的东西。他们强迫你离开指引的道路，自己去探索。他们会让你研究其他语言，弄清楚如何实现特性，或者以其他方式让你走出你的舒适区。</p>
<p><span name="warning">战胜</span>挑战，你会接触到更广泛的知识，可能还会有一些磕磕碰碰。如果你想呆在舒适的旅游巴士里，就跳过它们。这是你的书。</p>
<aside name="warning">
<p>一个警告：这些挑战经常要求你对你正在构建的解释器进行修改。你应该在你的代码副本中实现这些改动。后面的章节假定你的解释器处于原始（&ldquo;未接受挑战&ldquo;）状态。</p>
</aside>
<h3><a href="#设计须知" id="设计须知"><small>1&#8202;.&#8202;2&#8202;.&#8202;5</small>设计须知</a></h3>
<p>大多数“编程语言”书籍都是严格意义上的编程语言实现书。他们很少讨论如何设计正在实现的语言。实现之所以有趣，是因为它的定义<span name="benchmark">非常精确</span>。我们程序员似乎对黑白、1和0这些东西有一种亲和力。</p>
<aside name="benchmark">
<p>我认识很多语言黑客，他们的职业就是基于此。你把一个语言规范塞到他们的门口，等上几个月，代码和基准测试结果就出来了。</p>
</aside>
<p>我个人认为，世界只需要这么多 <span name="fortran">FORTRAN 77</span> 的实现。在某些时候，您会发现自己正在设计一种新的语言。一旦你开始玩这个游戏，那么软性的、人性化的一面就变得非常重要。比如哪些特性容易学习，如何平衡创新和熟悉感，哪些语法更易读，对谁更易读。</p>
<aside name="fortran">
<p>希望你的新语言不会将关于打孔卡片宽度的假设硬编码到其语法中。</p>
</aside>
<p>所有这些东西都会深刻地影响到你的新语言的成功。我希望您的语言能够成功，所以在某些章节中，我以 &ldquo;设计须知 &ldquo;作为结尾，这是一篇关于编程语言的人文方面的某个角落的小文章。我不是这方面的专家ーー我不知道是否真的有专家ーー所以，对这些问题持保留态度。这应该能让它们变得更加美味，这是我的主要目标。</p>
<h2><a href="#第一个解译器" id="第一个解译器"><small>1&#8202;.&#8202;3</small>第一个解译器</a></h2>
<p>我们将用<span name="lang">Java</span>编写我们的第一个解释器，jlox。重点是 <em>概念</em> 。我们将编写最简单、最干净的代码来正确实现语言的语义。这将使我们对基本的技术感到舒服，同时也磨练我们对这门语言到底应该如何表现的理解。</p>
<aside name="lang">
<p>本书使用Java和C语言，但读者已将代码移植到许多<a href="https://github.com/munificent/craftinginterpreters/wiki/Lox-implementations">其他语言</a>。如果我挑选的语言不是你的菜，可以看看那些语言实现。</p>
</aside>
<p>在这方面，Java是一种很好的语言。它的水平很高，我们不会被繁琐的实现细节所淹没，但它仍然很明确。与脚本语言不同，隐藏在底层的机器往往没有那么复杂，而且您可以使用静态类型来查看正在使用的数据结构。</p>
<p>我选择 <code>Java</code> ，也是因为它是一种面向对象的语言。这种模式在90年代席卷了编程世界，现在已经成为数百万程序员的主导思维方式。很可能您已经习惯于将代码组织成类和方法，因此我们将让您保持在这个舒适区。</p>
<p>虽然学术界的语言人士有时会看不起面向对象的语言，但现实是，它们甚至被广泛用于语言工作。GCC和LLVM是用C++编写的，大多数JavaScript虚拟机也是如此。面向对象的语言无处不在，而且一种语言的工具和编译器往往是用<span name="host">同一种语言</span>编写的。</p>
<aside name="host">
<p>编译器读取一种语言的文件，对其进行翻译，然后输出另一种语言的文件。你可以在任何语言中实现一个编译器，包括它所编译的同一种语言，这个过程称为 <strong>自托管</strong>。</p>
<p>你的编译器还不能自己编译自己，但如果你有另一个用其他语言编写的编译器，你就可以用那个编译器来编译一次你的编译器。现在你可以用你自己的编译器的编译版本来编译它的未来版本，而你可以丢弃从其他编译器编译的原始版本。这被称为 &ldquo;引导&ldquo;（ <strong>bootstrapping</strong> ），来自于用自己的引导带把自己拉起来的形象。</p><img src="image/introduction/bootstrap.png" alt="Fact: This is the primary mode of transportation of the American cowboy." />
</aside>
<p>而且，最后，Java是非常流行的。这意味着你很有可能已经知道它了，所以你在书中要学的东西就少了。如果你对Java不是那么熟悉，也不要惊慌。我试图坚持使用它的一个相当小的子集。我使用了Java 7中的钻石运算符，使事情变得更加简洁，但就 &ldquo;高级&ldquo;功能而言，也就这些了。如果你知道另一种面向对象的语言，如C#或C++，你可以蒙混过关。</p>
<p>在第二部分结束时，我们会有一个简单、可读的实现。它不是非常快，但它是正确的。然而，我们只有通过建立在Java虚拟机自身的运行时设施上才能实现这一点。我们要学习Java <em>本身</em> 如何实现这些东西。</p>
<h2><a href="#第二个解译器" id="第二个解译器"><small>1&#8202;.&#8202;4</small>第二个解译器</a></h2>
<p>因此，在下一部分中，我们将重新开始，但这次是用C语言。C语言是理解一个实现如何 <em>真正</em> 工作的完美语言，一直到内存中的字节和流经CPU的代码。</p>
<p>我们使用C语言的一个重要原因是，我可以向你展示C语言特别擅长的东西，但这 <em>确实</em> 意味着你需要对它非常熟悉。你不必成为丹尼斯-里奇的转世，但你也不应该被指针吓到。</p>
<p>如果你还没有达到这个水平，那就拿起一本关于C语言的入门书，仔细研读，然后在完成后再来这里。作为回报，你会通过这本书中成为一个更强大的C语言程序员。鉴于有许多语言的实现是用C语言写的，这很有用。Lua、CPython和Ruby的MRI，仅举几例。</p>
<p>在我们的C语言解释器<span name="clox">clox</span>中，我们被迫为自己实现所有Java免费给我们的东西。我们将编写我们自己的动态数组和哈希表。我们将决定对象在内存中如何表示，并建立一个垃圾收集器来回收它们。</p>
<aside name="clox">
<p>我把这个名字念成 &ldquo;sea-locks&rdquo;，但你也可以说成 &ldquo;clocks&rdquo;，甚至是 &ldquo;cloch&rdquo;，你可以像希腊人那样念 &ldquo;x&rdquo;，如果这让你高兴的话。</p>
</aside>
<p>我们的Java实现专注于正确性。现在我们已经完成了这一点，我们将解决速度问题。我们的C语言解释器将包含一个<span name="compiler">编译器</span>，将Lox翻译成有效的字节码表示（别担心，我很快就会说到这是什么意思），然后执行。这与Lua、Python、Ruby、PHP和其他许多成功语言的实现所使用的技术相同。</p>
<aside name="compiler">
<p>你以为这只是一本解释器的书吗？它也是一本编译器书。一书两用!</p>
</aside>
<p>我们甚至会尝试进行基准测试和优化。最后，我们将为我们的语言提供一个健壮、准确、快速的解释器，能够跟上其他专业水平的实现。对于一本书和几千行代码来说还不错。</p>
<div class="challenges">
<h2><a href="#challenges" id="challenges">Challenges</a></h2>
<ol>
<li>
<p>在我为编写和出版本书而拼凑的这个<a href="https://github.com/munificent/craftinginterpreters">小系统</a> 中，至少使用了六种特定于领域的语言。他们是什么？</p>
</li>
<li>
<p>用 Java实现一个“hello,world!” 程序。设置任何您需要的 makefile 或 IDE 项目来使其工作。如果您有一个调试器，请适应它，并在程序运行时逐步调试它。</p>
</li>
<li>
<p>使用C 实现同样的事情。为了练习使用指针，定义一个堆分配的字符串[双向链表][]。编写用于从中插入、查找和删除项的函数。测试他们。</p>
</li>
</ol>
</div>
<div class="design-note">
<h2><a href="#设计须知-名字里有什么？" id="设计须知-名字里有什么？"><small>1&#8202;.&#8202;6</small>设计须知: 名字里有什么？</a></h2>
<p>写这本书最大的挑战之一就是为它实现的语言命名。我翻了好几页候选人才找到一个可用的。正如您在开始构建自己的语言的第一天就会发现的那样，命名非常困难。一个好名字要满足以下几个条件:</p>
<ol>
<li>
<p><strong>未被使用</strong> 如果你不小心踩到了别人的名字，你可能会遇到各种各样的麻烦，无论是法律上的还是社会上的。</p>
</li>
<li>
<p><strong>容易发音</strong> 如果一切顺利的话，成群结队的人将会说和写你的语言的名字。任何超过几个音节或几个字母的东西都会让他们烦恼不已。</p>
</li>
<li>
<p><strong>足够独特,方便搜索</strong> 人们会用谷歌搜索你的语言名称来了解它，所以你需要一个足够罕见的单词，以至于大多数搜索结果都指向你的文档。不过，随着今天人工智能搜索引擎的大量涌现，这个问题就不那么严重了。尽管如此，如果您将语言命名为“ for”，那么对您的用户没有任何好处。</p>
</li>
<li>
<p><strong>它在很多文化中都没有负面的含义。</strong> 这很难防范，但值得考虑。Nimrod 的设计者最终将他的语言重新命名为Nim，因为太多的人记得兔八哥用“Nimrod”作为一种<a href="https://www.dictionary.com/browse/nimrod">侮辱</a>。</p>
</li>
</ol>
<p>如果你的候选名能通过这一关，那就保留它。不要执着于试图找到一个能抓住你的语言精髓的称呼。如果世界上其他成功的语言的名称告诉我们什么，那就是名字并不重要。你所需要的只是一个相当独特的符号。</p>
</div>

<footer>
<a href="a-map-of-the-territory.html" class="next">
  Next Chapter: &ldquo;A Map of the Territory&rdquo; &rarr;
</a>
Handcrafted by Robert Nystrom&ensp;&mdash;&ensp;<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy; 2015&hairsp;&ndash;&hairsp;2021</a>
</footer>
</article>

</div>
</body>
</html>
