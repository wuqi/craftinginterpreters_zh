<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Representing Code &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="contents">
<h3><a href="#top">Representing Code<small>5</small></a></h3>

<ul>
    <li><a href="#上下文无关文法"><small>5.1</small> 上下文无关文法</a></li>
    <li><a href="#实现语法树"><small>5.2</small> 实现语法树</a></li>
    <li><a href="#working-with-trees"><small>5.3</small> Working with Trees</a></li>
    <li><a href="#a-not-very-pretty-printer"><small>5.4</small> A (Not Very) Pretty Printer</a></li>
    <li class="divider"></li>
    <li class="end-part"><a href="#challenges">Challenges</a></li>
</ul>


<div class="prev-next">
    <a href="scanning.html" title="Scanning" class="left">&larr;&nbsp;Previous</a>
    <a href="a-tree-walk-interpreter.html" title="A Tree-Walk Interpreter">&uarr;&nbsp;Up</a>
    <a href="parsing-expressions.html" title="Parsing Expressions" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
<a href="scanning.html" title="Scanning" class="prev">←</a>
<a href="parsing-expressions.html" title="Parsing Expressions" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<h3><a href="#top">Representing Code<small>5</small></a></h3>

<ul>
    <li><a href="#上下文无关文法"><small>5.1</small> 上下文无关文法</a></li>
    <li><a href="#实现语法树"><small>5.2</small> 实现语法树</a></li>
    <li><a href="#working-with-trees"><small>5.3</small> Working with Trees</a></li>
    <li><a href="#a-not-very-pretty-printer"><small>5.4</small> A (Not Very) Pretty Printer</a></li>
    <li class="divider"></li>
    <li class="end-part"><a href="#challenges">Challenges</a></li>
</ul>


<div class="prev-next">
    <a href="scanning.html" title="Scanning" class="left">&larr;&nbsp;Previous</a>
    <a href="a-tree-walk-interpreter.html" title="A Tree-Walk Interpreter">&uarr;&nbsp;Up</a>
    <a href="parsing-expressions.html" title="Parsing Expressions" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">5</div>
  <h1>Representing Code</h1>

<blockquote>
<p>对于居住在树林里的人来说，几乎每一种树都有它的声音和特点。
<cite>Thomas Hardy, <em>Under the Greenwood Tree</em></cite></p>
</blockquote>
<p>在<a href="scanning.html">上一章</a>中，我们将原始的源代码作为字符串，并将其转换为一个稍高层次的表示：一系列的 token 。我们将在<a href="parsing-expressions.html">下一章</a>中编写的解析器，将这些 token 再次转化为更丰富、更复杂的表达。</p>
<p>在我们能够产生这种表示法之前，我们需要定义它。这就是本章的主题。在这一过程中，我们将<span name="boring">介绍</span>一些围绕形式化语法的理论，感受函数式编程和面向对象编程之间的区别，讨论几个设计模式，并实现一些元编程。</p>
<aside name="boring">
<p>我非常担心这是本书中最无聊的一章，所以我不断地把更多有趣的想法塞进去，直到没有空间了。</p>
</aside>
<p>在我们做所有这些之前，让我们关注一下主要目标——代码的表示。
句法分析器应该便于生产，解释器也应该易于消费。如果你还没有编写一个句法分析器或解释器，那么这些需求并不明确。也许你的直觉能帮上忙。当你扮演<em>人工</em>翻译的角色时，你的大脑在做什么？你如何心算这样一个算术表达式:</p>
<div class="codehilite"><pre><span class="n">1</span> + <span class="n">2</span> * <span class="n">3</span> - <span class="n">4</span>
</pre></div>
<p>因为你了解运算顺序--  像<a href="https://en.wikipedia.org/wiki/Order_of_operations#Mnemonics">Please Excuse My Dear Aunt Sally</a>的<span name="PEMDAS">口诀</span>中说的--你知道乘法要在加法或减法之前计算。有一种方法是用一棵树来说明这种优先顺序。叶子结点是数字，内部结点是运算符，每个运算符都有分支。</p>
<aside name="PEMDAS">
<p>译注: 美国记运算的顺序的口诀：括号（Parenthesis）、指数(Exponent)、乘除（multiplication and division）、加减（addition and subtraction），编成了Please Excuse My Dear Aunt Sally （请原谅我亲爱的阿姨莎莉）。</p>
</aside>
<p>为了计算一个算术节点，你需要知道其子节点的数值，所以你必须先计算这些子节点。这意味着你要从叶节点向根部遍历--即<em>后序遍历</em>。</p>
<p><span name="tree-steps"></span></p><img src="image/representing-code/tree-evaluate.png" alt="Evaluating the tree from the bottom up." />
<aside name="tree-steps">
<p>A. 从整个树开始，首先计算最底部的操作, <code>2 * 3</code>.</p>
<p>B. 然后我们做加法 <code>+</code> .</p>
<p>C. 继续, 做减法 <code>-</code>.</p>
<p>D. 得到最终结果！</p>
</aside>
<p>如果我给你一个算术表达式，你可以很容易地画出这些树。给定一棵树，你可以毫不费力地计算它。因此，从直觉上看，我们代码的可以表示为一棵与语言的语法结构(运算符嵌套)相匹配的<span name="only">树</span>。</p>
<aside name="only">
<p>这并不是说树是我们代码的<em>唯一</em>的表示方法。在<a href="a-bytecode-virtual-machine.html">Part III</a>中，我们将生成字节码，这是另一种不太友好但更接近机器的表示方法。</p>
</aside>
<p>那么我们需要更精确地了解语法是什么。就像上一章中的词法语法一样，围绕着句法语法有大量的理论。我们对这个理论的研究比扫描时多一点，因为它在解释器中是一个有用的工具。我们从<a href="https://en.wikipedia.org/wiki/Chomsky_hierarchy">Chomsky hierarchy</a>层次结构的第一层开始<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span></p>
<h2><a href="#上下文无关文法" id="上下文无关文法"><small>5&#8202;.&#8202;1</small>上下文无关文法</a></h2>
<p>在上一章中，我们用来定义词汇语法的样式——即字符如何组合成 token 的规则——被称为<em>正则语言</em>。这对我们的扫描器来说很完美，它发射出死板的 token 序列。但是正则语言没有强大到足以处理可以任意深度嵌套的表达式。</p>
<p>我们需要一把更大的锤子，那把锤子就是 <strong>上下文无关文法</strong> (<strong>CFG</strong>)。它是 <strong><a href="https://en.wikipedia.org/wiki/Formal_grammar">形式语法</a></strong> (formal grammars)工具箱中第二重的工具。一种形式语法由一组原子片段组成，称之为“字母表”(alphabet)。然后，它定义一组(通常是无限的)语法&ldquo;中&ldquo;的“字符串”。每个字符串都是字母表中的“字母”序列。</p>
<p>我之所以使用所有这些引号，是因为从词法到句法的语法时，这些术语会变得有点混乱。在我们的扫描器语法中，字母表由单个字符组成，字符串是有效的词组--大致是 &ldquo;单词&ldquo;。在我们现在讨论的句法语法中，我们处于不同的粒度水平。现在，字母表中的每个 &ldquo;字母&rdquo; 都是一个完整的 token ，而 &ldquo;字符串 &ldquo;是一个 <em>tokens</em> 的序列--一个完整的表达式。</p>
<p>哦，也许一张表格会有些帮助:</p><table>
<thead>
<tr>
  <td>术语</td>
  <td></td>
  <td>词法语法</td>
  <td>句法语法</td>
</tr>
</thead>
<tbody>
<tr>
  <td> &ldquo;字母表&rdquo; 是<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.</span></td>
  <td>&rarr;&ensp;</td>
  <td>字符</td>
  <td>Tokens</td>
</tr>
<tr>
  <td> &ldquo;字符串&rdquo; 是<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.</span></td>
  <td>&rarr;&ensp;</td>
  <td>Lexeme 或 token</td>
  <td>表达式</td>
</tr>
<tr>
  <td>由什么实现<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.</span></td>
  <td>&rarr;&ensp;</td>
  <td>扫描器</td>
  <td>句法分析器</td>
</tr>
</tbody>
</table>
<p>形式语法的工作是指定哪些字符串是有效的，哪些是无效的。如果我们为英语句子定义一个语法，&ldquo;鸡蛋是美味的早餐 &ldquo;是正确的语法，但 &ldquo;美味的早餐是鸡蛋 &ldquo;则不是。</p>
<h3><a href="#语法规则" id="语法规则"><small>5&#8202;.&#8202;1&#8202;.&#8202;1</small>语法规则</a></h3>
<p>我们如何描述一个包含无限个有效字符串的语法？显然，我们不能把他们全部列出来。我们创建了一个有限的规则集作为替代，你可以把它想象成一个二选一的游戏。</p>
<p>如果你从规则开始，你可以用它们来 <em>生成</em> 语法中的字符串。以这种方式创建的字符串被称为 <strong>派生</strong> ，因为每个字符串都是从语法的规则中派生出来的。在游戏的每一步中，你选择一条规则，然后按照它告诉你的去做。形式语法的大部分行话都是从这里来的。规则被称为 <strong>产生式</strong> ，因为它们在 <em>语法</em> 中产生字符串。</p>
<p>上下文无关文法中的每个产生式都有一个 <strong>头</strong><span class="em">&mdash;</span>包含<span name="name">名称</span>--和 <strong>主体</strong>，用于描述它生成的内容。在其纯粹的形式中，主体只是一个符号的列表。符号有两种可选口味:</p>
<aside name="name">
<p>将头限制在一个符号上是上下文无关文法的一个决定性特征。更强大的形式主义，如 <strong><a href="https://en.wikipedia.org/wiki/Unrestricted_grammar">无限制文法</a></strong> ，允许在头和主体中有一系列符号。</p>
</aside>
<ul>
<li>
<p><strong>终结符</strong> 是语法字母表中的一个字符。你可以把它看成是一个字面值。在我们定义的句法语法中，终结符是来自扫描器的单个 lexemes--token ，如 <code>if</code> 或 <code>1234</code> 。</p>
<p>这些被称为 &ldquo;终结符&ldquo;，取 &ldquo;终点&rdquo; 之意，因为它们不会导致游戏中的任何进一步 &ldquo;行动&ldquo;。你只是产生一个符号。</p>
</li>
<li>
<p><strong>非终结符</strong> 是对语法中另一条规则的命名引用。它意味着 &ldquo;执行该规则并在这里插入它产生的任何内容&ldquo;。这样一来，语法就构成了。</p>
</li>
</ul>
<p>还有最后一项改进：你可以有多个同名的规则。当你到达一个具有该名称的非终结符时，你可以为它选择任何一条规则，以你的想法为准。</p>
<p>为了使之具体化，我们需要一种<span name="turtles">方法</span>来写下这些产生式规则。人们一直在试图将语法具体化，这可以追溯到古印度语法学家波你尼撰写的《声明论》(亦称《八章书》) ，他在几千年前就将梵文语法编成了法典。直到John Backus和其公司需要一个用于指定ALGOL 58语言的记法，并提出了<a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form"><strong>Backus-Naur form</strong></a>（ <strong>BNF</strong> 巴科斯范式），才有了很大的进展。从那时起，几乎每个人都使用某种形式的BNF，并根据自己的口味进行调整。</p>
<p>我试图想出一些简洁的方法。每条规则都是一个名字，后面跟一个箭头（ <code>→</code> ），然后是一连串的符号，最后以分号（<code>;</code>）结束。终结符是带引号的字符串，非终结符是小写的单词。</p>
<aside name="turtles">
<p>是的，我们需要定义一种语法，用于定义我们的语法的规则。我们是否也应该指定这种 <em>元语法</em> ？我们用什么记法来表示 <em>它</em> ？一路下来都是语言!</p>
</aside>
<p>利用这种方式，下面是<span name="breakfast">早餐</span>菜单的语法。</p>
<aside name="breakfast">
<p>是的，我真的要在这整本书中使用早餐的例子。对不起。</p>
</aside>
<div class="codehilite"><pre><span class="i">breakfast</span>  → <span class="i">protein</span> <span class="s">&quot;with&quot;</span> <span class="i">breakfast</span> <span class="s">&quot;on the side&quot;</span> ;
<span class="i">breakfast</span>  → <span class="i">protein</span> ;
<span class="i">breakfast</span>  → <span class="i">bread</span> ;

<span class="i">protein</span>    → <span class="i">crispiness</span> <span class="s">&quot;crispy&quot;</span> <span class="s">&quot;bacon&quot;</span> ;
<span class="i">protein</span>    → <span class="s">&quot;sausage&quot;</span> ;
<span class="i">protein</span>    → <span class="i">cooked</span> <span class="s">&quot;eggs&quot;</span> ;

<span class="i">crispiness</span> → <span class="s">&quot;really&quot;</span> ;
<span class="i">crispiness</span> → <span class="s">&quot;really&quot;</span> <span class="i">crispiness</span> ;

<span class="i">cooked</span>     → <span class="s">&quot;scrambled&quot;</span> ;
<span class="i">cooked</span>     → <span class="s">&quot;poached&quot;</span> ;
<span class="i">cooked</span>     → <span class="s">&quot;fried&quot;</span> ;

<span class="i">bread</span>      → <span class="s">&quot;toast&quot;</span> ;
<span class="i">bread</span>      → <span class="s">&quot;biscuits&quot;</span> ;
<span class="i">bread</span>      → <span class="s">&quot;English muffin&quot;</span> ;
</pre></div>
<p>我们可以使用这个语法来生成随机早餐。我们来玩一轮，看看效果如何。按照古老的惯例，游戏从语法中的第一条规则开始，在这里是 <code>breakfast</code>。有三个产生式，我们随机选择第一个。我们得到的字符串如下所示:</p>
<div class="codehilite"><pre>protein &quot;with&quot; breakfast &quot;on the side&quot;
</pre></div>
<p>我们需要扩展第一个非终结符，即 <code>protein</code> ，所以我们为它选择一个产生式。我们来选一个:</p>
<div class="codehilite"><pre><span class="i">protein</span> → <span class="i">cooked</span> <span class="s">&quot;eggs&quot;</span> ;
</pre></div>
<p>接下来，我们需要为 <code>cooked</code> 选一个产生式，所以我们选择  <code>"poached"</code>。那是一个终结符，所以我们把它加进去。现在我们的字符串看起来像:</p>
<div class="codehilite"><pre>&quot;poached&quot; &quot;eggs&quot; &quot;with&quot; breakfast &quot;on the side&quot;
</pre></div>
<p>下一个非终结符又是 <code>breakfast</code> 。我们选择的第一个 <code>breakfast</code> 产生式递归引用了 <code>breakfast</code> 规则。语法中的递归是一个很好的标志，说明被定义的语言是上下文无关的，而不是正则的。特别是，递归非终结符 <span name="nest">两边</span>都有产生式的递归，意味着这种语言不是正则的。</p>
<aside name="nest">
<p>想象一下，我们在这里把 <code>breakfast</code> 规则递归扩展了好几次，比如&ldquo;bacon with bacon with bacon with<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>&rdquo; 。为了正确地完成这个字符串，我们需要在结尾处添加<em>同等</em> 数量的 &ldquo;on the side&rdquo; 。跟踪所需尾部的数量超出了正则语法的能力。正则语法可以表达重复，但它们不能统计有多少次重复，而这对于确保字符串有相同数量的 <code>with</code> 和 <code>on the side</code> 部分是必要的。</p>
</aside>
<p>我们可以一次又一次地挑选第一种产生式作为 <code>breakfast</code> ，产生各种形式的早餐，如 &ldquo;bacon with sausage with scrambled eggs with bacon<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>&rdquo;。但我们不会这样做。这一次，我们将选择 <code>bread</code>。<code>bread</code> 有三条规则，每条都只包含一个终结符。我们将选择 &ldquo;English muffin&rdquo;。</p>
<p>这样，字符串中的每个非终结符都被展开，直到最后只包含终结符，我们只剩下:</p><img src="image/representing-code/breakfast.png" alt='"Playing" the grammar to generate a string.' />
<p>扔进去一些火腿和荷兰酱，你就有了班尼迪克蛋。</p>
<p>每当我们碰到一个包含多个产生式的规则时，我们都会任意选择一个。正是这种灵活性允许少量的语法规则编码组合上更大的字符串集。一个规则可以直接或间接地引用自身，这一事实使它更加灵活，让我们可以把无限多的字符串装进一个有限的语法中。</p>
<h3><a href="#强化我们的记法" id="强化我们的记法"><small>5&#8202;.&#8202;1&#8202;.&#8202;2</small>强化我们的记法</a></h3>
<p>把无限的字符串集塞进少量的规则中非常神奇，但是我们还可以更进一步。我们的记法是有效的，但它很乏味。因此，像任何一个好的语言设计者一样，我们将在上面撒上一点语法糖--一些额外的便利记法。除了终结符和非终结符之外，我们还允许在规则的主体中出现一些其他类型的表达式：</p>
<ul>
<li>
<p>我们不需要每次都重复规则的名称，而是允许使用一系列用竖线（<code>|</code>）隔开产生式。</p>
<div class="codehilite"><pre><span class="i">bread</span> → <span class="s">&quot;toast&quot;</span> | <span class="s">&quot;biscuits&quot;</span> | <span class="s">&quot;English muffin&quot;</span> ;
</pre></div>
</li>
<li>
<p>此外，我们将允许用圆括号进行分组，然后允许 <code>|</code> 在其中从一系列的选项中选择一个产生式。</p>
<div class="codehilite"><pre><span class="i">protein</span> → ( <span class="s">&quot;scrambled&quot;</span> | <span class="s">&quot;poached&quot;</span> | <span class="s">&quot;fried&quot;</span> ) <span class="s">&quot;eggs&quot;</span> ;
</pre></div>
</li>
<li>
<p>使用递归来支持重复的符号序列有一定的<span name="purity">吸引力</span>，但每次我们想要循环时，都要创建一个单独的命名子规则，这有点麻烦。因此，我们还使用后缀 <code>*</code> 来允许前面的符号或组重复零次或多次。</p>
<div class="codehilite"><pre><span class="i">crispiness</span> → <span class="s">&quot;really&quot;</span> <span class="s">&quot;really&quot;</span>* ;
</pre></div>
</li>
</ul>
<aside name="purity">
<p>这就是Scheme编程语言的工作方式。它根本就没有内置的循环功能。反之，所有的重复都是用递归来表达的。</p>
</aside>
<ul>
<li>
<p>后缀 <code>+</code> 与此类似，但要求前面的产生式至少出现一次。</p>
<div class="codehilite"><pre><span class="i">crispiness</span> → <span class="s">&quot;really&quot;</span>+ ;
</pre></div>
</li>
<li>
<p>后缀&ldquo;？&ldquo;是指一个可选的产生式。它前面的东西可以出现零次或一次，但不能更多。</p>
<div class="codehilite"><pre><span class="i">breakfast</span> → <span class="i">protein</span> ( <span class="s">&quot;with&quot;</span> <span class="i">breakfast</span> <span class="s">&quot;on the side&quot;</span> )? ;
</pre></div>
</li>
</ul>
<p>有了所有这些语法细节，我们的早餐语法概括为：</p>
<div class="codehilite"><pre><span class="i">breakfast</span> → <span class="i">protein</span> ( <span class="s">&quot;with&quot;</span> <span class="i">breakfast</span> <span class="s">&quot;on the side&quot;</span> )?
          | <span class="i">bread</span> ;

<span class="i">protein</span>   → <span class="s">&quot;really&quot;</span>+ <span class="s">&quot;crispy&quot;</span> <span class="s">&quot;bacon&quot;</span>
          | <span class="s">&quot;sausage&quot;</span>
          | ( <span class="s">&quot;scrambled&quot;</span> | <span class="s">&quot;poached&quot;</span> | <span class="s">&quot;fried&quot;</span> ) <span class="s">&quot;eggs&quot;</span> ;

<span class="i">bread</span>     → <span class="s">&quot;toast&quot;</span> | <span class="s">&quot;biscuits&quot;</span> | <span class="s">&quot;English muffin&quot;</span> ;
</pre></div>
<p>我希望不是太糟糕。如果您习惯于在文本编辑器中使用grep或<a href="https://en.wikipedia.org/wiki/Regular_expression#Standards">正则表达式</a>，那么大多数标点符号应该很熟悉。主要区别在于这里的符号表示整个 token ，而不是单个字符。</p>
<p>在本书的其余部分，我们将使用这个记法来精确描述Lox的语法。当你研究编程语言时，你会发现上下文无关文法（使用这个或 <a href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form">EBNF</a> 或其他记法）可以帮助你将你的非正式语法设计想法具体化。它们也是与其他语言黑客交流语法的一个方便的媒介。</p>
<p>我们为Lox定义的规则和产生式也是我们要实现的树状数据结构的指南，以表示内存中的代码。在做到这一点之前，我们需要一个实际的Lox语法，或者至少有足够的语法让我们开始工作。</p>
<h3><a href="#lox表达式的语法" id="lox表达式的语法"><small>5&#8202;.&#8202;1&#8202;.&#8202;3</small>Lox表达式的语法</a></h3>
<p>在上一章中，我们一举完成了Lox的整个词法语法。每个关键词和标点符号都在那里。句法语法更大，在我们真正启动和运行我们的解释器之前，从头到尾研究一遍实在是一件无聊的事情。</p>
<p>因此，我们将在接下来的几章中学习这门语言的子集。一旦我们有了这种小型语言的表示、解析和解释，那么后面的章节将逐步为它增加新的特性，包括新的语法。现在，我们只关注少数几个表达式:</p>
<ul>
<li>
<p><strong>字面值.</strong> 数字, 字符串, 布尔值, 以及 <code>nil</code>.</p>
</li>
<li>
<p><strong>一元表达式.</strong> 前缀 <code>!</code> 用于执行逻辑非，而 <code>-</code> 用于对一个数求反。</p>
</li>
<li>
<p><strong>二元表达式.</strong> 我们熟知并热爱的中缀算术运算符(<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>)和逻辑运算符(<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>)。</p>
</li>
<li>
<p><strong>圆括号.</strong> 一对 <code>(</code> 和 <code>)</code> 包裹着一个表达式。</p>
</li>
</ul>
<p>这为我们提供了足够的语法来表达如下表达式：</p>
<div class="codehilite"><pre><span class="n">1</span> - (<span class="n">2</span> * <span class="n">3</span>) &lt; <span class="n">4</span> == <span class="k">false</span>
</pre></div>
<p>使用我们方便时髦的新记法，语法可以表示为:</p>
<div class="codehilite"><pre><span class="i">expression</span>     → <span class="i">literal</span>
               | <span class="i">unary</span>
               | <span class="i">binary</span>
               | <span class="i">grouping</span> ;

<span class="i">literal</span>        → <span class="t">NUMBER</span> | <span class="t">STRING</span> | <span class="s">&quot;true&quot;</span> | <span class="s">&quot;false&quot;</span> | <span class="s">&quot;nil&quot;</span> ;
<span class="i">grouping</span>       → <span class="s">&quot;(&quot;</span> <span class="i">expression</span> <span class="s">&quot;)&quot;</span> ;
<span class="i">unary</span>          → ( <span class="s">&quot;-&quot;</span> | <span class="s">&quot;!&quot;</span> ) <span class="i">expression</span> ;
<span class="i">binary</span>         → <span class="i">expression</span> <span class="i">operator</span> <span class="i">expression</span> ;
<span class="i">operator</span>       → <span class="s">&quot;==&quot;</span> | <span class="s">&quot;!=&quot;</span> | <span class="s">&quot;&lt;&quot;</span> | <span class="s">&quot;&lt;=&quot;</span> | <span class="s">&quot;&gt;&quot;</span> | <span class="s">&quot;&gt;=&quot;</span>
               | <span class="s">&quot;+&quot;</span>  | <span class="s">&quot;-&quot;</span>  | <span class="s">&quot;*&quot;</span> | <span class="s">&quot;/&quot;</span> ;
</pre></div>
<p>这里有一点额外的<span name="play">元语法</span>。除了对匹配精确 lexeme 的终结符使用加引号的字符串外，我们还对单一 lexeme 的终结符使用大写字母，这些 lexeme 的文本表示可能有所不同。 <code>NUMBER</code> 是任意数字直接量，<code>STRING</code> 是任意字符串直接量。稍后，我们将对 <code>IDENTIFIER</code> 做同样的处理。</p>
<p>这个语法实际上是不明确的，我们在解析它的时候会看到这一点。但是现在已经足够好了。</p>
<aside name="play">
<p>如果你愿意，可以试着用这个语法生成一些表达式，就像我们之前用早餐语法做的那样。你觉得结果表达式看起来对吗？你能让它产生像 <code>1 + / 3</code> 这样的错误吗？</p>
</aside>
<h2><a href="#实现语法树" id="实现语法树"><small>5&#8202;.&#8202;2</small>实现语法树</a></h2>
<p>最后，我们可以写一些代码了。那个小小的表达式语法就是我们的骨架。由于语法是递归的--注意<code>grouping</code>, <code>unary</code>和<code>binary</code>都是指 <code>expression</code> --我们的数据结构将形成一棵树。由于这个结构代表了我们语言的语法，所以它被称为<span name="ast"><strong>语法树</strong></span>。</p>
<aside name="ast">
<p>特别地，我们定义了一个 <strong>抽象语法树</strong> ( <strong>AST</strong> )。在一个 <strong>语法分析树</strong> 中，每一个语法产生式都成为树中的一个节点。AST删除后面阶段不需要的产生式。</p>
</aside>
<p>我们的扫描器使用单个Token类来表示所有的 lexeme。为了区分不同的种类- -想想数字 <code>123</code>  和字符串 <code>"123"</code> - -我们加了一个简单的 TokenType 枚举。句法树并不是那么<span name="token-data">同质化</span>。一元表达式只有一个操作数，二元表达式有两个操作数，字面表达式没有操作数。</p>
<p>我们 <em>可以</em> 把这些都混在一起，变成一个具有任意子级列表的单个Expression类。有些编译器就是这样做的。但是我喜欢充分利用Java的类型系统。因此我们将为表达式定义一个基类。然后，对于每一种表达式- -每个表达式( <code>expression</code> )下的产生式- -我们创建了一个子类，该子类具有该规则所特有的非终结符字段。这样，如果我们试图访问一元表达式的第二个操作数，我们就会得到一个编译错误。</p>
<aside name="token-data">
<p>Tokens 也不是完全同质的。字面值的 Token 保存了值，但其他类型的 lexeme 不需要这种状态。我见过一些扫描器对字面值和其他种类的 lexeme 使用不同的类，但我想我应该让事情更简单。</p>
</aside>
<p>大概是这样的:</p>
<div class="codehilite"><pre><span class="k">package</span> <span class="i">com.craftinginterpreters.lox</span>;

<span class="k">abstract</span> <span class="k">class</span> <span class="t">Expr</span> {<span name="expr"> </span>
  <span class="k">static</span> <span class="k">class</span> <span class="t">Binary</span> <span class="k">extends</span> <span class="t">Expr</span> {
    <span class="t">Binary</span>(<span class="t">Expr</span> <span class="i">left</span>, <span class="t">Token</span> <span class="i">operator</span>, <span class="t">Expr</span> <span class="i">right</span>) {
      <span class="k">this</span>.<span class="i">left</span> = <span class="i">left</span>;
      <span class="k">this</span>.<span class="i">operator</span> = <span class="i">operator</span>;
      <span class="k">this</span>.<span class="i">right</span> = <span class="i">right</span>;
    }

    <span class="k">final</span> <span class="t">Expr</span> <span class="i">left</span>;
    <span class="k">final</span> <span class="t">Token</span> <span class="i">operator</span>;
    <span class="k">final</span> <span class="t">Expr</span> <span class="i">right</span>;
  }

  <span class="c">// Other expressions...</span>
}
</pre></div>
<aside name="expr">
<p>我在代码中避免使用缩写，因为它们会让不知道缩写代表什么的读者犯错误。但是在我所观察的编译器中，&ldquo;Expr&rdquo; 和 &ldquo;Stmt&rdquo; 是如此普遍，以至于我现在也可以开始让你习惯它们了。</p>
</aside>
<p>Expr 是所有表达式类都继承自的基类。正如你在 <code>Binary</code> 中所看到的，子类都嵌套在它里面。这在技术上没有必要，但它让我们把所有的类都压缩到一个 Java 文件中。</p>
<h3><a href="#无处安放的对象" id="无处安放的对象"><small>5&#8202;.&#8202;2&#8202;.&#8202;1</small>无处安放的对象</a></h3>
<p>您会注意到，与Token类非常相似，这里没有任何方法。这是一个愚蠢的结构。写得很好看，但只是一包数据。这在Java这样的面向对象语言中感觉很奇怪。类内不应该 <em>做一些事情</em> 吗？</p>
<p>问题是这些树相关类不属于任何一个领域。既然树是在语法分析时创建的，那么它们应该有语法分析方法吗？或者解释，因为这是他们被消费的地方？树横跨这些领土之间的边界，这意味着它们实际上都不属于 <em>任何一方</em>。</p>
<p>事实上，这些类型的存在是为了使解析器和解释器能够进行通信。这使它适合于简单的没有关联行为的数据类型。这种风格在函数式语言中非常自然，比如Lisp和ML，在这些语言中，所有的数据都与行为分离，但是在Java中感觉很奇怪。</p>
<p>函数式编程的狂热爱好者现在都跳起来惊呼“看！面向对象语言不适合解释器！”我不会这么说。您会记得扫描仪本身非常适合面向对象。它有所有的可变状态来跟踪它在源代码中的位置，有一组定义良好的公共方法，还有一些私有帮助器。</p>
<p>我的感觉是，解释器的每个阶段或部分在面向对象的风格中工作得很好。在它们之间流动的数据结构才是被剥离的行为。</p>
<h3><a href="#metaprogramming-the-trees" id="metaprogramming-the-trees"><small>5&#8202;.&#8202;2&#8202;.&#8202;2</small>Metaprogramming the trees</a></h3>
<p>Java can express behavior-less classes, but I wouldn&rsquo;t say that it&rsquo;s
particularly great at it. Eleven lines of code to stuff three fields in an
object is pretty tedious, and when we&rsquo;re all done, we&rsquo;re going to have 21 of
these classes.</p>
<p>I don&rsquo;t want to waste your time or my ink writing all that down. Really, what is
the essence of each subclass? A name, and a list of typed fields. That&rsquo;s it.
We&rsquo;re smart language hackers, right? Let&rsquo;s <span
name="automate">automate</span>.</p>
<aside name="automate">
<p>Picture me doing an awkward robot dance when you read that. &ldquo;AU-TO-MATE.&rdquo;</p>
</aside>
<p>Instead of tediously handwriting each class definition, field declaration,
constructor, and initializer, we&rsquo;ll hack together a <span
name="python">script</span> that does it for us. It has a description of each
tree type<span class="em">&mdash;</span>its name and fields<span class="em">&mdash;</span>and it prints out the Java code needed to
define a class with that name and state.</p>
<p>This script is a tiny Java command-line app that generates a file named
&ldquo;Expr.java&rdquo;:</p>
<aside name="python">
<p>I got the idea of scripting the syntax tree classes from Jim Hugunin, creator of
Jython and IronPython.</p>
<p>An actual scripting language would be a better fit for this than Java, but I&rsquo;m
trying not to throw too many languages at you.</p>
</aside>
<div class="codehilite"><div class="source-file"><em>com\craftinginterpreters\tool\GenerateAst.java</em><br>
create new file</div>
<pre><span class="k">package</span> <span class="i">com.craftinginterpreters.tool</span>;

<span class="k">import</span> <span class="i">java.io.IOException</span>;
<span class="k">import</span> <span class="i">java.io.PrintWriter</span>;
<span class="k">import</span> <span class="i">java.util.Arrays</span>;
<span class="k">import</span> <span class="i">java.util.List</span>;

<span class="k">public</span> <span class="k">class</span> <span class="t">GenerateAst</span> {
  <span class="k">public</span> <span class="k">static</span> <span class="t">void</span> <span class="i">main</span>(<span class="t">String</span>[] <span class="i">args</span>) <span class="k">throws</span> <span class="t">IOException</span> {
    <span class="k">if</span> (<span class="i">args</span>.<span class="i">length</span> != <span class="n">1</span>) {
      <span class="t">System</span>.<span class="i">err</span>.<span class="i">println</span>(<span class="s">&quot;Usage: generate_ast &lt;output directory&gt;&quot;</span>);
      <span class="t">System</span>.<span class="i">exit</span>(<span class="n">64</span>);
    }
    <span class="t">String</span> <span class="i">outputDir</span> = <span class="i">args</span>[<span class="n">0</span>];
  }
}
</pre></div>
<div class="source-file-narrow"><em>com\craftinginterpreters\tool\GenerateAst.java</em>, create new file</div>

<p>Note that this file is in a different package, <code>.tool</code> instead of <code>.lox</code>. This
script isn&rsquo;t part of the interpreter itself. It&rsquo;s a tool <em>we</em>, the people
hacking on the interpreter, run ourselves to generate the syntax tree classes.
When it&rsquo;s done, we treat &ldquo;Expr.java&rdquo; like any other file in the implementation.
We are merely automating how that file gets authored.</p>
<p>To generate the classes, it needs to have some description of each type and its
fields.</p>
<div class="codehilite"><pre class="insert-before">    String outputDir = args[0];
</pre><div class="source-file"><em>com\craftinginterpreters\tool\GenerateAst.java</em><br>
in <em>main</em>()</div>
<pre class="insert">    <span class="i">defineAst</span>(<span class="i">outputDir</span>, <span class="s">&quot;Expr&quot;</span>, <span class="t">Arrays</span>.<span class="i">asList</span>(
      <span class="s">&quot;Binary   : Expr left, Token operator, Expr right&quot;</span>,
      <span class="s">&quot;Grouping : Expr expression&quot;</span>,
      <span class="s">&quot;Literal  : Object value&quot;</span>,
      <span class="s">&quot;Unary    : Token operator, Expr right&quot;</span>
    ));
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>com\craftinginterpreters\tool\GenerateAst.java</em>, in <em>main</em>()</div>

<p>For brevity&rsquo;s sake, I jammed the descriptions of the expression types into
strings. Each is the name of the class followed by <code>:</code> and the list of fields,
separated by commas. Each field has a type and a name.</p>
<p>The first thing <code>defineAst()</code> needs to do is output the base Expr class.</p>
<div class="codehilite"><div class="source-file"><em>com\craftinginterpreters\tool\GenerateAst.java</em><br>
add after <em>main</em>()</div>
<pre>  <span class="k">private</span> <span class="k">static</span> <span class="t">void</span> <span class="i">defineAst</span>(
      <span class="t">String</span> <span class="i">outputDir</span>, <span class="t">String</span> <span class="i">baseName</span>, <span class="t">List</span>&lt;<span class="t">String</span>&gt; <span class="i">types</span>)
      <span class="k">throws</span> <span class="t">IOException</span> {
    <span class="t">String</span> <span class="i">path</span> = <span class="i">outputDir</span> + <span class="s">&quot;/&quot;</span> + <span class="i">baseName</span> + <span class="s">&quot;.java&quot;</span>;
    <span class="t">PrintWriter</span> <span class="i">writer</span> = <span class="k">new</span> <span class="t">PrintWriter</span>(<span class="i">path</span>, <span class="s">&quot;UTF-8&quot;</span>);

    <span class="i">writer</span>.<span class="i">println</span>(<span class="s">&quot;package com.craftinginterpreters.lox;&quot;</span>);
    <span class="i">writer</span>.<span class="i">println</span>();
    <span class="i">writer</span>.<span class="i">println</span>(<span class="s">&quot;import java.util.List;&quot;</span>);
    <span class="i">writer</span>.<span class="i">println</span>();
    <span class="i">writer</span>.<span class="i">println</span>(<span class="s">&quot;abstract class &quot;</span> + <span class="i">baseName</span> + <span class="s">&quot; {&quot;</span>);

    <span class="i">writer</span>.<span class="i">println</span>(<span class="s">&quot;}&quot;</span>);
    <span class="i">writer</span>.<span class="i">close</span>();
  }
</pre></div>
<div class="source-file-narrow"><em>com\craftinginterpreters\tool\GenerateAst.java</em>, add after <em>main</em>()</div>

<p>When we call this, <code>baseName</code> is &ldquo;Expr&rdquo;, which is both the name of the class and
the name of the file it outputs. We pass this as an argument instead of
hardcoding the name because we&rsquo;ll add a separate family of classes later for
statements.</p>
<p>Inside the base class, we define each subclass.</p>
<div class="codehilite"><pre class="insert-before">    writer.println(&quot;abstract class &quot; + baseName + &quot; {&quot;);

</pre><div class="source-file"><em>com\craftinginterpreters\tool\GenerateAst.java</em><br>
in <em>defineAst</em>()</div>
<pre class="insert">    <span class="c">// The AST classes.</span>
    <span class="k">for</span> (<span class="t">String</span> <span class="i">type</span> : <span class="i">types</span>) {
      <span class="t">String</span> <span class="i">className</span> = <span class="i">type</span>.<span class="i">split</span>(<span class="s">&quot;:&quot;</span>)[<span class="n">0</span>].<span class="i">trim</span>();
      <span class="t">String</span> <span class="i">fields</span> = <span class="i">type</span>.<span class="i">split</span>(<span class="s">&quot;:&quot;</span>)[<span class="n">1</span>].<span class="i">trim</span>();<span name="robust"> </span>
      <span class="i">defineType</span>(<span class="i">writer</span>, <span class="i">baseName</span>, <span class="i">className</span>, <span class="i">fields</span>);
    }
</pre><pre class="insert-after">    writer.println(&quot;}&quot;);
</pre></div>
<div class="source-file-narrow"><em>com\craftinginterpreters\tool\GenerateAst.java</em>, in <em>defineAst</em>()</div>

<aside name="robust">
<p>This isn&rsquo;t the world&rsquo;s most elegant string manipulation code, but that&rsquo;s fine.
It only runs on the exact set of class definitions we give it. Robustness ain&rsquo;t
a priority.</p>
</aside>
<p>That code, in turn, calls:</p>
<div class="codehilite"><div class="source-file"><em>com\craftinginterpreters\tool\GenerateAst.java</em><br>
add after <em>defineAst</em>()</div>
<pre>  <span class="k">private</span> <span class="k">static</span> <span class="t">void</span> <span class="i">defineType</span>(
      <span class="t">PrintWriter</span> <span class="i">writer</span>, <span class="t">String</span> <span class="i">baseName</span>,
      <span class="t">String</span> <span class="i">className</span>, <span class="t">String</span> <span class="i">fieldList</span>) {
    <span class="i">writer</span>.<span class="i">println</span>(<span class="s">&quot;  static class &quot;</span> + <span class="i">className</span> + <span class="s">&quot; extends &quot;</span> +
        <span class="i">baseName</span> + <span class="s">&quot; {&quot;</span>);

    <span class="c">// Constructor.</span>
    <span class="i">writer</span>.<span class="i">println</span>(<span class="s">&quot;    &quot;</span> + <span class="i">className</span> + <span class="s">&quot;(&quot;</span> + <span class="i">fieldList</span> + <span class="s">&quot;) {&quot;</span>);

    <span class="c">// Store parameters in fields.</span>
    <span class="t">String</span>[] <span class="i">fields</span> = <span class="i">fieldList</span>.<span class="i">split</span>(<span class="s">&quot;, &quot;</span>);
    <span class="k">for</span> (<span class="t">String</span> <span class="i">field</span> : <span class="i">fields</span>) {
      <span class="t">String</span> <span class="i">name</span> = <span class="i">field</span>.<span class="i">split</span>(<span class="s">&quot; &quot;</span>)[<span class="n">1</span>];
      <span class="i">writer</span>.<span class="i">println</span>(<span class="s">&quot;      this.&quot;</span> + <span class="i">name</span> + <span class="s">&quot; = &quot;</span> + <span class="i">name</span> + <span class="s">&quot;;&quot;</span>);
    }

    <span class="i">writer</span>.<span class="i">println</span>(<span class="s">&quot;    }&quot;</span>);

    <span class="c">// Fields.</span>
    <span class="i">writer</span>.<span class="i">println</span>();
    <span class="k">for</span> (<span class="t">String</span> <span class="i">field</span> : <span class="i">fields</span>) {
      <span class="i">writer</span>.<span class="i">println</span>(<span class="s">&quot;    final &quot;</span> + <span class="i">field</span> + <span class="s">&quot;;&quot;</span>);
    }

    <span class="i">writer</span>.<span class="i">println</span>(<span class="s">&quot;  }&quot;</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>com\craftinginterpreters\tool\GenerateAst.java</em>, add after <em>defineAst</em>()</div>

<p>There we go. All of that glorious Java boilerplate is done. It declares each
field in the class body. It defines a constructor for the class with parameters
for each field and initializes them in the body.</p>
<p>Compile and run this Java program now and it <span name="longer">blasts</span>
out a new &ldquo;.java&rdquo; file containing a few dozen lines of code. That file&rsquo;s
about to get even longer.</p>
<aside name="longer">
<p><a href="appendix-ii.html">Appendix II</a> contains the code generated by this script once we&rsquo;ve finished
implementing jlox and defined all of its syntax tree nodes.</p>
</aside>
<h2><a href="#working-with-trees" id="working-with-trees"><small>5&#8202;.&#8202;3</small>Working with Trees</a></h2>
<p>Put on your imagination hat for a moment. Even though we aren&rsquo;t there yet,
consider what the interpreter will do with the syntax trees. Each kind of
expression in Lox behaves differently at runtime. That means the interpreter
needs to select a different chunk of code to handle each expression type. With
tokens, we can simply switch on the TokenType. But we don&rsquo;t have a &ldquo;type&rdquo; enum
for the syntax trees, just a separate Java class for each one.</p>
<p>We could write a long chain of type tests:</p>
<div class="codehilite"><pre><span class="k">if</span> (<span class="i">expr</span> <span class="k">instanceof</span> <span class="t">Expr</span>.<span class="t">Binary</span>) {
  <span class="c">// ...</span>
} <span class="k">else</span> <span class="k">if</span> (<span class="i">expr</span> <span class="k">instanceof</span> <span class="t">Expr</span>.<span class="t">Grouping</span>) {
  <span class="c">// ...</span>
} <span class="k">else</span> <span class="c">// ...</span>
</pre></div>
<p>But all of those sequential type tests are slow. Expression types whose names
are alphabetically later would take longer to execute because they&rsquo;d fall
through more <code>if</code> cases before finding the right type. That&rsquo;s not my idea of an
elegant solution.</p>
<p>We have a family of classes and we need to associate a chunk of behavior with
each one. The natural solution in an object-oriented language like Java is to
put those behaviors into methods on the classes themselves. We could add an
abstract <span name="interpreter-pattern"><code>interpret()</code></span> method on Expr
which each subclass would then implement to interpret itself.</p>
<aside name="interpreter-pattern">
<p>This exact thing is literally called the <a href="https://en.wikipedia.org/wiki/Interpreter_pattern">&ldquo;Interpreter pattern&rdquo;</a> in
<em>Design Patterns: Elements of Reusable Object-Oriented Software</em>, by Erich
Gamma, et al.</p>
</aside>
<p>This works alright for tiny projects, but it scales poorly. Like I noted before,
these tree classes span a few domains. At the very least, both the parser and
interpreter will mess with them. As <a href="resolving-and-binding.html">you&rsquo;ll see later</a>, we need to
do name resolution on them. If our language was statically typed, we&rsquo;d have a
type checking pass.</p>
<p>If we added instance methods to the expression classes for every one of those
operations, that would smush a bunch of different domains together. That
violates <a href="https://en.wikipedia.org/wiki/Separation_of_concerns">separation of concerns</a> and leads to hard-to-maintain code.</p>
<h3><a href="#the-expression-problem" id="the-expression-problem"><small>5&#8202;.&#8202;3&#8202;.&#8202;1</small>The expression problem</a></h3>
<p>This problem is more fundamental than it may seem at first. We have a handful of
types, and a handful of high-level operations like &ldquo;interpret&rdquo;. For each pair of
type and operation, we need a specific implementation. Picture a table:</p><img src="image/representing-code/table.png" alt="A table where rows are labeled with expression classes, and columns are function names." />
<p>Rows are types, and columns are operations. Each cell represents the unique
piece of code to implement that operation on that type.</p>
<p>An object-oriented language like Java assumes that all of the code in one row
naturally hangs together. It figures all the things you do with a type are
likely related to each other, and the language makes it easy to define them
together as methods inside the same class.</p><img src="image/representing-code/rows.png" alt="The table split into rows for each class." />
<p>This makes it easy to extend the table by adding new rows. Simply define a new
class. No existing code has to be touched. But imagine if you want to add a new
<em>operation</em><span class="em">&mdash;</span>a new column. In Java, that means cracking open each of those
existing classes and adding a method to it.</p>
<p>Functional paradigm languages in the <span name="ml">ML</span> family flip that
around. There, you don&rsquo;t have classes with methods. Types and functions are
totally distinct. To implement an operation for a number of different types, you
define a single function. In the body of that function, you use <em>pattern
matching</em><span class="em">&mdash;</span>sort of a type-based switch on steroids<span class="em">&mdash;</span>to implement the
operation for each type all in one place.</p>
<aside name="ml">
<p>ML, short for &ldquo;metalanguage&rdquo; was created by Robin Milner and friends and forms
one of the main branches in the great programming language family tree. Its
children include SML, Caml, OCaml, Haskell, and F#. Even Scala, Rust, and Swift
bear a strong resemblance.</p>
<p>Much like Lisp, it is one of those languages that is so full of good ideas that
language designers today are still rediscovering them over forty years later.</p>
</aside>
<p>This makes it trivial to add new operations<span class="em">&mdash;</span>simply define another function
that pattern matches on all of the types.</p><img src="image/representing-code/columns.png" alt="The table split into columns for each function." />
<p>But, conversely, adding a new type is hard. You have to go back and add a new
case to all of the pattern matches in all of the existing functions.</p>
<p>Each style has a certain &ldquo;grain&rdquo; to it. That&rsquo;s what the paradigm name literally
says<span class="em">&mdash;</span>an object-oriented language wants you to <em>orient</em> your code along the
rows of types. A functional language instead encourages you to lump each
column&rsquo;s worth of code together into a <em>function</em>.</p>
<p>A bunch of smart language nerds noticed that neither style made it easy to add
<em>both</em> rows and columns to the <span name="multi">table</span>. They called this
difficulty the &ldquo;expression problem&rdquo; because<span class="em">&mdash;</span>like we are now<span class="em">&mdash;</span>they first ran
into it when they were trying to figure out the best way to model expression
syntax tree nodes in a compiler.</p>
<aside name="multi">
<p>Languages with <em>multimethods</em>, like Common Lisp&rsquo;s CLOS, Dylan, and Julia do
support adding both new types and operations easily. What they typically
sacrifice is either static type checking, or separate compilation.</p>
</aside>
<p>People have thrown all sorts of language features, design patterns, and
programming tricks to try to knock that problem down but no perfect language has
finished it off yet. In the meantime, the best we can do is try to pick a
language whose orientation matches the natural architectural seams in the
program we&rsquo;re writing.</p>
<p>Object-orientation works fine for many parts of our interpreter, but these tree
classes rub against the grain of Java. Fortunately, there&rsquo;s a design pattern we
can bring to bear on it.</p>
<h3><a href="#the-visitor-pattern" id="the-visitor-pattern"><small>5&#8202;.&#8202;3&#8202;.&#8202;2</small>The Visitor pattern</a></h3>
<p>The <strong>Visitor pattern</strong> is the most widely misunderstood pattern in all of
<em>Design Patterns</em>, which is really saying something when you look at the
software architecture excesses of the past couple of decades.</p>
<p>The trouble starts with terminology. The pattern isn&rsquo;t about &ldquo;visiting&rdquo;, and the
&ldquo;accept&rdquo; method in it doesn&rsquo;t conjure up any helpful imagery either. Many think
the pattern has to do with traversing trees, which isn&rsquo;t the case at all. We
<em>are</em> going to use it on a set of classes that are tree-like, but that&rsquo;s a
coincidence. As you&rsquo;ll see, the pattern works as well on a single object.</p>
<p>The Visitor pattern is really about approximating the functional style within an
OOP language. It lets us add new columns to that table easily. We can define all
of the behavior for a new operation on a set of types in one place, without
having to touch the types themselves. It does this the same way we solve almost
every problem in computer science: by adding a layer of indirection.</p>
<p>Before we apply it to our auto-generated Expr classes, let&rsquo;s walk through a
simpler example. Say we have two kinds of pastries: <span
name="beignet">beignets</span> and crullers.</p>
<aside name="beignet">
<p>A beignet (pronounced &ldquo;ben-yay&rdquo;, with equal emphasis on both syllables) is a
deep-fried pastry in the same family as doughnuts. When the French colonized
North America in the 1700s, they brought beignets with them. Today, in the US,
they are most strongly associated with the cuisine of New Orleans.</p>
<p>My preferred way to consume them is fresh out of the fryer at Café du Monde,
piled high in powdered sugar, and washed down with a cup of café au lait while I
watch tourists staggering around trying to shake off their hangover from the
previous night&rsquo;s revelry.</p>
</aside>
<div class="codehilite"><pre>  <span class="k">abstract</span> <span class="k">class</span> <span class="t">Pastry</span> {
  }

  <span class="k">class</span> <span class="t">Beignet</span> <span class="k">extends</span> <span class="t">Pastry</span> {
  }

  <span class="k">class</span> <span class="t">Cruller</span> <span class="k">extends</span> <span class="t">Pastry</span> {
  }
</pre></div>

<p>We want to be able to define new pastry operations<span class="em">&mdash;</span>cooking them, eating them,
decorating them, etc.<span class="em">&mdash;</span>without having to add a new method to each class every
time. Here&rsquo;s how we do it. First, we define a separate interface.</p>
<div class="codehilite"><pre>  <span class="k">interface</span> <span class="t">PastryVisitor</span> {
    <span class="t">void</span> <span class="i">visitBeignet</span>(<span class="t">Beignet</span> <span class="i">beignet</span>);<span name="overload"> </span>
    <span class="t">void</span> <span class="i">visitCruller</span>(<span class="t">Cruller</span> <span class="i">cruller</span>);
  }
</pre></div>

<aside name="overload">
<p>In <em>Design Patterns</em>, both of these methods are confusingly named <code>visit()</code>, and
they rely on overloading to distinguish them. This leads some readers to think
that the correct visit method is chosen <em>at runtime</em> based on its parameter
type. That isn&rsquo;t the case. Unlike over<em>riding</em>, over<em>loading</em> is statically
dispatched at compile time.</p>
<p>Using distinct names for each method makes the dispatch more obvious, and also
shows you how to apply this pattern in languages that don&rsquo;t support overloading.</p>
</aside>
<p>Each operation that can be performed on pastries is a new class that implements
that interface. It has a concrete method for each type of pastry. That keeps the
code for the operation on both types all nestled snugly together in one class.</p>
<p>Given some pastry, how do we route it to the correct method on the visitor based
on its type? Polymorphism to the rescue! We add this method to Pastry:</p>
<div class="codehilite"><pre class="insert-before">  abstract class Pastry {
</pre><pre class="insert">    <span class="k">abstract</span> <span class="t">void</span> <span class="i">accept</span>(<span class="t">PastryVisitor</span> <span class="i">visitor</span>);
</pre><pre class="insert-after">  }
</pre></div>

<p>Each subclass implements it.</p>
<div class="codehilite"><pre class="insert-before">  class Beignet extends Pastry {
</pre><pre class="insert">    <span class="a">@Override</span>
    <span class="t">void</span> <span class="i">accept</span>(<span class="t">PastryVisitor</span> <span class="i">visitor</span>) {
      <span class="i">visitor</span>.<span class="i">visitBeignet</span>(<span class="k">this</span>);
    }
</pre><pre class="insert-after">  }
</pre></div>

<p>And:</p>
<div class="codehilite"><pre class="insert-before">  class Cruller extends Pastry {
</pre><pre class="insert">    <span class="a">@Override</span>
    <span class="t">void</span> <span class="i">accept</span>(<span class="t">PastryVisitor</span> <span class="i">visitor</span>) {
      <span class="i">visitor</span>.<span class="i">visitCruller</span>(<span class="k">this</span>);
    }
</pre><pre class="insert-after">  }
</pre></div>

<p>To perform an operation on a pastry, we call its <code>accept()</code> method and pass in
the visitor for the operation we want to execute. The pastry<span class="em">&mdash;</span>the specific
subclass&rsquo;s overriding implementation of <code>accept()</code><span class="em">&mdash;</span>turns around and calls the
appropriate visit method on the visitor and passes <em>itself</em> to it.</p>
<p>That&rsquo;s the heart of the trick right there. It lets us use polymorphic dispatch
on the <em>pastry</em> classes to select the appropriate method on the <em>visitor</em> class.
In the table, each pastry class is a row, but if you look at all of the methods
for a single visitor, they form a <em>column</em>.</p><img src="image/representing-code/visitor.png" alt="Now all of the cells for one operation are part of the same class, the visitor." />
<p>We added one <code>accept()</code> method to each class, and we can use it for as many
visitors as we want without ever having to touch the pastry classes again. It&rsquo;s
a clever pattern.</p>
<h3><a href="#visitors-for-expressions" id="visitors-for-expressions"><small>5&#8202;.&#8202;3&#8202;.&#8202;3</small>Visitors for expressions</a></h3>
<p>OK, let&rsquo;s weave it into our expression classes. We&rsquo;ll also <span
name="context">refine</span> the pattern a little. In the pastry example, the
visit and <code>accept()</code> methods don&rsquo;t return anything. In practice, visitors often
want to define operations that produce values. But what return type should
<code>accept()</code> have? We can&rsquo;t assume every visitor class wants to produce the same
type, so we&rsquo;ll use generics to let each implementation fill in a return type.</p>
<aside name="context">
<p>Another common refinement is an additional &ldquo;context&rdquo; parameter that is passed to
the visit methods and then sent back through as a parameter to <code>accept()</code>. That
lets operations take an additional parameter. The visitors we&rsquo;ll define in the
book don&rsquo;t need that, so I omitted it.</p>
</aside>
<p>First, we define the visitor interface. Again, we nest it inside the base class
so that we can keep everything in one file.</p>
<div class="codehilite"><pre class="insert-before">    writer.println(&quot;abstract class &quot; + baseName + &quot; {&quot;);

</pre><div class="source-file"><em>com\craftinginterpreters\tool\GenerateAst.java</em><br>
in <em>defineAst</em>()</div>
<pre class="insert">    <span class="i">defineVisitor</span>(<span class="i">writer</span>, <span class="i">baseName</span>, <span class="i">types</span>);

</pre><pre class="insert-after">    // The AST classes.
</pre></div>
<div class="source-file-narrow"><em>com\craftinginterpreters\tool\GenerateAst.java</em>, in <em>defineAst</em>()</div>

<p>That function generates the visitor interface.</p>
<div class="codehilite"><div class="source-file"><em>com\craftinginterpreters\tool\GenerateAst.java</em><br>
add after <em>defineAst</em>()</div>
<pre>  <span class="k">private</span> <span class="k">static</span> <span class="t">void</span> <span class="i">defineVisitor</span>(
      <span class="t">PrintWriter</span> <span class="i">writer</span>, <span class="t">String</span> <span class="i">baseName</span>, <span class="t">List</span>&lt;<span class="t">String</span>&gt; <span class="i">types</span>) {
    <span class="i">writer</span>.<span class="i">println</span>(<span class="s">&quot;  interface Visitor&lt;R&gt; {&quot;</span>);

    <span class="k">for</span> (<span class="t">String</span> <span class="i">type</span> : <span class="i">types</span>) {
      <span class="t">String</span> <span class="i">typeName</span> = <span class="i">type</span>.<span class="i">split</span>(<span class="s">&quot;:&quot;</span>)[<span class="n">0</span>].<span class="i">trim</span>();
      <span class="i">writer</span>.<span class="i">println</span>(<span class="s">&quot;    R visit&quot;</span> + <span class="i">typeName</span> + <span class="i">baseName</span> + <span class="s">&quot;(&quot;</span> +
          <span class="i">typeName</span> + <span class="s">&quot; &quot;</span> + <span class="i">baseName</span>.<span class="i">toLowerCase</span>() + <span class="s">&quot;);&quot;</span>);
    }

    <span class="i">writer</span>.<span class="i">println</span>(<span class="s">&quot;  }&quot;</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>com\craftinginterpreters\tool\GenerateAst.java</em>, add after <em>defineAst</em>()</div>

<p>Here, we iterate through all of the subclasses and declare a visit method for
each one. When we define new expression types later, this will automatically
include them.</p>
<p>Inside the base class, we define the abstract <code>accept()</code> method.</p>
<div class="codehilite"><pre class="insert-before">      defineType(writer, baseName, className, fields);
    }
</pre><div class="source-file"><em>com\craftinginterpreters\tool\GenerateAst.java</em><br>
in <em>defineAst</em>()</div>
<pre class="insert">

    <span class="c">// The base accept() method.</span>
    <span class="i">writer</span>.<span class="i">println</span>();
    <span class="i">writer</span>.<span class="i">println</span>(<span class="s">&quot;  abstract &lt;R&gt; R accept(Visitor&lt;R&gt; visitor);&quot;</span>);

</pre><pre class="insert-after">    writer.println(&quot;}&quot;);
</pre></div>
<div class="source-file-narrow"><em>com\craftinginterpreters\tool\GenerateAst.java</em>, in <em>defineAst</em>()</div>

<p>Finally, each subclass implements that and calls the right visit method for its
own type.</p>
<div class="codehilite"><pre class="insert-before">    writer.println(&quot;    }&quot;);
</pre><div class="source-file"><em>com\craftinginterpreters\tool\GenerateAst.java</em><br>
in <em>defineType</em>()</div>
<pre class="insert">

    <span class="c">// Visitor pattern.</span>
    <span class="i">writer</span>.<span class="i">println</span>();
    <span class="i">writer</span>.<span class="i">println</span>(<span class="s">&quot;    @Override&quot;</span>);
    <span class="i">writer</span>.<span class="i">println</span>(<span class="s">&quot;    &lt;R&gt; R accept(Visitor&lt;R&gt; visitor) {&quot;</span>);
    <span class="i">writer</span>.<span class="i">println</span>(<span class="s">&quot;      return visitor.visit&quot;</span> +
        <span class="i">className</span> + <span class="i">baseName</span> + <span class="s">&quot;(this);&quot;</span>);
    <span class="i">writer</span>.<span class="i">println</span>(<span class="s">&quot;    }&quot;</span>);
</pre><pre class="insert-after">

    // Fields.
</pre></div>
<div class="source-file-narrow"><em>com\craftinginterpreters\tool\GenerateAst.java</em>, in <em>defineType</em>()</div>

<p>There we go. Now we can define operations on expressions without having to muck
with the classes or our generator script. Compile and run this generator script
to output an updated &ldquo;Expr.java&rdquo; file. It contains a generated Visitor
interface and a set of expression node classes that support the Visitor pattern
using it.</p>
<p>Before we end this rambling chapter, let&rsquo;s implement that Visitor interface and
see the pattern in action.</p>
<h2><a href="#a-not-very-pretty-printer" id="a-not-very-pretty-printer"><small>5&#8202;.&#8202;4</small>A (Not Very) Pretty Printer</a></h2>
<p>When we debug our parser and interpreter, it&rsquo;s often useful to look at a parsed
syntax tree and make sure it has the structure we expect. We could inspect it in
the debugger, but that can be a chore.</p>
<p>Instead, we&rsquo;d like some code that, given a syntax tree, produces an unambiguous
string representation of it. Converting a tree to a string is sort of the
opposite of a parser, and is often called &ldquo;pretty printing&rdquo; when the goal is to
produce a string of text that is valid syntax in the source language.</p>
<p>That&rsquo;s not our goal here. We want the string to very explicitly show the nesting
structure of the tree. A printer that returned <code>1 + 2 * 3</code> isn&rsquo;t super helpful
if what we&rsquo;re trying to debug is whether operator precedence is handled
correctly. We want to know if the <code>+</code> or <code>*</code> is at the top of the tree.</p>
<p>To that end, the string representation we produce isn&rsquo;t going to be Lox syntax.
Instead, it will look a lot like, well, Lisp. Each expression is explicitly
parenthesized, and all of its subexpressions and tokens are contained in that.</p>
<p>Given a syntax tree like:</p><img src="image/representing-code/expression.png" alt="An example syntax tree." />
<p>It produces:</p>
<div class="codehilite"><pre>(* (- 123) (group 45.67))
</pre></div>
<p>Not exactly &ldquo;pretty&rdquo;, but it does show the nesting and grouping explicitly. To
implement this, we define a new class.</p>
<div class="codehilite"><div class="source-file"><em>com\craftinginterpreters\lox\AstPrinter.java</em><br>
create new file</div>
<pre><span class="k">package</span> <span class="i">com.craftinginterpreters.lox</span>;

<span class="k">class</span> <span class="t">AstPrinter</span> <span class="k">implements</span> <span class="t">Expr</span>.<span class="t">Visitor</span>&lt;<span class="t">String</span>&gt; {
  <span class="t">String</span> <span class="i">print</span>(<span class="t">Expr</span> <span class="i">expr</span>) {
    <span class="k">return</span> <span class="i">expr</span>.<span class="i">accept</span>(<span class="k">this</span>);
  }
}
</pre></div>
<div class="source-file-narrow"><em>com\craftinginterpreters\lox\AstPrinter.java</em>, create new file</div>

<p>As you can see, it implements the visitor interface. That means we need visit
methods for each of the expression types we have so far.</p>
<div class="codehilite"><pre class="insert-before">    return expr.accept(this);
  }
</pre><div class="source-file"><em>com\craftinginterpreters\lox\AstPrinter.java</em><br>
add after <em>print</em>()</div>
<pre class="insert">

  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">String</span> <span class="i">visitBinaryExpr</span>(<span class="t">Expr</span>.<span class="t">Binary</span> <span class="i">expr</span>) {
    <span class="k">return</span> <span class="i">parenthesize</span>(<span class="i">expr</span>.<span class="i">operator</span>.<span class="i">lexeme</span>,
                        <span class="i">expr</span>.<span class="i">left</span>, <span class="i">expr</span>.<span class="i">right</span>);
  }

  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">String</span> <span class="i">visitGroupingExpr</span>(<span class="t">Expr</span>.<span class="t">Grouping</span> <span class="i">expr</span>) {
    <span class="k">return</span> <span class="i">parenthesize</span>(<span class="s">&quot;group&quot;</span>, <span class="i">expr</span>.<span class="i">expression</span>);
  }

  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">String</span> <span class="i">visitLiteralExpr</span>(<span class="t">Expr</span>.<span class="t">Literal</span> <span class="i">expr</span>) {
    <span class="k">if</span> (<span class="i">expr</span>.<span class="i">value</span> == <span class="k">null</span>) <span class="k">return</span> <span class="s">&quot;nil&quot;</span>;
    <span class="k">return</span> <span class="i">expr</span>.<span class="i">value</span>.<span class="i">toString</span>();
  }

  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">String</span> <span class="i">visitUnaryExpr</span>(<span class="t">Expr</span>.<span class="t">Unary</span> <span class="i">expr</span>) {
    <span class="k">return</span> <span class="i">parenthesize</span>(<span class="i">expr</span>.<span class="i">operator</span>.<span class="i">lexeme</span>, <span class="i">expr</span>.<span class="i">right</span>);
  }
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>com\craftinginterpreters\lox\AstPrinter.java</em>, add after <em>print</em>()</div>

<p>Literal expressions are easy<span class="em">&mdash;</span>they convert the value to a string with a little
check to handle Java&rsquo;s <code>null</code> standing in for Lox&rsquo;s <code>nil</code>. The other expressions
have subexpressions, so they use this <code>parenthesize()</code> helper method:</p>
<div class="codehilite"><div class="source-file"><em>com\craftinginterpreters\lox\AstPrinter.java</em><br>
add after <em>visitUnaryExpr</em>()</div>
<pre>  <span class="k">private</span> <span class="t">String</span> <span class="i">parenthesize</span>(<span class="t">String</span> <span class="i">name</span>, <span class="t">Expr</span>... <span class="i">exprs</span>) {
    <span class="t">StringBuilder</span> <span class="i">builder</span> = <span class="k">new</span> <span class="t">StringBuilder</span>();

    <span class="i">builder</span>.<span class="i">append</span>(<span class="s">&quot;(&quot;</span>).<span class="i">append</span>(<span class="i">name</span>);
    <span class="k">for</span> (<span class="t">Expr</span> <span class="i">expr</span> : <span class="i">exprs</span>) {
      <span class="i">builder</span>.<span class="i">append</span>(<span class="s">&quot; &quot;</span>);
      <span class="i">builder</span>.<span class="i">append</span>(<span class="i">expr</span>.<span class="i">accept</span>(<span class="k">this</span>));
    }
    <span class="i">builder</span>.<span class="i">append</span>(<span class="s">&quot;)&quot;</span>);

    <span class="k">return</span> <span class="i">builder</span>.<span class="i">toString</span>();
  }
</pre></div>
<div class="source-file-narrow"><em>com\craftinginterpreters\lox\AstPrinter.java</em>, add after <em>visitUnaryExpr</em>()</div>

<p>It takes a name and a list of subexpressions and wraps them all up in
parentheses, yielding a string like:</p>
<div class="codehilite"><pre>(+ 1 2)
</pre></div>
<p>Note that it calls <code>accept()</code> on each subexpression and passes in itself. This
is the <span name="tree">recursive</span> step that lets us print an entire
tree.</p>
<aside name="tree">
<p>This recursion is also why people think the Visitor pattern itself has to do
with trees.</p>
</aside>
<p>We don&rsquo;t have a parser yet, so it&rsquo;s hard to see this in action. For now, we&rsquo;ll
hack together a little <code>main()</code> method that manually instantiates a tree and
prints it.</p>
<div class="codehilite"><div class="source-file"><em>com\craftinginterpreters\lox\AstPrinter.java</em><br>
add after <em>parenthesize</em>()</div>
<pre>  <span class="k">public</span> <span class="k">static</span> <span class="t">void</span> <span class="i">main</span>(<span class="t">String</span>[] <span class="i">args</span>) {
    <span class="t">Expr</span> <span class="i">expression</span> = <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Binary</span>(
        <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Unary</span>(
            <span class="k">new</span> <span class="t">Token</span>(<span class="t">TokenType</span>.<span class="i">MINUS</span>, <span class="s">&quot;-&quot;</span>, <span class="k">null</span>, <span class="n">1</span>),
            <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Literal</span>(<span class="n">123</span>)),
        <span class="k">new</span> <span class="t">Token</span>(<span class="t">TokenType</span>.<span class="i">STAR</span>, <span class="s">&quot;*&quot;</span>, <span class="k">null</span>, <span class="n">1</span>),
        <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Grouping</span>(
            <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Literal</span>(<span class="n">45.67</span>)));

    <span class="t">System</span>.<span class="i">out</span>.<span class="i">println</span>(<span class="k">new</span> <span class="t">AstPrinter</span>().<span class="i">print</span>(<span class="i">expression</span>));
  }
</pre></div>
<div class="source-file-narrow"><em>com\craftinginterpreters\lox\AstPrinter.java</em>, add after <em>parenthesize</em>()</div>

<p>If we did everything right, it prints:</p>
<div class="codehilite"><pre>(* (- 123) (group 45.67))
</pre></div>
<p>You can go ahead and delete this method. We won&rsquo;t need it. Also, as we add new
syntax tree types, I won&rsquo;t bother showing the necessary visit methods for them
in AstPrinter. If you want to (and you want the Java compiler to not yell at
you), go ahead and add them yourself. It will come in handy in the next chapter
when we start parsing Lox code into syntax trees. Or, if you don&rsquo;t care to
maintain AstPrinter, feel free to delete it. We won&rsquo;t need it again.</p>
<div class="challenges">
<h2><a href="#challenges" id="challenges">Challenges</a></h2>
<ol>
<li>
<p>Earlier, I said that the <code>|</code>, <code>*</code>, and <code>+</code> forms we added to our grammar
metasyntax were just syntactic sugar. Take this grammar:</p>
<div class="codehilite"><pre><span class="i">expr</span> → <span class="i">expr</span> ( <span class="s">&quot;(&quot;</span> ( <span class="i">expr</span> ( <span class="s">&quot;,&quot;</span> <span class="i">expr</span> )* )? <span class="s">&quot;)&quot;</span> | <span class="s">&quot;.&quot;</span> <span class="t">IDENTIFIER</span> )+
     | <span class="t">IDENTIFIER</span>
     | <span class="t">NUMBER</span>
</pre></div>
<p>Produce a grammar that matches the same language but does not use any of
that notational sugar.</p>
<p><em>Bonus:</em> What kind of expression does this bit of grammar encode?</p>
</li>
<li>
<p>The Visitor pattern lets you emulate the functional style in an
object-oriented language. Devise a complementary pattern for a functional
language. It should let you bundle all of the operations on one type
together and let you define new types easily.</p>
<p>(SML or Haskell would be ideal for this exercise, but Scheme or another Lisp
works as well.)</p>
</li>
<li>
<p>In <a href="https://en.wikipedia.org/wiki/Reverse_Polish_notation">reverse Polish notation</a> (RPN), the operands to an arithmetic
operator are both placed before the operator, so <code>1 + 2</code> becomes <code>1 2 +</code>.
Evaluation proceeds from left to right. Numbers are pushed onto an implicit
stack. An arithmetic operator pops the top two numbers, performs the
operation, and pushes the result. Thus, this:</p>
<div class="codehilite"><pre>(<span class="n">1</span> + <span class="n">2</span>) * (<span class="n">4</span> - <span class="n">3</span>)
</pre></div>
<p>in RPN becomes:</p>
<div class="codehilite"><pre><span class="n">1</span> <span class="n">2</span> + <span class="n">4</span> <span class="n">3</span> - *
</pre></div>
<p>Define a visitor class for our syntax tree classes that takes an expression,
converts it to RPN, and returns the resulting string.</p>
</li>
</ol>
</div>

<footer>
<a href="parsing-expressions.html" class="next">
  Next Chapter: &ldquo;Parsing Expressions&rdquo; &rarr;
</a>
Handcrafted by Robert Nystrom&ensp;&mdash;&ensp;<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy; 2015&hairsp;&ndash;&hairsp;2021</a>
</footer>
</article>

</div>
</body>
</html>
