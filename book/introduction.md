> 童话故事一点都不虚幻，它让你知道世上有邪恶，但关键是让你明白人可以战胜邪恶。
>
> <cite>G.K. Chesterton by way of Neil Gaiman, <em>Coraline</em></cite>

我很高兴我们能一起踏上这段旅程。这是一本关于为编程语言实现解释器的书。它也是一本关于如何设计一种值得实现的语言的书。这是我刚开始学习语言时就希望拥有的书，也是我已经在<span
name="head">脑子</span>里写了近十年的书。

<aside name="head">

我的朋友和家人，对不起，我一直都很心不在焉!

</aside>

本书中，我们将一步步为一个全功能的语言实现两个完整的解释器。我假设这是您第一次涉足编程语言，因此我将介绍构建一个完整、可用、快速的语言实现所需的每个概念，每行代码。

为了在一本书中塞进两个完整的实现，而不使它变成一个门槛，本书的理论部分比其他书更薄。在构建系统的每个部分时，我将介绍其背后的历史和概念。我会尽量让你熟悉这些行话，让您即便在充满PL（编程语言）研究人员的<span name="party">鸡尾酒会</span>中，也能快速融入其中。

<aside name="party">

奇怪的是，我曾多次发现自己处于这种情况。你不会相信他们中的一些人这么能喝。

</aside>

但是我们主要精力还是花在了让语言运转起来上。这并不是说理论不重要。在学习一门语言时，能够对语法和语义进行精确和<span name="formal">公式化</span>的推理是一项至关重要的技能。但是，就我个人而言，我通过实践学习得最好。对于我来说，费力地阅读充满抽象概念的段落并真正理解它们太难了。但如果我（根据理论）编写了代码，运行并调试它，那么我就能 *掌握* 它。

<aside name="formal">

静态类型系统尤其需要严格的形式推理。破解类型系统就像证明数学定理一样。

事实证明，这并不是巧合。在上世纪初，哈斯克-库里和威廉-阿尔文-霍华德表明，它们是同一枚硬币的两面：[the Curry-Howard isomorphism][] （Curry-Howard同构）。

[the curry-howard isomorphism]: https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence

</aside>

这就是我对您的期望。我想让你们直观地理解一门真正的语言是如何生存和呼吸的。我希望，当你以后阅读其他理论性更强的书籍时，那些概念会牢牢地扎根在你的脑海里，依附于这个有形的基石之上。

##  为什么要学这些东西？

每一本编译器相关书籍的前言似乎都有这一节。我不知道为什么编程语言会引起这种存在主义的怀疑。就像我不认为鸟类学书籍担心这东西。他们假设读者喜欢鸟类，然后就开始教学。

但是编程语言有点不同。我认为，对我们中的任何一个人来说，创造一种广泛成功的通用编程语言的可能性确实很小，这是事实。装上所有世界上广泛使用的语言的设计者们甚至不需要露营车，一辆大众2型公交车足以。如果加入这个精英群体是学习语言的唯一理由，那么难以自圆其说。幸运的是，事实并非如此。

###  小型语言无处不在

每一种成功的通用语言，都对应了上千种成功的小众语言。我们过去称它们为“小语言”，但术语泛滥的今天它们有了“领域特定语言（即DSL）”的名称。这些是为特定任务量身定做的洋泾浜语言，就像应用程序脚本语言、模板引擎、标记格式和配置文件。

<span name="little"></span><img src="image/introduction/little-languages.png" alt="A random selection of little languages." />

<aside name="little">

一些你可能遇到的小语言。

</aside>

几乎每个大型软件项目都需要一些这样的东西。如果可以的话，最好是重用现有的工具，而不是自己开发。一旦考虑到文档、调试器、编辑器支持、语法高亮显示和所有其他可能的障碍，自己实现就成了一项艰巨的任务。

但是，当现有的库不能满足您的需要时，你仍然很有可能发现自己需要开发一个解析器或其他工具。即使重用一些现有的实现，您也不可避免地需要调试和维护，并在探究它的内部。

###  语言是很好的锻炼

长跑运动员有时会在脚踝上绑重物，或在大气稀薄的高海拔地区训练。当他们后来卸下负担时，轻盈的四肢和富氧的空气使他们能够跑得更远更快。

实现一门语言是对编程技能的真正考验。代码复杂，性能也至关重要。您必须掌握递归、动态数组、树、图和哈希表。您可能至少在日常编程中使用哈希表，但您对它们的理解程度有多高呢？好吧，在我们从头完成我们自己的作品后，我保证你会明白的。

虽然我想说明解释器并不像您想的那样令人生畏，但实现一个好的解释器仍然是一个挑战。学会了它，您会成为一个更强大的程序员，并且在日常工作中也能更加灵巧地使用数据结构和算法。

### One more reason

这最后一个原因我很难承认，因为它是很私密的理由。我从小学习编程以来，我觉得语言有一种神奇的力量。当我第一次一个键一个键地敲出BASIC程序时，我无法想象BASIC语言本身是如何制作出来的。

后来，我的大学朋友们在谈论他们的编译器课程时，脸上的敬畏和惊恐的表情足以让我相信，语言黑客是一种不同的人类--某种获得了通向神秘艺术的特权的巫师。

这是一个迷人的<span name="image">形象</span>，但它也有黑暗的一面。我感觉自己不像个巫师，所以我认为自己缺乏加入秘社所需的先天品质。 虽然自从我在学校的笔记本上涂写一些捏造的关键词后，我就对语言很着迷，但我花了几十年的时间才鼓起勇气去尝试真正学习它们。那种 "神奇 "的特质，那种排他性的感觉，将我挡在门外。

<aside name="image">

而它的从业者也毫不犹豫地渲染这种形象。有两本关于编程语言的开创性书籍的封面上有一条[龙][]和一个[巫师][]。

[龙]: https://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools
[巫师]: https://mitpress.mit.edu/sites/default/files/sicp/index.html

</aside>

当我终于开始攒我自己的小编译器时，我很快意识到，根本就没有什么魔法。它只是代码，而语言黑客也只是普通人。

有一些技巧 *是* 在编程语言之外不常遇到的，而有些部分有点困难。但不会比你所克服的其他障碍更难。我希望，如果你对编程语言感到畏惧，而这本书能帮助你克服这种恐惧，也许我会让您比以前更勇敢一丝。

而且，说不准，也许你 *将* 会创造出下一个伟大的语言，毕竟总得有人去做。

##  本书的组织结构

这本书分为三部分，您现在正在读的是第一部分。这部分用了几章来让您进入状态，教您一些语言黑客使用的行话，并向你介绍Lox，我们将要实现的语言。

其他两部分则分别构建两个完整的 Lox 解释器。在这些部分中，每章的结构都是相同的。 每一章节挑选一个语言功能点，教您背后对应的概念，并逐步介绍实现方法。

我花了不少时间去试错，但我还是成功地把这两个解释器按照章节分成了一些小块，每一小块的内容都会建立在前面几章的基础上，但不需要后续章节的知识。从第一章开始，你就会有一个可以运行和使用的工作程序。随着章节的推移，它的功能越来越丰富，直到你最终拥有一门完整的语言。

除了大量妙趣横生的英文段落，章节中还会包含一些其它的惊喜：

###  代码

本书是关于 *制作* 解释器的，所以本书包含了真正的代码。所需的每行代码都包括在内，而且每个代码片段都会告知您需要插入到实现代码中的 什么位置。

许多其他的语言书籍和语言实现都使用 [Lex][] 和 <span name="yacc">[Yacc][]</span> 这样的工具，即所谓的 **编译器的编译器** ，它们从一些更高层次的描述中自动生成一些用于实现的源文件。这些工具有利有弊，而且双方都有强烈的主张--有些人可能将其说成是信仰。

<aside name="yacc">

Yacc是一个工具，它接收一个语法文件并产生一个编译器的源文件，所以它有点像一个输出编译器的 "编译器"，这也是 "compiler-compiler"（编译器的编译器）一词的由来。

Yacc并不是第一个类似的工具，这就是为什么它被命名为 "Yacc"-- *Yet Another* Compiler-Compiler。后来的一个类似工具是 [Bison][] ，它的名字是对Yacc的发音的双关语，就像 "yak" （牦牛）。


<img src="image/introduction/yak.png" alt="A yak." />

[bison]: https://en.wikipedia.org/wiki/GNU_bison

如果你觉得所有这些小的自我介绍和双关语都很有趣，你会适合这里的。如果不是，那么，也许语言nerd的幽默感是一种后天的味道。

</aside>

我们不会在这里使用它们。我想确保魔法和困惑不会藏在黑暗的角落，所以我们将手写所有代码。正如您将看到的，这并没有听起来那么糟糕，这意味着您将真正理解每行代码，以及两个解释器是如何工作的。

[lex]: https://en.wikipedia.org/wiki/Lex_(software)
[yacc]: https://en.wikipedia.org/wiki/Yacc

书中代码和“真实世界”的代码是有区别的，因此这里的代码风格可能并不是可维护生产软件的最佳方式。如果我看起来有点轻率，例如，省略 `private` 或声明全局变量，敬请理解，这样做是为了让您更容易看懂代码。书页不像IDE窗口那么宽，所以每一个字符都很珍贵。

另外，代码也没有太多的注释。这是因为每一部分代码前后，都使用了一些简洁的文字来对其进行解释。当你写一本书来配合你的程序时，也欢迎你省略注释。否则，你也许应该比我多用些 `//`。

虽然书中包含了每一行代码，并讲授了每行代码的含义，但它并没有描述编译和运行解释器所需的机制。我假设你可以在IDE中编写一个makefile或新建一个项目，以便让代码运行。这类说明很快就会过时，我希望这本书像XO白兰地一样醇久，而不是非法酿造的劣酒那样容易变质。

### 代码片段

因为这本书包含了实现所需的每一行代码，所以这些代码片段非常精确。此外，即使是在缺少主要功能的时候，我也尝试将程序保持在可运行状态。因此我们有时会添加临时代码，这些代码将在以后的代码段中替换。

一个完整的代码片段看起来像这样:

<div class="codehilite"><pre class="insert-before">
      default:
</pre><div class="source-file"><em>lox/Scanner.java</em><br>
in <em>scanToken</em>()<br>
replace 1 line</div>
<pre class="insert">
        <span class="k">if</span> (<span class="i">isDigit</span>(<span class="i">c</span>)) {
          <span class="i">number</span>();
        } <span class="k">else</span> {
          <span class="t">Lox</span>.<span class="i">error</span>(<span class="i">line</span>, <span class="s">&quot;Unexpected character.&quot;</span>);
        }
</pre><pre class="insert-after">
        break;
</pre></div>
<div class="source-file-narrow"><em>lox/Scanner.java</em>, in <em>scanToken</em>(), replace 1 line</div>

中间是要添加的新代码。这部分代码的上面或下面可能有一些淡出的行，以显示它在周围代码中的位置。还会附有一小段介绍，告诉您在哪个文件中以及在哪里放置代码片段。如果提示说 "replace _ lines"（替换行），表明在浅色的行之间有一些现有的代码需要删除，并替换为新的代码片段。

### 旁注

<span name="joke">旁注</span>包括传记、历史背景、相关主题的参考资料，以及对其他领域的探索建议。为了理解本书后面的部分，你不需要知道这些内容，所以如果你想的话，可以跳过它们。我不会指责你，但我可能会有点难过。

<aside name="joke">

好吧，至少有些旁白是这样的。他们中的大多数只是愚蠢的笑话和业余的绘画。

</aside>

### 挑战

每章结尾都有一些练习。不像教科书中的习题集那样用于回顾已讲述的内容，这些习题是为了帮助您学习更多的知识，而不仅仅是本章中的内容。它们会迫使您走出文章指出的路线，自行探索。 它们将要求您研究其他语言，弄清楚如何实现功能，换句话说，就是使您走出舒适区。

<span name="warning">完成</span>挑战，您会接触到更广泛的知识，可能遇到一些挫折。如果你想呆在舒适的旅游巴士里，就跳过它们。这是你的自由。

<aside name="warning">

警告：这些挑战经常要求你对你正在构建的解释器进行修改。你应该在你的代码副本中实现这些改动。后面的章节假定你的解释器处于原始（"未进行挑战"）状态。

</aside>

###  设计须知

大多数“编程语言”书籍都是严格意义上的编程语言实现书籍。他们很少讨论如何设计正在实现的语言。实现之所以有趣，是因为它的定义<span name="benchmark">非常精确</span>。黑与白、1和0这些东西似乎对我们程序员有天生的吸引力。

<aside name="benchmark">

我认识很多语言黑客，他们的职业就是基于此。你把一个语言规范塞到他们的门口，等上几个月，代码和基准测试结果就出来了。

</aside>

我个人认为，世界只需要这么多 <span name="fortran">FORTRAN 77</span> 的实现。在某些时候，您会发现自己正在设计一种新的语言。一旦你开始玩这个游戏，那么软性的、人性化的一面就变得非常重要。比如哪些特性容易学习，如何平衡创新和熟悉感，哪些语法、对于哪些人更易读等。

<aside name="fortran">

希望你的新语言不会将关于打孔卡片宽度的假设硬编码到其语法中。

</aside>

所有这些东西都会深刻地影响到你的新语言的成功。我希望您的语言能够成功，所以在某些章节中，我以 "设计须知 "作为结尾，这是一篇关于编程语言在人文方面的某个角落的小文章。我不是这方面的专家ーー我不确定是否有人真的精通这些ーー因此，请您在阅读这些文字的时候持保留态度。这应该会让它们成为更美味的精神食粮，这是我的主要目标。

##  第一个解译器

我们将用<span name="lang">Java</span>编写我们的第一个解释器，jlox。这时的关注点是 *概念* 。我们将编写最简单、最干净的代码来正确实现该语言的语义。这样能够帮助我们熟悉基本技术，并磨练对语言表现形式的确切理解。


<aside name="lang">

本书使用Java和C语言，但读者已将代码移植到许多[其他语言][port]。如果我挑选的语言不是你的菜，可以看看那些语言实现。

[port]: https://github.com/munificent/craftinginterpreters/wiki/Lox-implementations

</aside>

Java是一门很适合这种场景的语言。它的级别足够高，我们不会被繁琐的实现细节所淹没，但代码仍然很清晰。与脚本语言不同，它的底层没有隐藏太过复杂的机制，而且您可以使用静态类型来查看正在使用的数据结构。

我选择 `Java` ，也是因为它是一种面向对象的语言。这种范式在90年代席卷了编程世界，现在已经成为数百万程序员的主流思维方式。很可能您已经习惯于将代码组织成类和方法，因此我们将继续在这个舒适区中学习。

虽然学术界的语言专家有时会看不起面向对象的语言，但现实中，它们被广泛用于语言工作。 GCC 和 LLVM 是用 C++ 编写的，大多数 JavaScript 虚拟机也是如此。面向对象语言无处不在，而且针对该语言的工具和编译器往往是用<span name="host">同一种语言</span>编写的。


<aside name="host">

编译器读取一种语言的文件，翻译它们，然后输出另一种语言的文件。你可以在任何语言中实现一个编译器，包括它所编译的同一种语言，这个过程称为 **自举**。

你的编译器还无法自己编译自己，但是如果你用其它语言为你的语言写了一个编译器，你就可以用那个编译器来编译一次你的编译器。然后你可以用自己编译器的编译版本来编译它的未来版本，从而丢弃从其他编译器编译的原始版本。这就是所谓的 "引导"（ **bootstrapping** ），通过自己的引导程序将自己拉起来。

<img src="image/introduction/bootstrap.png" alt="Fact: This is the primary mode of transportation of the American cowboy." />

</aside>

最后一点，Java 非常流行。这意味着你很有可能已经了解它了，所以你要学习的东西就更少了。 如果你对 Java 不是那么熟悉，也无需惊慌。 我尽量只使用它的最小子集。我使用了 Java 7中的钻石运算符，使事情变得更加简洁，但就 "高级"功能而言，也就这些了。如果你会另一种面向对象的语言，如C#或C++，就可以蒙混过关。

在第二部分结束时，我们会有一个简单、可读的实现。它不是非常快，但它是正确的。然而，它还是利用了Java虚拟机自身的运行时工具。我们要学习Java *本身* 如何实现这些东西。

##  第二个解译器

因此，在下一部分中，我们将重新开始，但这次是用C语言。C语言一直到内存中的字节和流经CPU的代码，是理解编译器如何 *真正* 工作的完美语言。

我们使用C语言的一个重要原因是，我可以向你展示C语言特别擅长的东西，但这 *确实* 意味着你需要对它非常熟悉。你不必成为丹尼斯-里奇的转世，但也不应被指针吓到。

如果你还没有达到这个水平，那就拿起一本关于C语言的入门书，仔细研读，读完后再回来。作为回报，你会通过这本书成为一个更强大的C语言程序员。想想有多少语言的实现是用C语言写的，举几个例子：Lua、CPython和Ruby's MRI等等。

在我们的C语言解释器<span name="clox">clox</span>中，我们不得不自己实现那些Java免费提供给我们的东西。 我们将编写自己的动态数组和哈希表。我们将决定对象在内存中的表示方式，并构建一个垃圾回收器来回收它。

<aside name="clox">

我把这个名字念成 "sea-locks"，但你也可以说成 "clocks"，甚至是 "cloch"，你可以像希腊人那样念 "x"，如果这让你高兴的话。

</aside>

我们的 Java 版实现专注于正确性。现在我们已经完成了这一点，我们将解决速度问题。我们的C语言解释器将包含一个<span name="compiler">编译器</span>，将Lox翻译成有效的字节码形式（别担心，我很快就会说到这是什么意思），然后执行。这与Lua、Python、Ruby、PHP和其他许多成功语言的实现所使用的技术相同。

<aside name="compiler">

你以为这只是一本解释器的书吗？它也是一本编译器书。一书两用!

</aside>

我们甚至会尝试进行基准测试和优化。最后，我们将为我们的语言提供一个健壮、准确、快速的解释器，能够跟上其他专业水平的实现。对于一本书和几千行代码来说还不错。

<div class="challenges">

## Challenges

1.  在我为编写和出版本书而拼凑的这个[小系统][repo] 中，至少使用了六种特定于领域的语言。他们是什么？

1.  用 Java实现一个“hello,world!” 程序。设置任何您需要的 makefile 或 IDE 项目来使其工作。如果您有一个调试器，请先熟悉一下，并在程序运行时逐步调试。

1.  使用 C 实现同样的事情。为了练习使用指针，定义一个堆分配的字符串的[双向链表][]。编写用于从中插入、查找和删除项的函数。测试他们。

[repo]: https://github.com/munificent/craftinginterpreters
[doubly linked list]: https://en.wikipedia.org/wiki/Doubly_linked_list

</div>

<div class="design-note">

##  设计须知: 名字里有什么？

写这本书最困难的挑战之一是为它所实现的语言取个名字。我翻了好几页备选名单才找到一个可用的。当你某一天开始构建自己的语言时，你就会发现起名有多难。一个好名字要满足几个标准：

1.  **未被使用** 如果你不小心踩到了别人的名字，你可能会遇到各种各样的麻烦，无论是法律上的还是社会上的。

2.  **容易发音** 如果一切顺利的话，很多人将会读和写你的语言名字。超过几个音节或几个字母的东西都会让他们烦恼不已。

3.  **足够独特,方便搜索** 人们会用谷歌搜索你的语言名称来了解它，所以你需要一个足够罕见的单词，以便大多数搜索结果都指向你的文档。不过，随着今天人工智能搜索引擎的大量涌现，这个问题就不那么严重了。尽管如此，如果您将语言命名为“ for”，那么对您的用户没有任何好处。

4.  **它在很多文化中都没有负面的含义。** 这很难防范，但值得考虑。Nimrod 的设计者最终将他的语言重新命名为Nim，因为太多的人记得兔八哥用“Nimrod”作为一种[侮辱](https://www.dictionary.com/browse/nimrod)。

如果你的候选名能通过这一关，那就保留它。不要执着于找到一个能抓住你的语言精髓的称呼。如果世界上其他成功的语言的名称教会了我们什么的话，那就是名字并不重要。你所需要的只是一个相当独特的标记。

</div>
