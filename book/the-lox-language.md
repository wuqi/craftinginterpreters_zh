> 除了给别人做早餐，你还能为他们做什么更好的事情呢?
>
> <cite>Anthony Bourdain</cite>

我们将用本书的其余部分来阐明Lox语言的每一个黑暗和杂乱的角落，但让你立即开始为解释器编写代码，而不至少看一看我们最终会得到什么，这似乎很残酷。

同时，我也不想在你接触文本<span name="home">编辑器</span>之前，就把你拖入成堆的语言律条和规范术语中。因此，这将是对Lox的一个温和、友好的介绍。它将撇开很多细节和边缘案例。我们以后有足够的时间来了解这些。

<aside name="home">

如果你不能亲自尝试代码，那么教程就没有什么意思了。唉，你还没有一个Lox解释器，因为你还没有建立一个Lox解释器!

别担心。你可以使用[我的库][repo]

[repo]: https://github.com/munificent/craftinginterpreters

</aside>

## 你好，Lox

这是你第一次尝到<span name="salmon">Lox</span>的滋味 :

<aside name="salmon">

你第一次品尝Lox，语言，就是这样。我不知道你以前是否吃过这种腌制、冷熏的三文鱼。如果没有，也请你试一试。

</aside>

```lox
// Your first Lox program!
print "Hello, world!";
```

正如那个 `//` 行注释和尾部的分号所暗示的，Lox的语法是C家族的一员。(字符串周围没有括号，因为 `print` 是一个内置语句，而不是一个库函数)。

现在，我不会声称<span name="c">C</span>语言有一个伟大的语法。如果我们想要优雅的东西，我们可能会模仿Pascal或Smalltalk。如果我们想完全采用北欧极简装修风格的话，我们会采用Scheme。他们各有优劣。

<aside name="c">

我肯定有偏见，但我认为Lox的语法是相当干净的。C语言最令人震惊的语法问题是围绕着类型。Dennis Ritchie有一个叫做 [declaration reflects use][use] 的想法，在这里，变量的声明反映了你必须对变量进行的操作，以获得一个基本类型的值。这个想法很聪明，但我认为它在实践中的效果并不好。

[use]: http://softwareengineering.stackexchange.com/questions/117024/why-was-the-c-syntax-for-arrays-pointers-and-functions-designed-this-way

Lox没有静态类型，所以我们避免了这一点。

</aside>

类似C语言的语法所具有的反而是你经常会发现在一种语言中更有价值的东西：熟悉性。我知道你对这种风格已经很熟悉了，因为我们用来实现Lox的两种语言--Java和C--也都继承了这种风格。在Lox中使用类似的语法，可以让你少学一点东西。

## 高级语言

虽然这本书最终比我希望的要厚，但它仍然不够厚，不能把像Java这样庞大的语言装进去。为了在这几页中容纳两个完整的Lox的实现，Lox本身必须相当紧凑。

当我想到那些小而有用的语言时，我想到的是高级 "脚本 "语言，如<span name="js">JavaScript</span> 、Scheme和Lua。在这三种语言中，Lox看起来最像JavaScript，主要是因为大多数C-语法语言都是如此。稍后我们将了解到，Lox的范围界定方法与Scheme非常接近。我们将在[Part III][]建立的Lox的C语言实现，在很大程度上得益于Lua的简洁、高效的实现。

[part iii]: a-bytecode-virtual-machine.html

<aside name="js">

现在，JavaScript已经占领了世界，并被用来建立巨大的应用程序，很难再把它看作是一种 "小脚本语言"。但是Brendan Eich在十天内将第一个JS解释器黑进了Netscape Navigator，使网页上的按钮变成了动画。从那时起，JavaScript已经长大了，但它曾经是一种可爱的小语言。

因为Eich用与一季《百战天龙》大致相同的原材料和时间将JS拼凑在一起，所以它有一些奇怪的语义角落，在那里，胶带和回形针会露出来。像变量提升、动态绑定 `this` 、数组中的漏洞和隐式转换。

我在Lox上花了不少时间，所以它应该更干净一些。

</aside>

Lox与这三种语言还有两个共同点:

### 动态类型

Lox是动态类型语言。变量可以存储任何类型的值，单个变量甚至可以在不同时间存储不同类型的值。如果你试图对错误类型的值进行操作--例如，用一个数字除以一个字符串--那么这个错误会在运行时才被检测到并报告。

<span name="static">静态</span>类型有很多优点，但它们没有一个比实用性更重要。静态类型系统需要大量工作去学习和实现。跳过它，你会得到一个更简单的语言和一本更薄的书。如果我们把类型检查推迟到运行时，我们就能更快地启动解释器并执行一些代码。

<aside name="static">

毕竟，我们将用来实现Lox的两种语言都是静态类型的。

</aside>

### 自动内存管理

高级语言的存在是为了消除容易出错的、低层次的繁琐工作，还有什么比手动管理存储的分配和释放更繁琐的呢？没有人在起床后迎接早晨的太阳，"我迫不及待地想知道我今天分配的每一个字节的内存的正确位置，以调用 `free()` ！"

有两种管理内存的主要<span name="gc">技术</span>：**引用计数** 和 **追踪式垃圾回收** （通常只称为 **垃圾回收** 或 **GC** ）。引用计数的实现要简单得多，我想这就是为什么Perl、PHP和Python一开始都使用它们。但是，随着时间的推移，参考计数的限制变得太麻烦了。所有这些语言最终都增加了一个完整的追踪式GC，或者至少是足以清理对象周期的GC。

<aside name="gc">

在实践中，参考计数和GC更像是一个连续体的两端，而不是对立面。大多数参考计数系统最终都会做一些跟踪来处理循环，如果你仔细看的话，生成GC的写障碍看起来有点像保留调用。

关于这个问题的更多信息，请参考 "[A Unified Theory of Garbage Collection][gc]"（PDF）。

[gc]: https://researcher.watson.ibm.com/researcher/files/us-bacon/Bacon04Unified.pdf

</aside>

追踪式垃圾回收有一个可怕的名声。在原始内存的层面上工作有点令人痛苦。调试GC有时会让你在梦中看到十六进制转储。但是，请记住，这本书是关于消除魔法和杀死那些怪物的，所以我们要编写自己的垃圾回收器。我想你会发现这个算法很简单，实现起来很有趣。

## 数据类型

在Lox的小宇宙中，构成所有物质的原子都是内置的数据类型。只有几个:

*   **<span name="bool">布尔值</span>.** 没有逻辑就没有代码，没有布尔值就没有逻辑。"真 "和 "假"，是软件的阴和阳。不像一些古老的语言，重新利用现有的类型来表示真和假，Lox有一个专门的布尔类型。我们在这次探险中可能是粗暴的，但我们不是野蛮人。

    <aside name="bool">

    Boolean变量是Lox中唯一以乔治·布尔命名的数据类型，这就是为什么“Boolean”是大写的。他于1864年去世，比数字计算机将他的代数转化为电学早了近一个世纪。我想知道他看到自己的名字出现在数十亿行Java代码中会怎么想。 

    </aside>

    显然，下面有两个字面布尔值。

    ```lox
    true;  // Not false.
    false; // Not *not* false.
    ```

*   **Numbers.** Lox只有一种数字：双精度浮点。由于浮点数也可以代表广泛的整数，这涵盖了很多领域，同时保持了简单。

    功能齐全的语言有很多数字的语法--十六进制、科学符号、八进制，各种有趣的东西。我们将满足于基本的整数和小数字。

    ```lox
    1234;  // An integer.
    12.34; // A decimal number.
    ```

*   **Strings.** 我们已经在第一个例子中看到了一个字符串字面。像大多数语言一样，它们被括在双引号中。

    ```lox
    "I am a string";
    "";    // The empty string.
    "123"; // This is a string, not a number.
    ```

    当我们开始实现它们时，我们会看到，在这一连串无害的<span     name="char">字符</span>中隐藏着相当多的复杂性。

    <aside name="char">

    即使是 "character "这个词，也是一个骗局。它是 ASCII 的? Unicode ？一个码位还是一个 "字形簇"？字符是如何编码的？每个字符的大小是固定的，还是可以变化的？

    </aside>

*   **Nil.** 有一个最后的内在价值，他从未被邀请参加聚会，但似乎总是出现在这里。它代表 "无效值"。它在许多其他语言中被称为 "null"。在Lox中，我们把它拼成  `nil` 。(当我们实现它时，这将有助于区分我们在谈论Lox的  `nil` 和Java或C中的  `null` )。

    在语言中不使用空值有很好的论据，因为空指针错误是我们行业的祸害。如果我们做的是静态类型的语言，那就值得尝试禁止它。但在动态类型的语言中，消除它往往比拥有它更令人讨厌。

## 表达式

如果内置数据类型及其文字是原子，那么 **expressions** 必须是分子。其中大多数都很面熟。

### 算术运算符

Lox具有你在C语言和其他语言中熟悉和喜爱的基本算术运算符：

```lox
add + me;
subtract - me;
multiply * me;
divide / me;
```

操作符两边的子表达式是操作数。因为它们有两个，所以被称为二元运算符（ **binary** operators）。(这与 "**binary** "的1和0的用法无关。)因为运算符<span name="fixity">固定</span>在操作数的中间，所以这些运算符也称为 **中缀** 运算符(与运算符位于操作数之前的 **前缀** 运算符和运算符位于操作数之后的 **后缀** 运算符相反)。

<aside name="fixity">

有一些运算符有两个以上的操作数，运算符之间是交错的。唯一被广泛使用的是C的 "条件 "或 "三元 "运算符。

```c
condition ? thenArm : elseArm;
```

有些人称这些为混合运算符。有一些语言允许你定义自己的运算符，并控制它们的位置--它们的 "固定性"。

</aside>

一个算术运算符实际上既是中缀又是前缀。运算符也可用于对数字求反。

```lox
-negateMe;
```

所有这些操作符都处理数字，向它们传递任何其他类型都是错误的。例外是 `+` 运算符，您也可以向它传递两个字符串来连接它们。

### 比较运算符

继续前进，我们还有一些总是返回布尔结果的运算符。我们可以使用古老的比较运算符来比较数字（而且只是数字）。

```lox
less < than;
lessThan <= orEqual;
greater > than;
greaterThan >= orEqual;
```

我们可以测试两个任何类型的值是否相等或不相等。

```lox
1 == 2;         // false.
"cat" != "dog"; // true.
```

甚至不同类型。

```lox
314 == "pi"; // false.
```

不同类型的值 *永远* 不相等。

```lox
123 == "123"; // false.
```

我通常反对隐式转换。

### 逻辑运算符

not操作符是前缀操作符 `！`，如果其操作数为真，则返回假，反之亦然。

```lox
!true;  // false.
!false; // true.
```

另外两个逻辑运算符实际上是以表达式为幌子的控制流结构。<span name="and">`and`</span> 表达式决定了两个值是否都是真的。如果是假的，它就返回左边的操作数，否则就返回右边的操作数。

```lox
true and false; // false.
true and true;  // true.
```

 `or` 表达式决定两个值中的任何一个（或两个）是否为真。如果是真的，它返回左边的操作数，否则返回右边的操作数。

```lox
false or false; // false.
true or false;  // true.
```

<aside name="and">

我用 `and` 和 `or` 来代替 `&&` 和 `||` ，因为Lox不使用 `&` 和 `|` 来表示位操作符。在没有单字符的情况下介绍双字符形式感觉很奇怪。

我也喜欢用字来表示这些，因为它们是真正的控制流结构，而不是简单的运算符。

</aside>

`and` 和 `or` 像控制流结构一样的原因是它们是 **短路** 的。如果左边的操作数是假的， `and` 不仅会返回，而且在这种情况下它甚至不会运算右边的操作数。类似的，如果 `or` 的左边操作数为真，右边操作数就会被跳过。

### 优先级和分组

所有这些操作符都有相同的优先级和结合律，你可以从c语言中得到。(当我们开始解析时，我们会得到更精确的结果。)如果优先级不是您想要的，您可以使用 `()` 对内容进行分组。

```lox
var average = (min + max) / 2;
```

由于它们在技术上不是很有趣，我已经从我们的小语言中删掉了剩下的典型操作符。没有按位、移位、模或条件运算符。我不是在给你打分，但如果你用它们来增强自己的Lox实现，你会在我心中得到加分。

这些是表达形式（除了与我们稍后将讨论的特定功能相关的一些），所以让我们向上移动一个级别。

## Statements

现在我们来看看语句。表达式的主要工作是产生一个值，而语句的工作是产生一个效果。因为根据定义，语句的计算结果不是一个值，为了有用，它们必须以某种方式改变世界--通常是修改一些状态，读取输入，或产生输出。

你已经看到了几种类型的语句。第一种是:

```lox
print "Hello, world!";
```

 <span name="print">`print` statement</span> 语句计算单个表达式，并向用户显示结果。您还看到了一些语句，如:

<aside name="print">

在语言中加入 `print` ，而不是将其作为核心库函数，是一种黑客行为。但它对我们来说是一个 *有用* 的技巧：它意味着我们正在进行的解释器可以在我们实现所有定义函数、按名称查找和调用它们所需的机器之前就开始产生输出。

</aside>

```lox
"some expression";
```

后跟分号(`;`) 将表达式提升为语句。这被称为(足够想象)，一个 **表达声明** 。

如果你想把一系列的语句打包在一个单独的语句中，你可以把它们打包在一个 **块** 中。

```lox
{
  print "One statement.";
  print "Two statements.";
}
```

块也会影响作用域，这将引导我们进入下一节...

## 变量

使用 `var` 语句声明变量。如果 <span name="omit">省略</span> 初始化器，变量值默认为 `nil` 。

<aside name="omit">

在这种情况下，不使用“nil”并强制将每个变量初始化为某个值将比使用“nill”本身更令人讨厌。

</aside>

```lox
var imAVariable = "here is my value";
var iAmNil;
```

一旦声明了，你就可以很自然地使用它的名字来访问和赋值一个变量。

<span name="breakfast"></span>

```lox
var breakfast = "bagels";
print breakfast; // "bagels".
breakfast = "beignets";
print breakfast; // "beignets".
```

<aside name="breakfast">

你能看出我倾向于在早上吃东西之前就开始写这本书吗？

</aside>

我不会在这里讨论变量作用域的规则，因为在后面的章节中，我们将会花费大量的时间来描述每一个规则。在大多数情况下，它的工作方式就像你从C或Java中所期望的那样。

## 控制流

如果不能跳过一些代码或者多次执行一些代码，就很难写出<span name="flow">有用的</span>程序。这意味着控制流程。除了我们已经讨论过的逻辑操作符，Lox直接从c语言中提取了三个语句。

<aside name="flow">

我们已经有了用于分支的 `and` 和 `or` ，而且我们可以使用递归来重复代码，所以理论上这就足够了。不过，在一种命令式语言中这样编程会很尴尬的。

另一方面，Scheme没有内置的循环结构。它确实依靠递归来实现重复。Smalltalk没有内置的分支结构，而是依靠动态调度来选择性地执行代码。

</aside>

 `if` 语句根据某种条件执行两条语句中的一条。

```lox
if (condition) {
  print "yes";
} else {
  print "no";
}
```

只要条件表达式的计算结果为true，`while` <span name="do">循环</span> 就会重复执行主体。

```lox
var a = 1;
while (a < 10) {
  print a;
  a = a + 1;
}
```

<aside name="do">

我没有在Lox中实现 `do while` 循环，因为它们并不常见，而且不会教你任何你从  `while` 中学不到的东西。如果你高兴的话，可以把它添加到你的实现中去。这是你的party。

</aside>

最后，我们有 `for` 循环。

```lox
for (var a = 1; a < 10; a = a + 1) {
  print a;
}
```

这个循环与前一个 `while` 循环做相同的事情。大多数现代语言还具有某种<span name="foreach">`for-in`</span> 或 `foreach` 循环，用于显式迭代各种序列类型。在真实的语言中，这比我们在这里得到的粗糙的 C 风格 `for` 循环要好。Lox只保留最基础的实现。

<aside name="foreach">

这是我做出的一个让步，因为实现方式是跨章节的。一个 `for-in` 循环需要迭代器协议中的某种动态调度来处理不同种类的序列，但我们在完成控制流之后才会得到这个。我们可以回过头来，在后面添加 `for-in` 循环，但我认为这样做不会让你学到什么超级有趣的东西。

</aside>

## 函数

函数调用表达式看起来和c语言中的一样。

```lox
makeBreakfast(bacon, eggs, toast);
```

你也可以调用一个函数而不传递任何东西给它。

```lox
makeBreakfast();
```

与Ruby不同，在这种情况下，括号是必需的。如果不使用它们，名称不会 *调用* 函数，它只是引用它。

如果你不能定义你自己的函数，那么一种语言就算不上有趣。在Lox中，你可以用 <span name="fun">`fun`</span>关键字实现。

A language isn't very fun if you can't define your own functions. In Lox, you do
that with <span name="fun">`fun`</span>.

<aside name="fun">

我见过其他语言有使用 `fn`, `fun`, `func`, 和 `function` 做关键字的. 我还是希望能在某个地方找到 `funct`, `functi`, 或者 `functio` 做为函数的关键字. 

</aside>

```lox
fun printSum(a, b) {
  print a + b;
}
```

现在是澄清一些<span name="define">术语</span>的好时机。有些人认为 `parameter` 和 `argument` 是可以互换的，对许多人来说，它们是可以互换的。我们将花很多时间来剖析语义，所以让我们用词更尖锐。从现在开始: 

*   **argument** 是调用函数时传递给函数的实际值。所以函数调用有一个实参列表( `argument list` )。有时称之为实参 **actual parameter** 。

*    `Parameter` 是一个变量，它在函数体中保存参数的值。因此，函数声明有一个形参列表( `parameter list` )。被称之为形参  **formal parameters** ,或者 **formals** 。

<aside name="define">

说到术语，一些静态类型的语言，如C语言，对声明函数和定义函数进行了区分。声明将函数的类型与它的名字绑定在一起，这样可以对调用进行类型检查，但不提供主体。定义声明了函数，同时也填写了主体，这样函数就可以被编译了。

由于Lox是动态类型的，这种区别没有意义。一个函数声明完全指定了函数，包括它的主体。

</aside>

函数体总是一个块。在其中，您可以使用 `return` 语句返回值。

```lox
fun returnSum(a, b) {
  return a + b;
}
```

如果执行到了块的末尾而没有 `return` ，则<span name="sneaky">隐式</span>返回nil。

<aside name="sneaky">

原注: 你看，我告诉过你 `nil` 会在我们不注意的时候潜入。

</aside>

### 闭包

函数是Lox中的 *头等舱* ，这意味着它们是实值，你可以引用，存储在变量中，传递等等。这是可行的:

```lox
fun addPair(a, b) {
  return a + b;
}

fun identity(a) {
  return a;
}

print identity(addPair)(1, 2); // Prints "3".
```

因为函数声明是语句，所以可以在另一个函数中声明局部函数。

```lox
fun outerFunction() {
  fun localFunction() {
    print "I'm local!";
  }

  localFunction();
}
```

如果将局部函数、一级函数和块范围结合起来，就会遇到这种有趣的情况:

```lox
fun returnFunction() {
  var outside = "outside";

  fun inner() {
    print outside;
  }

  return inner;
}

var fn = returnFunction();
fn();
```

这里，`inner()` 访问一个在它的主体之外的周围函数中声明的局部变量。这样做合适吗？既然许多语言都借鉴了Lisp的这一特性，您可能知道答案是肯定的。

要做到这一点，`inner()` 必须“保持”对它所使用的任何周围变量的引用，这样，即使在外部函数返回之后，它们也不会丢失。我们称这样做的函数为<span
name="closure">**closures** 闭包</span>。这些天，这个术语经常被用于任何一级函数，尽管如果函数不发生在任何变量上，这有点用词不当。

<aside name="closure">

Peter J. Landin 创造了 "闭合 "这个术语。是的，他发明了编程语言中几乎一半的术语。他们中的大多数都来自一篇令人难以置信的论文："[The Next 700 Programming Languages][svh]"

[svh]: https://homepages.inf.ed.ac.uk/wadler/papers/papers-we-love/landin-next-700.pdf

为了实现这类函数，你需要创建一个数据结构，将函数的代码和它所需要的周围变量捆绑在一起。他把这称为 "闭包"，因为它关闭了它所需要的变量，并保持着这些变量。

</aside>

可以想象，实现这些会增加一些复杂性，因为我们不能再假设变量作用域严格地像堆栈一样工作，在堆栈中，局部变量在函数返回时就消失了。我们将度过一段愉快的时光，学习如何正确有效地使用这些工具。

## 类

由于Lox具有动态类型、词法(粗略地说是“块”)范围和闭包，它离成为函数式语言还有一段距离。但是正如您将看到的，它也是面向对象语言的一半。这两种范式都有很多优点，所以我认为有必要分别介绍一下。 

既然类因为没有达到他们的宣传而受到攻击，让我首先解释为什么我把它们放到Lox和这本书里。实际上有两个问题:

### 为什么任何语言都想成为面向对象的？

现在像Java这样的面向对象语言已经售罄，只在舞台上表演，再喜欢它们也不酷了。为什么会有人用物体创造一种新的语言？这不就像在8轨上发布音乐吗？

诚然，90年代的“始终继承”热潮产生了一些可怕的类层次结构，但 **面向对象编程** （ **OOP** ）仍然相当疯狂。已经用OOP语言编写了数十亿行成功的代码，为快乐的用户提供了数百万个应用程序。可能今天大多数在职程序员都在使用面向对象语言。他们不可能都错了。

特别是，对于动态类型语言，对象非常方便。我们需要一些定义复合数据类型的方法来将数据块捆绑在一起。

如果我们还可以挂起这些方法，那么我们就不需要在所有函数前面加上它们所操作的数据类型的名称，以避免与不同类型的类似函数发生冲突。例如，在Racket中，您必须将函数命名为 `hash-copy` 用于复制哈希表）和 `vector-copy` （用来复制向量），这样它们就不会相互影响。方法的作用域是对象，这样问题就解决了。

### Lox为什么是面向对象的？ 

我可以说是因为对象很棒，但这仍然超出了本书的范围。大多数编程语言书籍，尤其是那些试图实现整个语言的书籍，都忽略了对象。对我来说，这意味着这个主题没有被很好地覆盖。对于这样一个广泛存在的范例，这种遗漏让我很难过。 

鉴于我们中有多少人整天都在使用OOP语言，看起来这个世界需要一些文档来说明如何制作一个。正如你将看到的，这是非常有趣的。没有你担心的那么难，但也没有你想象的那么简单。

### Classes 或 prototypes

谈到对象，实际上有两种方法，[classes][]和[prototypes][]。Classes最先出现，并且由于C++、Java、C#和朋友们的出现而变得更加普遍。Prototypes是一个几乎被遗忘的分支，直到JavaScript意外地占领了世界。

[classes]: https://en.wikipedia.org/wiki/Class-based_programming
[prototypes]: https://en.wikipedia.org/wiki/Prototype-based_programming

在基于类的语言中，有两个核心概念：实例(instances)和类(classes)。实例存储每个对象的状态，并有一个对实例的类的引用。类包含方法和继承链。要在一个实例上调用一个方法，总是有一个层次的间接性。你要<span
name="dispatch">查找</span>实例的类，然后在那里找到该方法。

<aside name="dispatch">

在像 `C++` 这样的静态类型语言中，方法查找通常发生在编译时，基于实例的静态类型，为您提供静态调度。相反，**动态调度** 在运行时查找实际实例对象的类。这就是静态类型语言中的虚方法和动态类型语言(如Lox)中的所有方法的工作方式。

</aside>

<img src="image/the-lox-language/class-lookup.png" alt="How fields and methods are looked up on classes and instances" />

基于原型的语言<span name="blurry">融合</span>了这两个概念。只有对象，没有类，每个单独的对象可能包含状态和方法。对象可以直接相互继承(或者在原型行话中“委托给”):

<aside name="blurry">

实际上，基于类的语言和基于原型的语言之间的界限很模糊。JavaScript的“构造函数”概念让你很难定义类对象 [很难定义类对象][js new]。同时，基于类的Ruby非常乐意让您将方法附加到单个实例上。

[js new]: http://gameprogrammingpatterns.com/prototype.html#what-about-javascript

</aside>

<img src="image/the-lox-language/prototype-lookup.png" alt="How fields and methods are looked up in a prototypal system" />

这意味着在某些方面，原型语言比类更基本。它们很容易实现，因为它们是如此简单。而且，它们可以表达很多不寻常的模式，而类会引导你远离这些模式。

但是我看过很多用原型语言写的代码——包括一些我自己设计的 [some of my own devising][finch]。你知道人们通常会用原型语言的所有功能和灵活性来做什么吗？ . . 他们用它们来重新创造类。

[finch]: http://finch.stuffwithstuff.com/

我不知道这是为什么，但人们似乎自然而然地喜欢基于类（Classic？ Classy？原型在语言上更简单，但它们似乎只是通过把复杂性<span name="waterbed">推给</span>用户来实现的。所以，对于Lox来说，我们要为用户省去麻烦，把类直接烘烤进去。

<aside name="waterbed">

Larry Wall ，Perl的发明者/预言家，把这称为 "[waterbed theory][]"。一些复杂性是必不可少的，不能被消除。如果你把它压在一个地方，它就会在另一个地方膨胀起来。

[waterbed theory]: http://wiki.c2.com/?WaterbedTheory

原型语言与其说是 *消除* 了类的复杂性，不如说是让用户通过建立他们自己的类的元编程库来承担这种复杂性。

</aside>

### Lox中的类

现在有足够的理由，让我们看看我们实际拥有的东西。在大多数语言中，类包含了一系列的特征。对于Lox，我选择了我认为最亮的星。你可以像这样声明一个类和它的方法:

```lox
class Breakfast {
  cook() {
    print "Eggs a-fryin'!";
  }

  serve(who) {
    print "Enjoy your breakfast, " + who + ".";
  }
}
```

类的主体包含它的方法。它们看起来像函数声明，但是没有 `fun` <span name="method">关键字</span>。当执行类声明时，Lox创建一个类对象，并将其存储在一个以类命名的变量中。就像函数一样，类是Lox中的头等舱。

<aside name="method">

但是踏马还是跟fun类似。

</aside>

```lox
// Store it in variables.
var someVariable = Breakfast;

// Pass it to functions.
someFunction(Breakfast);
```

接下来，我们需要一种创建实例的方法。我们可以添加一些 `new` 关键字，但是为了简单起见，在Lox中，类本身是一个工厂函数。像调用函数一样调用一个类，它会产生自己的一个新实例。


```lox
var breakfast = Breakfast();
print breakfast; // "Breakfast instance".
```

### 实例化和初始化

只有行为的类不是非常有用。面向对象编程背后的思想是将行为和状态封装在一起。为此，需要字段。Lox和其他动态类型语言一样，允许您在对象上自由添加属性。

```lox
breakfast.meat = "sausage";
breakfast.bread = "sourdough";
```

如果某个字段尚不存在，则赋值时就会创建该字段。

如果你想从一个方法中访问当前对象上的一个字段或方法，你可以使用古老的 `this`。

```lox
class Breakfast {
  serve(who) {
    print "Enjoy your " + this.meat + " and " +
        this.bread + ", " + who + ".";
  }

  // ...
}
```

在对象中封装数据的一部分是确保对象在创建时处于有效状态。为此，你可以定义一个构造函数。如果您的类有一个名为 `init()` 的方法，则在构造对象时会自动调用该方法。传递给该类的任何参数都被转发给它的构造函数。

```lox
class Breakfast {
  init(meat, bread) {
    this.meat = meat;
    this.bread = bread;
  }

  // ...
}

var baconAndToast = Breakfast("bacon", "toast");
baconAndToast.serve("Dear Reader");
// "Enjoy your bacon and toast, Dear Reader."
```

### 继承

每一种面向对象的语言不仅允许你定义方法，还允许你在多个类或对象中重用它们。为此，Lox支持单一继承。当声明一个类时，可以使用小于<span name="less">(`<`)</span>运算符指定它继承的类。

```lox
class Brunch < Breakfast {
  drink() {
    print "How about a Bloody Mary?";
  }
}
```

<aside name="less">

为什么是 `<` 运算符？我不想引入像 `extends` 这样的新关键字。Lox不使用 `:` ,所以我也不想保留它。相反，我借鉴了Ruby的做法，用 `<` 。

如果你了解任何类型理论，你会注意到这不是一个完全任意的选择。子类的每个实例也是其超类的实例，但是超类的实例可能不是子类的实例。这意味着，在对象的世界中，子类对象的集合小于超类对象的集合，尽管类型爱好者通常使用  `<:` 。

</aside>

在这里，早午餐是 **派生类** 或 **子类** ，早餐是 **基类** 或 **超类** 。

超类中定义的每个方法也可用于它的子类。

```lox
var benedict = Brunch("ham", "English muffin");
benedict.serve("Noble Reader");
```

甚至 `init()` 方法也被继承了。在实践中，子类通常也想定义自己的 `init()` 方法。但是原来的那个方法也需要被调用，这样超类就可以保持它的状态。我们需要一些方法来调用我们自己实例上的方法，而又不影响我们自己的方法。

<aside name="init">

Lox不同于C++、Java和C#，它们不继承构造函数，类似于Smalltalk和Ruby，它们继承构造函数。

</aside>

就像在Java中一样，你可以用 `super` 来实现。

```lox
class Brunch < Breakfast {
  init(meat, bread, drink) {
    super.init(meat, bread);
    this.drink = drink;
  }
}
```

这就是对象定位的情况。我试图保持最小的特征集。本书的结构确实迫使我们做出一个妥协。Lox不是一种纯粹的面向对象的语言。在真正的OOP语言中，每个对象都是一个类的实例，即使是数字和布尔这样的原始值。

因为我们在开始使用内置类型后才实现类，这将是很难的。所以原始类型的值并不是真正意义上的类的实例的对象。它们没有方法或属性。如果我想让Lox成为真正的用户的真正的语言，我就会解决这个问题。

## 标准库

我们几乎已经完成了。这就是整个语言，所以剩下的就是 "核心 "或 "标准 "库--直接在解释器中实现的一组功能，所有用户定义的行为都建立在这个基础之上。

这是Lox最悲哀的地方。它的标准库超越了极简主义，接近于彻底的虚无主义。对于书中的示例代码，我们只需要证明代码正在运行并做它应该做的事情。为此，我们已经有了内置的 `print` 语句。

以后，当我们开始优化时，我们将写一些基准，看看执行代码需要多长时间。这意味着我们需要跟踪时间，所以我们将定义一个内置函数 `clock()` ，返回程序开始后的秒数。

然后......就是这样。我知道，对吗？这很令人尴尬。

如果你想把Lox变成一种真正有用的语言，你应该做的第一件事就是充实这个。字符串操作、三角函数、文件输入/输出、网络，甚至是读取用户的输入都会有帮助。但是我们在这本书中不需要这些东西，而且添加这些东西也不会教你任何有趣的东西，所以我把它排除在外。

别担心，在语言本身中，我们会有很多令人兴奋的东西让我们忙碌。

<div class="challenges">

## 挑战

1. 编写一些Lox程序样本并运行它们（你可以使用[my repository][repo]中的Lox的实现）。试着想出我在这里没有说明的边缘案例行为。它能做到你所期望的吗？为什么或为什么不呢？

2. 这个非正式的介绍留下了 *很多* 未说明的东西。列出你对该语言的语法和语义的几个开放问题。你认为答案应该是什么？

3. Lox是一种相当小的语言。你认为它缺少哪些功能，会使它在真正的程序中使用起来很烦人？(当然，除了标准库之外）。

</div>

<div class="design-note">

## 设计须知:表达式和语句

Lox既有表达式也有语句。有些语言省略了后者。相反，它们也将声明和控制流构造视为表达式。这些“一切都是表达式”语言往往具有功能谱系，包括大多数Lisp、SML、Haskell、Ruby和CoffeeScript。

为此，对于语言中的每个“类似语句”的构造，您需要确定其计算值。其中一些很简单

*   `if` 表达式的计算结果是所选分支的结果。同样，`switch` 或其他多路分支的计算结果取决于选择的任何一种情况。

*   变量声明的计算结果为变量的值。

*   块计算结果为序列中最后一个表达式的结果。

有些变得有点陌生。循环的计算结果应该是什么？CoffeeScript中的 `while` 循环计算包含主体计算的每个元素的数组。这可能很方便，或者如果不需要数组的话会浪费内存。

您还必须决定这些类似语句的表达式如何与其他表达式组合，您必须将它们放入语法的优先表中。例如，Ruby允许：

```ruby
puts 1 + if true then 2 else 3 end + 4
```

这是你所期望的吗？这是你的用户所期望的吗？这对你设计 "语句 "的语法有什么影响？请注意，Ruby有一个明确的 `end` 来告诉 `if` 表达式何时完成。如果没有它， `+ 4` 可能会被解析为 `else` 子句的一部分。

把每个语句变成一个表达式，迫使你回答一些像这样的毛糙的问题。作为回报，你消除了一些多余的东西。C语言既有用于排列语句顺序的块，也有用于排列表达式顺序的逗号运算符。它既有 `if` 语句，也有 `?:` 条件运算符。如果在C语言中所有的东西都是表达式，你就可以把这些东西都统一起来。

摒弃了语句的语言通常还具有 **隐式返回** 的特点--函数会自动返回其主体所评估的任何值，而不需要一些明确的 `return` 语法。对于小型函数和方法来说，这真的很方便。事实上，许多有语句的语言都增加了像 `=>` 这样的语法，以便能够定义函数体是对单个表达式求值的结果。

但是让 *所有* 的函数以这种方式工作可能有点奇怪。如果你不小心，你的函数会泄露一个返回值，即使你只是想让它产生点副作用。不过在实践中，这些语言的用户并没有发现这是个问题。

对于Lox来说，我给它声明是出于普通的原因。我选择了一种类似于C语言的语法是为了熟悉，如果想把现有的C语言的语句语法解释成表达式，会变得很奇怪。

对于Lox，我给出了一些平淡无奇的理由。为了熟悉起见，我选择了一种类似C的语法，如果想把现有的C语言的语句语法解释成表达式，很快就会变得很奇怪。

</div>
