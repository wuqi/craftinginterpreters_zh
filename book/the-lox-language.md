> 还有什么能比给别人做顿早餐，更能体现你对他的照顾呢？
>
> <cite>Anthony Bourdain</cite>

我们将用本书的其余部分来照亮Lox语言的每一个黑暗和杂乱的角落，不过如果让你在对目标一无所知的情况下，就立即开始为解释器编写代码，也太残忍了。

同时，我也不想在你接触文本<span name="home">编辑器</span>之前，就把你拖入成堆的语言律条和规范术语中。因此，这将是这是一个温和、友好的Lox介绍。它将省略很多细节和边缘情况。后面我们有足够的时间来解决这些问题。

<aside name="home">

如果你不能亲自尝试代码，那么本教程就没有什么意思了。唉，你还没有一个Lox解释器，因为你还没有建立一个Lox解释器!

别担心。你可以使用[我的库][repo]

[repo]: https://github.com/munificent/craftinginterpreters

</aside>

## 你好，Lox

这是你第一次尝到<span name="salmon">Lox</span>的滋味 :

<aside name="salmon">

你第一次品尝Lox，语言，就是这样。我不知道你以前是否吃过这种腌制、冷熏的三文鱼。如果没有，也请你试一试。

</aside>

```lox
// Your first Lox program!
print "Hello, world!";
```

正如那个 `//` 行注释和尾部的分号所暗示的那样，Lox的语法是C家族的一员。(字符串周围没有括号，是因为 `print` 是一个内置语句，而不是库函数)。

在这我不会声称<span name="c">C</span>语言的语法很出色。如果我们想要更优雅的东西，我们可能会模仿 Pascal 或 Smalltalk 。如果我们想完全采用北欧极简风格的话，我们会采用 Scheme。他们各具特色。

<aside name="c">

我肯定带有偏见，但我认为Lox的语法相当干净。C语言最令人头疼的语法问题是关于类型的。Dennis Ritchie有一个叫做 [declaration reflects use][use] （声明反映使用）的想法，其中变量声明反映了为获得基本类型的值而必须对变量执行的操作。这个主意不错，但我认为它在实践中的效果并不好。

[use]: http://softwareengineering.stackexchange.com/questions/117024/why-was-the-c-syntax-for-arrays-pointers-and-functions-designed-this-way

Lox没有静态类型，所以我们避免了这一点。

</aside>

类似C语言的语法所具有的是在一种语言中更有价值的东西：熟悉程度。我知道你对这种风格已经很熟悉了，因为我们用来实现 Lox 的两种语言--Java和C--也都继承了这种风格。在 Lox 中使用类似的语法，可以让你少学一点东西。

## 高级语言

虽然这本书最终比我希望的要厚，但它仍然不够厚，不能把像 Java 这样的庞然大物装进去。为了在有限的篇幅中容纳两个完整的 Lox 的实现，Lox本身必须相当紧凑。

当我想到那些小而有用的语言时，我脑海中最先浮现的是高级 "脚本 "语言，如<span name="js">JavaScript</span> 、Scheme 和 Lua 。在这三种语言中，Lox看起来最像JavaScript，主要是因为大多数C-语法语言都是如此。稍后我们将了解到，Lox的范围界定方法与Scheme密切相关。我们将在[Part III][]建立的Lox的C语言实现，在很大程度上借鉴了Lua的简洁、高效的实现。

[part iii]: a-bytecode-virtual-machine.html

<aside name="js">

现在，JavaScript已经席卷全球，并已用于构建大量应用程序，很难再把它看作是一种 "小脚本语言"。但是Brendan Eich曾在十天内将第一个JS解释器嵌进了Netscape Navigator，使网页上的按钮具有动画效果。从那时起，JavaScript逐渐发展，但它曾经是一种可爱的小语言。

因为Eich用与一季《百战天龙》大致相同的原材料和时间将JS拼凑在一起，所以它有一些奇怪的角落，在那里，胶带和回形针会露出来。像变量提升、动态绑定 `this` 、数组中的漏洞和隐式转换。

我在Lox上花了不少时间，所以它应该更干净一些。

</aside>

Lox与这三种语言还有两个共同点:

### 动态类型

Lox是动态类型语言。变量可以存储任何类型的值，单个变量甚至可以在不同时间存储不同类型的值。如果你试图对错误类型的值进行操作--例如，用一个数字除以一个字符串--那么这个错误会在运行时才被检测到并报告。

<span name="static">静态</span>类型有很多优点，但它们没有一个比实用性更重要。静态类型系统的学习和实现是一项艰巨的工作。跳过它，会让你的语言更简单，也可以让本书更薄。如果我们把类型检查推迟到运行时，我们就能更快地启动解释器并执行代码。

<aside name="static">

毕竟，我们将用来实现Lox的两种语言都是静态类型的。

</aside>

### 自动内存管理

高级语言的存在是为了消除容易出错的、低层次的繁琐工作，还有什么比手动管理存储的分配和释放更繁琐的呢？没有人会在起床后迎着早晨的太阳说，"我迫不及待想找到正确的位置去调用 `free()` 方法，来释放掉今天我在内存中申请的每个字节！"

管理内存的主要<span name="gc">技术</span>有两种：**引用计数** 和 **追踪式垃圾回收** （通常只称为 **垃圾回收** 或 **GC** ）。引用计数的实现要简单得多，我想这就是为什么 Perl 、PHP 和 Python 一开始都使用该方式的原因。但是，随着时间的推移，参考计数的限制变得太麻烦了。所有这些语言最终都增加了一个完整的 GC，或者至少是足以清除对象循环引用的管理方式。

<aside name="gc">

在实践中，引用计数和GC更像是一个连续体的两端，而非是对立的。大多数参考计数系统最终都会做一些跟踪来处理循环，如果你仔细观察的话，生成GC的写障碍看起来有点像保留调用。

关于这个问题的更多信息，请参考 "[A Unified Theory of Garbage Collection][gc]"（PDF）。

[gc]: https://researcher.watson.ibm.com/researcher/files/us-bacon/Bacon04Unified.pdf

</aside>

追踪式垃圾回收有一个听起来就很可怕的名称。在原始内存的层面上工作是有点折磨人的。调试 GC 有时会让你在梦中看到 hex dumps。但是，请记住，这本书是关于驱散魔法和杀死那些怪物的，所以我们要编写自己的垃圾回收器。我想你会发现这个算法很简单，而且实现起来很有趣。

## 数据类型

在Lox的小宇宙中，构成所有物质的原子是内置的数据类型。只有几种:

*   **<span name="bool">布尔值</span>.** 没有逻辑就没有代码，没有布尔值就没有逻辑。"真 "和 "假"，就是软件的阴和阳。与某些古老的语言重新利用已有类型来表示真假不同，Lox有一个专用的布尔类型。我们在这次探险中可能有些粗暴，但我们不是野蛮人。

    <aside name="bool">

    Boolean 变量是 Lox 中唯一以乔治·布尔命名的数据类型，这就是为什么“Boolean”是大写的。他于1864年去世，比数字计算机将他的代数转化为电子信息早了近一个世纪。我想知道他看到自己的名字出现在数十亿行Java代码中会怎么想。 

    </aside>

    显然，下面有两个布尔值，每个值都有一个字面量：

    ```lox
    true;  // Not false.
    false; // Not *not* false.
    ```

*   **Numbers.** Lox只有一种数字：双精度浮点数。由于浮点数也可以表示各种各样的整数，这涵盖了很多的领地，同时保持了简单。

    功能齐全的语言有多钟数字语法--十六进制、科学计数法、八进制等各种有趣的东西。我们将满足于基本的整数和十进制数字。

    ```lox
    1234;  // An integer.
    12.34; // A decimal number.
    ```

*   **Strings.** 我们已经在第一个例子中看到了一个字符串字面量。和大多数语言一样，它们被括在双引号中：

    ```lox
    "I am a string";
    "";    // The empty string.
    "123"; // This is a string, not a number.
    ```

    我们在实现它们时会看到，在这一连串无害的<span name="char">字符</span>序列中隐藏着相当多的复杂情况。

    <aside name="char">

    就连 "character "这个词，也是一个骗局。它是 ASCII 的? Unicode ？一个码位还是一个 "字形簇"？字符是如何编码的？每个字符的大小是固定的，还是可以变化的？

    </aside>

*   **Nil.** --最后一种内置数据，它从未被邀请参加聚会，但似乎总是出现。它代表 "无效值"。它在许多其他语言中被称为 "null"。在Lox中，我们把它拼写成  `nil` 。(当我们实现它时，这将有助于区分我们在谈论 Lox 的  `nil` 还是 Java 或 C 中的  `null` )。

    有充分的理由支持在语言中不使用 `null`，因为空指针错误是我们行业的祸害。如果我们实现的是静态类型语言，那么禁止它是值得的。但在动态类型的语言中，消除它往往比保留它更麻烦。

## 表达式

如果内置数据类型及其字面量是原子，那么 **expressions** 必须是分子。其中大多数我们都很面熟。

### 算术运算符

Lox具有你在C语言和其他语言中熟悉和喜爱的基本算术运算符：

```lox
add + me;
subtract - me;
multiply * me;
divide / me;
```

操作符两边的子表达式是操作数。因为有两个操作数，所以被称为二元运算符（ **binary** operators , 这与 "**binary** "的1和0的用法无关。)因为运算符<span name="fixity">固定</span>在操作数的中间，所以这些运算符也称为 **中缀** 运算符(相对的，还有运算符位于操作数之前的 **前缀** 运算符和运算符位于操作数之后的 **后缀** 运算符)。

<aside name="fixity">

有一些运算符有两个以上的操作数，运算符和操作数是交错的。唯一被广泛使用的是C的 "条件"或"三元"运算符。

```c
condition ? thenArm : elseArm;
```

有些人称这些为混合运算符。有一些语言允许你定义自己的运算符，并控制它们的位置--它们的 "固定性"。

</aside>

有一个算术运算符实际上既是中缀运算符又是前缀运算符。 即 `-` 运算符，它也可用于对数字求反。

```lox
-negateMe;
```

所有这些操作符都用于处理数字，向它们传递任何其他类型都是错误的。唯一的例外是 `+` 运算符，您也可以向它传递两个字符串来连接它们。

### 比较运算符

继续前行，我们还有一些总是返回布尔值的运算符。我们可以使用古老的比较运算符来比较数字（而且只能比较数字）。

```lox
less < than;
lessThan <= orEqual;
greater > than;
greaterThan >= orEqual;
```

我们可以测试两个任何类型的值是否相等：

```lox
1 == 2;         // false.
"cat" != "dog"; // true.
```

即使是不同类型也可以：

```lox
314 == "pi"; // false.
```

不同类型的值 *永远* 不相等：

```lox
123 == "123"; // false.
```

我通常是反对隐式转换的。

### 逻辑运算符

逻辑非运算符，表示为前缀操作符 `！`，如果其操作数为 `true` ，则返回`false` ，反之亦然。

```lox
!true;  // false.
!false; // true.
```

其他两个逻辑运算符实际上是以表达式为幌子的控制流结构。<span name="and">`and`</span> 表达式用于确认两个值是否都是 true 。如果是 false ，它就返回左边的操作数，否则就返回右边的操作数。

```lox
true and false; // false.
true and true;  // true.
```

 `or` 表达式决定两个值中的任何一个（或两个）是否为 true。如果是 true ，它返回左边的操作数，否则返回右边的操作数。

```lox
false or false; // false.
true or false;  // true.
```

<aside name="and">

我用 `and` 和 `or` 来代替 `&&` 和 `||` ，因为Lox不使用 `&` 和 `|` 来表示位元操作符。在没有单字符的情况下引入双字符形式感觉很奇怪。

我也更喜欢用单词来表示这些运算，因为它们实际是控制流结构，而不是简单的运算符。

</aside>

`and` 和 `or` 之所以像控制流结构，是因为它们会 **短路** 。如果左边的操作数是 false， `and` 不仅会返回，而且在这种情况下它甚至不会运算右边的操作数。类似的，如果 `or` 的左边操作数为真，右边操作数就会被跳过。

### 优先级和分组

所有这些操作符都具有与c语言相同的优先级和结合性。(当我们开始解析时，会进行更详细的说明)。在优先级不满足要求的情况下，您可以使用 `()` 对内容进行分组。

```lox
var average = (min + max) / 2;
```

由于在技术上不是很有趣，我已经从我们的小语言中删掉了剩下的典型操作符。没有位运算、移位、取模或条件运算符。我不给你评分，但如果你通过自己的方式来完成支持这些运算的 Lox 实现，你会在我心中得到额外加分。

这些是表达式形式（除了一些与我们将在后面介绍的特定特性相关的），所以让我们继续向上。

## 语句

现在我们来看看语句。表达式的主要工作是产生一个值，而语句的工作是产生一个效果。根据定义，语句不求值，它们用于以某种方式改变世界--通常是修改一些状态，读取输入，或产生输出。

您已经看到了几种类型的语句。第一种是:

```lox
print "Hello, world!";
```

 <span name="print">`print` </span> 语句计算单个表达式，并向用户显示结果。您还看到了一些语句，如:

<aside name="print">

在语言中加入 `print` 语句，而不是将其作为核心库函数，是一种黑客行为。但它对我们来说是一个 *有用* 的技巧：它意味着我们正在进行的解释器可以在我们实现所有定义函数、按名称查找和调用它们所需的机器之前就开始产生输出。

</aside>

```lox
"some expression";
```

表达式后跟分号(`;`) 可以将其提升为语句。这被称为(很有想象力)，一个 **表达式语句** 。

如果你想把一系列的语句打包到一个单独的语句中，你可以把它们打包在一个 **块** 中。

```lox
{
  print "One statement.";
  print "Two statements.";
}
```

块还会影响作用域，我们将在下一节中进行说明...

## 变量

你可以用 `var` 语句声明变量。如果 <span name="omit">省略</span> 了初始化操作，变量值默认为 `nil` 。

<aside name="omit">

在这种情况下，不使用“nil”并强制将每个变量初始化为某个值将比使用“nill”本身更麻烦。

</aside>

```lox
var imAVariable = "here is my value";
var iAmNil;
```

一旦声明完成，你自然就可以通过变量名对其进行访问和赋值。

<span name="breakfast"></span>

```lox
var breakfast = "bagels";
print breakfast; // "bagels".
breakfast = "beignets";
print breakfast; // "beignets".
```

<aside name="breakfast">

你能看出我倾向于在早上吃东西之前就开始写这本书吗？

</aside>

我不会在这里讨论变量作用域的规则，因为在后面的章节中，我们将会花费大量的时间来描述每一个规则。在大多数情况下，它的工作方式就像你从C或Java中所期望的那样。

## 控制流

如果你不能跳过某些代码，或者不能多次执行某些代码，就很难写出<span name="flow">有用的</span>程序。这就是控制流。除了我们已经讨论过的逻辑操作符，Lox直接从c语言中借鉴了三个语句。

<aside name="flow">

我们已经有了 `and` 和 `or` ，可以进行分支处理，而且我们可以使用递归来重复代码，所以理论上这就足够了。不过，在命令式语言中这样编程很尴尬。

另一方面，Scheme没有内置的循环结构。它确实靠递归来实现重复执行代码。Smalltalk没有内置的分支结构，而是依靠动态调度来选择性地执行代码。

</aside>

 `if` 语句根据某种条件执行两条语句中的一条。

```lox
if (condition) {
  print "yes";
} else {
  print "no";
}
```

只要条件表达式的计算结果为 true，`while` <span name="do">循环</span> 就会重复执行循环体。

```lox
var a = 1;
while (a < 10) {
  print a;
  a = a + 1;
}
```

<aside name="do">

我没有在Lox中实现 `do while` 循环，因为它们并不常见，而且不会教你任何你从  `while` 中学不到的东西。如果你高兴的话，可以把它添加到你的实现中去。这是你的party。

</aside>

最后，还有 `for` 循环。

```lox
for (var a = 1; a < 10; a = a + 1) {
  print a;
}
```

这个循环与之前的 `while` 循环做的事情相同。大多数现代语言还具有某种<span name="foreach">`for-in`</span> 或 `foreach` 循环，用于显式迭代各种序列类型。在真实的语言中，这比我们在这里得到的粗糙的 C 风格 `for` 循环要好。Lox只保留最基础的实现。

<aside name="foreach">

这是我做出的一个让步，因为本书中的实现是按章节划分的。 `for-in` 循环需要迭代器协议中的某种动态调度来处理不同种类的序列，但我们在完成控制流之后才会得到这个。我们可以回过头来，在后面添加 `for-in` 循环，但我认为这样做不会让你学到什么超级有趣的东西。

</aside>

## 函数

函数调用表达式看起来和c语言中的一样：

```lox
makeBreakfast(bacon, eggs, toast);
```

你也可以在不传递任何参数的情况下调用一个函数：

```lox
makeBreakfast();
```

与Ruby不同，在这种情况下，括号是必需的。如果不使用它们，就不会 *调用* 函数，而只是引用它。

如果你不能定义你自己的函数，那么一种语言就算不上有趣。在Lox中，你可以用 <span name="fun">`fun`</span>关键字实现。

<aside name="fun">

我见过其他语言有使用 `fn`, `fun`, `func`, 和 `function` 做关键字的. 我还是希望能在某个地方找到 `funct`, `functi`, 或者 `functio` 做为函数的关键字. 

</aside>

```lox
fun printSum(a, b) {
  print a + b;
}
```

现在是澄清一些<span name="define">术语</span>的好时机。有些人把 `parameter` 和 `argument` 混为一谈，对许多人来说，它们确实可以互换。我们将花很多时间围绕语义学来对其进行分辨，所以让我们在这里把话说清楚: 

*   **argument** 是调用函数时传递给函数的实际值。所以函数调用有一个实参列表( `argument list` )。有时称之为实参 **actual parameter** 。

*    `Parameter` 是一个变量，它在函数体中保存参数的值。因此，函数声明有一个形参列表( `parameter list` )。有时被称之为形参  **formal parameters** ,或者 **formals** 。

<aside name="define">

说到术语，一些静态类型的语言，如C语言，会对函数的声明和定义进行区分。声明将函数的类型与它的名字绑定在一起，这样可以对调用进行类型检查，但不提供函数体。定义声明了函数，同时也填写了主体，这样函数就可以被编译了。

由于Lox是动态类型的，所以这种区分没有意义。一个函数声明完全指定了函数，包括它的主体。

</aside>

函数体总是一个块。在其中，您可以使用 `return` 语句返回值。

```lox
fun returnSum(a, b) {
  return a + b;
}
```

如果执行到了块的末尾而没有 `return` 语句，则将<span name="sneaky">隐式</span>返回nil。

<aside name="sneaky">

原注: 你看，我告诉过你 `nil` 会在我们不注意的时候潜入。

</aside>

### 闭包

函数是Lox中的 *一等公民* ，这意味着它们是真实的值，你可以引用，存储在变量中，传递等等。下面的代码是有效的:

```lox
fun addPair(a, b) {
  return a + b;
}

fun identity(a) {
  return a;
}

print identity(addPair)(1, 2); // Prints "3".
```

因为函数声明是语句，所以可以在另一个函数中声明局部函数。

```lox
fun outerFunction() {
  fun localFunction() {
    print "I'm local!";
  }

  localFunction();
}
```

如果将局部函数、首类函数和块作用域结合起来，就会遇到这种有趣的情况:

```lox
fun returnFunction() {
  var outside = "outside";

  fun inner() {
    print outside;
  }

  return inner;
}

var fn = returnFunction();
fn();
```

这里，`inner()` 访问一个在它的函数体之外的外部函数中声明的局部变量。这样可行吗？现在许多语言都借鉴了Lisp的这一特性，您可能知道答案是肯定的。

要做到这一点，`inner()` 必须“保留”对它所使用的任何环境变量的引用，这样，即使在外部函数返回之后，这些变量也不会丢失。我们把能做到这一点的函数称为<span
name="closure">**closures** 闭包</span>。现在，这个术语经常被用于任何首类函数，但是如果函数没有在任何变量上闭包，那就有点用词不当了。

<aside name="closure">

Peter J. Landin 创造了 "闭合 "这个术语。是的，他发明了编程语言中几乎一半的术语。他们中的大多数都来自一篇令人难以置信的论文："[The Next 700 Programming Languages][svh]"

[svh]: https://homepages.inf.ed.ac.uk/wadler/papers/papers-we-love/landin-next-700.pdf

为了实现这类函数，你需要创建一个数据结构，将函数的代码和它所需要的环境变量捆绑在一起。他把这称为 "闭包"，是因为函数“闭合”并保留了它需要的变量。

</aside>

可以想象，实现这些会增加一些复杂度，因为我们不能再假定变量作用域严格地像堆栈一样工作，在函数返回时局部变量就消失了。我们将度过一段有趣的时间来学习如何使这些工作，并有效地做到这一点。

## 类

由于 Lox 具有动态类型、词法(粗略地说就是“块”)作用域和闭包，它离成为函数式语言只有一半的距离。但是正如您将看到的，它离成为面向对象语言也只有一半的距离。这两种模式都有很多优点，所以我认为有必要分别介绍一下。 

类因为没有达到其宣传效果而受到抨击，所以让我先解释一下为什么我把它们放到 Lox 和这本书中。这里实际上有两个问题:

### 为什么任何语言都想成为面向对象的？

现在像Java这样的面向对象语言已经销声匿迹，只能在舞台上表演，喜欢它们已经不酷了。为什么一种新的语言要面向对象？这不就像现在发行音乐磁带一样吗？

诚然，90年代的“始终继承”狂潮产生了一些畸形的类层次结构，但 **面向对象编程** （ **OOP** ）仍然相当流行。数十亿行成功的代码都是用OOP语言编写的，为快乐的用户提供了数百万个应用程序。可能今天大多数在职程序员都在使用面向对象语言。他们不可能都错得那么离谱。

特别是，对于动态类型语言，对象非常方便。我们需要某种方式来定义复合数据类型，用来将一堆数据组合在一起。

如果我们也能把方法挂在这些对象上，那么我们就不需要把函数操作的数据类型的名字作为函数名称的前缀，以避免与不同类型的类似函数发生冲突。例如，在Racket中，您必须将函数命名为 `hash-copy` 用于复制哈希表）和 `vector-copy` （用来复制向量），这样它们就不会相互影响。而方法的作用域是对象，这个问题就不存在了。

### Lox为什么是面向对象的？ 

我可以说是因为对象确实很吸引人，但这仍然超出了本书的范围。大多数编程语言书籍，尤其是那些试图实现一门完整语言的书籍，都忽略了对象。对我来说，这意味着这个主题没有被很好地覆盖。对于如此广泛使用的范式，这种遗漏让我很难过。 

鉴于我们中有多少人整天都在使用OOP语言，似乎这个世界应该有一些关于如何制作OOP语言的文档。正如你将看到的，这是非常有趣的。没有你担心的那么难，但也没有你想象的那么简单。

### Classes 或 prototypes

谈到对象，实际上有两种方法，[classes][]和[prototypes][]。Classes最先出现，并且由于C++、Java、C#和它们的朋友们的出现而变得更加普遍。Prototypes是一个几乎被遗忘的分支，直到JavaScript意外地占领了世界。

[classes]: https://en.wikipedia.org/wiki/Class-based_programming
[prototypes]: https://en.wikipedia.org/wiki/Prototype-based_programming

在基于类的语言中，有两个核心概念：实例(instances)和类(classes)。实例存储每个对象的状态，并有一个对实例的类的引用。类包含方法和继承链。要在实例上调用方法，总是存在一个中间层。你要<span name="dispatch">查找</span>实例的类，然后在那里找到该方法。

<aside name="dispatch">

在像 `C++` 这样的静态类型语言中，方法查找通常发生在编译时，基于实例的静态类型，为您提供静态调度。相反，**动态调度** 在运行时查找实际实例对象的类。这就是静态类型语言中的虚方法和动态类型语言(如Lox)中的所有方法的工作方式。

</aside>

<img src="image/the-lox-language/class-lookup.png" alt="How fields and methods are looked up on classes and instances" />

基于原型的语言<span name="blurry">融合</span>了这两个概念。只有对象，没有类，而且每个对象都可以包含状态和方法。对象可以直接相互继承(或者原型语言的术语称为“委托”):

<aside name="blurry">

实际上，基于类的语言和基于原型的语言之间的界限很模糊。JavaScript的“构造函数”概念让你很难定义类对象 [很难定义类对象][js new]。同时，基于类的Ruby非常乐意让您将方法附加到单个实例上。

[js new]: http://gameprogrammingpatterns.com/prototype.html#what-about-javascript

</aside>

<img src="image/the-lox-language/prototype-lookup.png" alt="How fields and methods are looked up in a prototypal system" />

这意味着在某些方面，原型语言比类更原始。它们很容易实现，因为它们是如此简单。而且，它们可以表达很多不寻常的模式，而类会引导你远离这些模式。

但是我看过很多用原型语言写的代码——包括一些我自己设计的 [some of my own devising][finch]。你知道人们通常会用原型语言的强大功能和灵活性来做什么吗？ . . 他们用它们来重新创造类。

[finch]: http://finch.stuffwithstuff.com/

我不知道这是为什么，但人们似乎自然而然地喜欢基于类的风格（Classic？ Classy）？原型在语言上更简单，但它们似乎只是通过把复杂性<span name="waterbed">推给</span>用户来实现的。所以，对于Lox来说，我们要为用户省去麻烦，把类直接烘焙进去。

<aside name="waterbed">

Larry Wall ，Perl的发明者/先知，把这称为 "[waterbed theory][]"。一些复杂性是必不可少的，不能被消除。如果你把它压在一个地方，它就会在另一个地方膨胀起来。

[waterbed theory]: http://wiki.c2.com/?WaterbedTheory

原型语言与其说是 *消除* 了类的复杂性，不如说是让用户通过建立他们自己的类的元编程库来承担这种复杂性。

</aside>

### Lox中的类

理由已经说够了，来看看我们实际上拥有什么。在大多数语言中，类包含了一系列的特性。对于Lox，我选择了我认为最闪亮的一点。您可以像这样声明一个类及其方法:

```lox
class Breakfast {
  cook() {
    print "Eggs a-fryin'!";
  }

  serve(who) {
    print "Enjoy your breakfast, " + who + ".";
  }
}
```

类的主体包含其方法。它们看起来像函数声明，但是没有 `fun` <span name="method">关键字</span>。当类声明生效时，Lox将创建一个类对象，并将其存储在以该类命名的变量中。就像函数一样，类在Lox中也是一等公民：

<aside name="method">

但是它们还是跟fun类似。

</aside>

```lox
// Store it in variables.
var someVariable = Breakfast;

// Pass it to functions.
someFunction(Breakfast);
```

接下来，我们需要一种创建实例的方法。我们可以添加一些 `new` 关键字，但是为了简单起见，在Lox中，类本身是实例的工厂函数。像调用函数一样调用一个类，它会生成一个自己的新实例：


```lox
var breakfast = Breakfast();
print breakfast; // "Breakfast instance".
```

### 实例化和初始化

只有行为的类不是非常实用。面向对象编程背后的思想是将行为和状态封装在一起。为此，需要字段。为此，您需要有字段。Lox和其他动态类型语言一样，允许您自由地向对象添加属性：

```lox
breakfast.meat = "sausage";
breakfast.bread = "sourdough";
```

如果某个字段尚不存在，则赋值时就会创建该字段。

如果你想从一个方法中访问当前对象上的一个字段或方法，你可以使用古老的 `this`。

```lox
class Breakfast {
  serve(who) {
    print "Enjoy your " + this.meat + " and " +
        this.bread + ", " + who + ".";
  }

  // ...
}
```

在对象中封装数据的目的之一是确保对象在创建时处于有效状态。为此，你可以定义一个构造函数。如果您的类有一个名为 `init()` 的方法，则在构造对象时会自动调用该方法。传递给该类的任何参数都被转发给它的构造函数。

```lox
class Breakfast {
  init(meat, bread) {
    this.meat = meat;
    this.bread = bread;
  }

  // ...
}

var baconAndToast = Breakfast("bacon", "toast");
baconAndToast.serve("Dear Reader");
// "Enjoy your bacon and toast, Dear Reader."
```

### 继承

每一种面向对象的语言不仅允许你定义方法，还允许你在多个类或对象中重用它们。为此，Lox支持单一继承。当声明一个类时，可以使用小于<span name="less">(`<`)</span>操作符指定它继承的类。

```lox
class Brunch < Breakfast {
  drink() {
    print "How about a Bloody Mary?";
  }
}
```

<aside name="less">

为什么是 `<` 运算符？我不想引入像 `extends` 这样的新关键字。Lox不使用 `:` ,所以我也不想保留它。相反，我借鉴了Ruby的做法，用 `<` 。

如果你了解任何类型理论，你会注意到这不是一个完全任意的选择。子类的每个实例也是其超类的实例，但是超类的实例可能不是子类的实例。这意味着，在对象的世界中，子类对象的集合小于超类对象的集合，尽管类型爱好者通常使用  `<:` 来表示这种关系。

</aside>

在这里，Brunch 是 **派生类** 或 **子类** ，Breakfast 是 **基类** 或 **超类** 。

超类中定义的每个方法也可用于它的子类。

```lox
var benedict = Brunch("ham", "English muffin");
benedict.serve("Noble Reader");
```

甚至 `init()` 方法也被继承了。在实践中，子类通常也想定义自己的 `init()` 方法。但是基类的那个方法也需要被调用，以便基类能够维护其状态。我们需要某种方式能够调用自己实例上的方法，而无需触发实例自身的方法。

<aside name="init">

Lox不同于C++、Java和C#，它们不继承构造函数，类似于Smalltalk和Ruby，它们继承构造函数。

</aside>

就像在Java中一样，你可以用 `super` 来实现。

```lox
class Brunch < Breakfast {
  init(meat, bread, drink) {
    super.init(meat, bread);
    this.drink = drink;
  }
}
```

这就是面向对象的内容。我尽量将功能设置保持在最低限度。本书的结构确实迫使我们做出一个妥协。Lox不是一种纯粹的面向对象的语言。在真正的OOP语言中，每个对象都是一个类的实例，即使是数字和布尔这样的基本类型。

因为我们开始使用内置类型很久之后才会实现类，所以这一点很难实现。因此，从类实例的意义上说，基本类型的值并不是真正的对象。它们没有方法或属性。如果以后我想让Lox成为真正的用户使用的语言，我会解决这个问题。

## 标准库

我们快结束了。这就是整个语言，所剩下的就是 "核心 "或 "标准 "库--直接在解释器中实现的一组功能集，所有用户定义的行为都建立在这个基础之上。

这是Lox最可悲的地方。它的标准库超越了极简主义，接近于彻底的虚无主义。对于书中的示例代码，我们只需要证明代码正在运行并做它应该做的事情。为此，我们已经有了内置的 `print` 语句。

稍后，当我们开始优化时，我们将写一些基准测试，看看执行代码需要多长时间。这意味着我们需要跟踪时间，所以我们将定义一个内置函数 `clock()` ，返回程序开始后的秒数。

然后......就是这样。 我知道，有点尴尬，对吧？ 

如果你想把Lox变成一门实际可用的语言，你应该做的第一件事就是充实这个。字符串操作、三角函数、文件输入/输出、网络，甚至是读取用户的输入都会有帮助。但是我们在这本书中不需要这些东西，而且添加这些东西也不会教你任何有趣的东西，所以我把它省略了。

别担心，这门语言本身就有很多令人兴奋的东西让我们忙个不停。

<div class="challenges">

## 挑战

1. 编写一些 Lox 程序并运行它们（你可以使用[my repository][repo]中的Lox的实现）。试着想出我在这里没有说明的边界情况。它能做到你所期望的吗？为什么？

2. 这个非正式的介绍留下了 *很多* 未说明的东西。列出你对该语言的语法和语义的几个开放问题。你认为答案应该是什么？

3. Lox是一种相当小的语言。你认为它缺少哪些功能，会使其不适用于实际程序？(当然，除了标准库之外）。

</div>

<div class="design-note">

## 设计须知:表达式和语句

Lox既有表达式也有语句。有些语言省略了后者。相反，它们也将声明和控制流结构视为表达式。这些“一切都是表达式”语言往往具有函数式的血统，包括大多数Lisp、SML、Haskell、Ruby和CoffeeScript。

为此，对于语言中的每个“类似语句”的构造，您需要确定其计算值。其中一些很简单

*   `if` 表达式的计算结果是所选分支的结果。同样，`switch` 或其他多路分支的计算结果取决于选择的情况。

*   变量声明的计算结果为变量的值。

*   块计算结果为序列中最后一个表达式的结果。

有些变得有点陌生。循环的计算结果应该是什么？CoffeeScript中的 `while` 循环计算结果为一个数组，其中包含了循环体中计算到的每个元素。这可能很方便，但如果你不需要这个数组，就会浪费内存。

您还必须决定这些类似语句的表达式如何与其他表达式组合，您必须将它们放入语法的优先表中。例如，Ruby允许：

```ruby
puts 1 + if true then 2 else 3 end + 4
```

这是你所期望的吗？这是你的用户所期望的吗？这对你设计 "语句 "的语法有什么影响？请注意，Ruby有一个明确的 `end` 来告诉 `if` 表达式何时完成。如果没有它， `+ 4` 可能会被解析为 `else` 子句的一部分。

把每个语句变成一个表达式，迫使你回答一些像这样的毛糙的问题。作为回报，你消除了一些冗余。C语言既有用于排列语句顺序的块，也有用于排列表达式顺序的逗号运算符。它既有 `if` 语句，也有 `?:` 条件运算符。如果在C语言中所有的东西都是表达式，你就可以把这些东西都统一起来。

摒弃了语句的语言通常还具有 **隐式返回** 的特点--函数会自动返回其主体所计算的任何值，而不需要显式的 `return` 语法。对于小型函数和方法来说，这真的很方便。事实上，许多有语句的语言都增加了像 `=>` 这样的语法，以便能够定义函数体是计算单一表达式结果的函数。

但是让 *所有* 的函数以这种方式工作可能有点奇怪。即使你只是想让函数产生副作用，如果不小心，函数也可能会泄露返回值。不过在实践中，这些语言的用户并不觉得这是一个问题。

对于 Lox 来说，我在其中添加语句的理由平淡无奇。因为熟悉，我选择了一种类似C的语法，而试图把现有的C语句语法像表达式一样解释，会很快变得奇怪。

</div>
