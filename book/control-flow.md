> 逻辑，犹如威士忌，当过度饮用时，其益处便难以显现。
>
> <cite>爱德华·约翰·莫顿·德拉克斯·普兰克特，邓桑尼勋爵</cite>

与[上一章][statements]艰苦的马拉松相比，本章就像在雏菊草地上轻快地嬉戏。虽然工作轻松，但回报却出乎意料地丰厚。

[statements]: statements-and-state.html

眼下，我们的解释器仅仅是一个简单的计算器而已。Lox程序在完成前只能执行有限的任务。要使其运行时间加倍，就必须让源代码变得更长。然而，我们即将改变这一现状。在本章中，我们的解释器将向编程语言的顶级联赛迈出重要一步：*图灵完备性*。

## 图灵机 (简介)

在上个世纪初的早期，数学家们陷入了一系列令人困惑的<span name="paradox">悖论</span> 中，这使他们对自己建立工作基础的稳定性产生了怀疑。为了解决这一[危机][crisis]，他们回到了原点。他们从少数必要的基本原理、逻辑和集合论出发，希望在坚不可摧的基础上重建数学。

[crisis]: https://en.wikipedia.org/wiki/Foundations_of_mathematics#Foundational_crisis

<aside name="paradox">

最有名的就是[**罗素悖论**][russell]了。一开始，集合论允许你定义任何类型的集合。只要你用英语描述出来，那就是有效的。因为数学家们喜欢自我引用，所以集合可以包含其他集合。于是，淘气的罗素提出了这个问题：

*R是所有不包含自己的集合的集合。*

R是不是包含自己呢？如果不包含自己，根据定义的后半部分，它应该包含自己。但如果它包含自己，那它就不再符合定义了。这个问题会让你的脑袋崩溃。

[russell]: https://en.wikipedia.org/wiki/Russell%27s_paradox

</aside>

他们想要严谨地回答这样的问题："所有真实的陈述都能被证明吗？"，"我们能[计算][compute]出我们可以定义的所有函数吗？"，甚至更普适的问题："当我们声称一个函数是'可计算的'时，代表什么意思？"

[compute]: https://en.wikipedia.org/wiki/Computable_function

他们假设前两个问题的答案是"是"。剩下的就是证明它。但事实证明，这两个问题的答案都是"否"，而且令人惊讶的是，这两个问题是深度交织在一起的。这是数学中一个迷人的角落，涉及到关于大脑能够做什么以及宇宙如何运作的基本问题。在这里，我无法充分地解释这个问题。

我想要指出的是，在证明前两个问题的答案是"不是"的过程中，艾伦·图灵和阿隆佐·邱奇提出了一个精确的答案来回答最后一个问题——什么样的函数是<span name="uncomputable">可计算的</span>。他们各自设计了一个简单的系统，只用了最基本的工具，但仍然足够强大，可以计算出任意超大类函数。

<aside name="uncomputable">

他们通过展示一个返回给定语句真值的函数*不是*可计算函数来证明第一个问题的答案是"否"。

</aside>

这些现在被称为"可计算函数"。图灵的系统被称为<span name="turing">**图灵机**</span>。邱奇的系统被称为**λ演算**。这两种系统仍然被广泛用作计算模型的基础，实际上，许多现代的函数式编程语言都以λ演算为核心。

<aside name="turing">

图灵称他的发明为"a-machines"，意为"自动的"(automatic)。他并没有过分自夸地将*自己的*名字放在这些发明上。后来的数学家们替他做了这件事。这就是如何在保持一些谦逊的同时获得名声的方法。
</aside>

<img src="image/control-flow/turing-machine.png" alt="A Turing machine." />

图灵机在名字上更有知名度——毕竟至今还没有关于阿隆佐·邱奇的好莱坞电影——但这两种形式化方法在能力上是[等效的][thesis]。实际上，任何具有一定表达能力的编程语言都足够强大，可以计算任何可*计算*函数。

[thesis]: https://en.wikipedia.org/wiki/Church%E2%80%93Turing_thesis

你可以通过在你的编程语言中编写一个图灵机模拟器来证明这一点。由于图灵证明了他的机器可以计算任何可计算函数，因此可以推断出，你的编程语言也可以。你只需要将函数转换为图灵机，然后在模拟器上运行即可。

如果你的编程语言足够表达力，它被认为是**图灵完备**的。图灵机非常简单，所以并不需要太多的能力来实现这一点。基本上，你只需要算术运算、一些控制流程以及分配和使用（理论上）任意数量的内存的能力。我们已经具备了第一个条件。在本章结束时，我们将具备<span name="memory">第二个条件</span>。

<aside name="memory">

我们*几乎*也满足了第三个条件。你可以创建和连接任意大小的字符串，因此你可以*存储*无限的内存。但我们还无法访问字符串的各个部分。

</aside>

## 条件执行

不再啰嗦历史了，让我们给我们的语言加点料吧。控制流可以大致分为两种类型：

*   **条件**或**分支控制流**用于*不*执行某段代码。从命令式的角度来看，你可以将其视为*跳过*一段代码的执行。

*   **循环控制流**用于多次执行一段代码。它会跳回到某个位置，以便再次执行相同的操作。由于通常不希望出现*无限*循环，循环控制流通常会包含一些条件逻辑，以确定何时停止循环。

分支控制流比较简单，所以我们先从这里开始讲解。C语言衍生的语言有两个主要的条件执行特性，`if` 语句和“条件”<span name="ternary">运算符</span> （`?:`）。`if`语句允许您有条件地执行语句，而条件运算符允许您有条件地执行表达式。

<aside name="ternary">

条件运算符也被称为“三元”运算符，因为它是C语言中唯一接受三个操作数的运算符。

</aside>

为了简单起见，Lox没有条件运算符，所以让我们直接开始`if`语句吧。我们的语句语法需要一个新的生成式。

<span name="semicolon"></span>

```ebnf
statement      → exprStmt
               | ifStmt
               | printStmt
               | block ;

ifStmt         → "if" "(" expression ")" statement
               ( "else" statement )? ;
```

<aside name="semicolon">

规则中的分号没有加引号，这意味着它们是语法元语法的一部分，而不是Lox语法的一部分。一个代码块（block）结尾没有分号，`if`语句也没有，除非`then`或`else`语句恰好以分号结尾。

</aside>

`if`语句有一个表达式作为条件，然后接一个在条件为真时要执行的语句。另外，它还可以有一个`else`关键字和条件为假时要执行的语句。<span name="if-ast">语法树节点</span>中对语法的这三部分都有对应的字段。

^code if-ast (1 before, 1 after)

<aside name="if-ast">

T新节点生成的代码在以下位置： [Appendix II][appendix-if].

[appendix-if]: appendix-ii.html#if-statement

</aside>

像其他语句一样，解析器通过前导的`if`关键字来识别`if`语句。

^code match-if (1 before, 1 after)

当解析器遇到if语句时，它会调用这个新方法来解析剩余的部分：

^code if-statement

<aside name="parens">

条件周围的圆括号只有一半是有用的。为了*区分*条件和执行语句，我们需要一种分隔符，否则解析器无法确定条件表达式何时结束。但是在if关键字后面的*小括号*并没有实际用途。Dennis Ritchie（Unix和 C 语言的发明人）把它放在那里是为了使用`)`作为结束分隔符，避免括号不平衡的问题。

其他语言如Lua和一些BASIC语言使用类似"then"的关键字作为结束分隔符，并且在条件之前没有任何内容。而Go和Swift则要求语句是一个用大括号括起来的代码块。这样可以利用在语句开头的`{`来判断条件何时结束。

</aside>

通常情况下，解析代码严格遵循语法。它通过查找前面的`else`关键字来检测`else`子句。如果没有else子句，则语法树中的`elseBranch`字段为`null`。

实际上，这个看似无害的可选else实际上在我们的语法中引起了歧义。考虑以下情况：

```lox
if (first) if (second) whenTrue(); else whenFalse();
```

这是一个谜题：这个else子句属于哪个if语句？这不仅仅是关于我们如何记录语法的理论问题，它实际上会影响代码的执行方式：

*   如果我们将else附加到第一个`if`语句，那么当`first`为假时，无论 `second` 的值是什么，都会调用`whenFalse()`函数。

*   如果我们将else附加到第二个`if`语句，那么只有当`first`为真且`second`为假时，才会调用`whenFalse()`函数。

由于`else`子句是可选的，并且没有明确的分隔符标记`if`语句的结束，当您以这种方式嵌套if语句时，语法就有歧义。这种经典的语法陷阱被称为**[悬挂else][dangling else]**问题。

[dangling else]: https://en.wikipedia.org/wiki/Dangling_else

<span name="else"></span>

<img class="above" src="image/control-flow/dangling-else.png" alt="Two ways the else can be interpreted." />

<aside name="else">
在这里，格式化的作用是突出了else可能有两种解析方式。但是要注意，解析器会忽略空白字符，所以这只是给人类读者的指南。
</aside>

其实也*可以*通过定义一个上下文无关文法来避免这种歧义，但是这样做需要将大部分语句规则分成两个部分，一个允许`if`语句后面带有`else`，一个不允许。这样做挺麻烦的。

相反，大多数编程语言和解析器都会用一些特殊方式规避这个问题。不管他们使用什么花招来解决困境，他们都是选择同样的解释——`else`与最近的`if`绑定在一起。

我们的解析器已经很方便地做到了这一点。由于 `ifStatement()` 在返回之前会主动查找`else`语句，所以在返回到外部`if`语句之前，最内层嵌套系列的调用将会独占`else`子句。

语法就绪了，我们可以开始解释了。

^code visit-if

解释器实现就是对相同的Java代码的简单包装。它首先对条件表达式进行求值。如果为真，则执行`then`分支。否则，如果有存在`else`分支，就执行`else`分支。

如果你把这段代码和我们实现的其他语法比较，你会发现让控制流程特殊的部分就是Java的`if`语句。大部分其他的语法树都会去执行他们的子树。但在这里，我们可能不会执行then或者else语句。如果这两者中的任何一个有副作用，那么选择不去执行它会让用户看到不同的结果。

## 逻辑操作符

虽然我们没有条件运算符，你可能会认为我们已经完成了分支，但事实并非如此。即使没有三元运算符，还有两个其他的运算符在技术上也是控制流结构——逻辑运算符`and`和`or`。

这些运算符与其他二元运算符不同，因为它们会进行**短路操作**。如果在计算左操作数后，我们已经知道逻辑表达式的结果，那么我们就不会计算右操作数。例如：

```lox
false and sideEffect();
```

对于一个`and`表达式来说，两个操作数都必须是真，才能得到结果为真。我们只要看到左侧的false操作数，就知道结果不会是真，也就不需要对`sideEffect()`求值，会直接跳过它。

这就是为什么我们没有将逻辑运算符与其他二元运算符一起实现的原因。现在我们准备好了。这两个新的运算符在优先级表中的位置较低。类似于C语言中的`||` 和`&&`，它们各自有<span name="logical">自己的</span>优先级，`or`比`and`运算符低。我们将它们放在赋值运算符和相等运算符之间的位置。

<aside name="logical">

我一直好奇为什么逻辑运算符的优先级不像各种比较或相等运算符那样相同。

</aside>

```ebnf
expression     → assignment ;
assignment     → IDENTIFIER "=" assignment
               | logic_or ;
logic_or       → logic_and ( "or" logic_and )* ;
logic_and      → equality ( "and" equality )* ;
```

Instead of falling back to `equality`, `assignment` now cascades to `logic_or`.
The two new rules, `logic_or` and `logic_and`, are <span name="same">similar</span> to other binary operators. Then `logic_and` calls
out to `equality` for its operands, and we chain back to the rest of the
expression rules.

现在，赋值（`assignment`）操作不会回退到相等（`equality`）操作，而是会级联到逻辑或操作（`logic_or` 、 `logic_and`）。这两个新规则，逻辑或和逻辑与，与其他二元运算符<span name="same">类似</span> 。然后`logic_and`会调用`equality`计算其操作数，并将其链接回其余的表达式规则。

<aside name="same">
*语法*并不关心它们是否短路。这是一个语义上的问题。
</aside>

我们可以重用现有的Expr.Binary类来处理这两个新表达式，因为它们具有相同的字段。但是， `visitBinaryExpr()` 方法将不得不检查运算符是否是逻辑运算符，并使用不同的代码来处理短路逻辑。我认为定义一个<span name="logical-ast">新类</span>来处理这些运算符更清晰，这样它们就可以拥有自己的 `visit`方法。

^code logical-ast (1 before, 1 after)

<aside name="logical-ast">

新节点的生成代码在 [Appendix II][appendix-logical].

[appendix-logical]: appendix-ii.html#logical-expression

</aside>

为了将新的表达式融入解析器中，我们首先需要修改赋值的解析代码，使其调用`or()`函数。

^code or-in-assignment (1 before, 2 after)

解析一系列`or`表达式的代码与其他二元运算符的解析代码类似。

^code or

它的操作数是下一个更高优先级的表达式，即新的`and`表达式。

^code and

这会为它的操作数调用等式(`equality()`)函数，这样，表达式解析器就重新连接在一起了。我们已经准备好进行解释了。

^code visit-logical

如果你将这个与[之前章节][evaluating]的`visitBinaryExpr()`方法进行比较，你会看到其中的区别。在这里，我们先计算左操作数的值。我们查看它的值来判断是否可以跳过后续步骤。如果不能跳过，那么我们才会计算右操作数的值。

[evaluating]: evaluating-expressions.html

这里还有一个有趣的问题，就是决定要返回什么实际值。因为Lox是动态类型的，所以我们允许使用任何类型的操作数，并使用真值来确定每个操作数的含义。我们对结果应用类似的推理。逻辑运算符不是承诺要返回true或false，而是保证返回一个具有适当真值的值。

幸运的是，我们手头上就有具有适当真值的值——即操作数本身的结果，所以我们可以直接使用它们。如：


```lox
print "hi" or 2; // "hi".
print nil or "yes"; // "yes".
```

在第一行，`"hi"`是一个有值的字符串，被认为是真值，所以`or`运算符会短路并返回它。在第二行，`nil` 是一个空值，被认为是假值，所以它会继续计算并返回第二个操作数，即`"yes"`。

这就涵盖了Lox中所有的分支原语。我们准备*跳到*循环部分。你看出我刚才的技巧了吗？*跳到*。懂了吗？嗯，就像一个引用...哦，算了。

## While 循环

Lox features two looping control flow statements, `while` and `for`. The `while`
loop is the simpler one, so we'll start there. Its grammar is the same as in C.
Lox有两种类型的循环控制流语句，分别是while和for。while循环更简单一点，我们先从它开始。它的语法与C语言相同。



```ebnf
statement      → exprStmt
               | ifStmt
               | printStmt
               | whileStmt
               | block ;

whileStmt      → "while" "(" expression ")" statement ;
```

我们在语句规则中添加了另一个子句，指向while的新规则。它以`while`关键字开头，后跟一个带括号的条件表达式，然后是一个语句体。新的语法规则需要定义新的<span name="while-ast">语法树节点</span>。

^code while-ast (1 before, 1 after)

<aside name="while-ast">

新节点生成的代码在 [Appendix II][appendix-while].

[appendix-while]: appendix-ii.html#while-statement

</aside>

该节点存储了条件和主体。在这里，你可以看到将表达式和语句拆分成独立基类的好处。字段的声明清楚地表明条件是表达式，而循环主体是语句。

在解析器中，我们遵循了与if语句相同的过程。首先，在`statement()`中添加一个分支来检测和匹配前导关键字。

^code match-while (1 before, 1 after)

实际的工作委托给下面的方法：

^code while-statement

语法非常简单，这里将其直接翻译为Java。说到直接翻译成Java，下面是我们执行新语法的方式：

^code visit-while

这个visitor的实现方式和`if`语句的 `visit` 方法类似，都是利用了Java的相应特性。虽然这个方法并不复杂，但它使得Lox的功能更加强大。现在，我们终于可以编写一个运行时间不受源代码长度严格限制的程序了。

## For 循环

我们来到了最后一个控制流结构， <span name="for">老派</span>C风格的for循环。我可能不需要再提醒你了，但它的样子就是这样的：

```lox
for (var i = 0; i < 10; i = i + 1) print i;
```

在语法中，是这样的：

```ebnf
statement      → exprStmt
               | forStmt
               | ifStmt
               | printStmt
               | whileStmt
               | block ;

forStmt        → "for" "(" ( varDecl | exprStmt | ";" )
                 expression? ";"
                 expression? ")" statement ;
```

<aside name="for">

大多数现代语言都有一种更高级的循环语句，用于迭代任意用户定义的序列。C#有`foreach`，Java有"enhanced for"，甚至C++现在也有基于范围的`for`语句。它们通过隐式调用被循环对象支持的迭代协议，提供了比C语言的`for`语句更清晰的语法。

我喜欢那些语法。不过对于Lox来说，我们受限于逐章构建解释器。我们还没有对象和方法，所以无法定义一个`for`循环可以使用的迭代协议。因此，我们将坚持使用老派的C语言`for`循环。把它看作是"复古"的控制流语句，就像自行车修复店里的固定齿轮车一样。

</aside>

在括号内，有三个由分号分隔的子语句：

1.  第一个部分是*初始化器*。它只执行一次，在其他任何操作之前。通常它是一个表达式，但是为了方便起见，我们也可以声明变量。在这种情况下，这个变量的作用域只在整个`for`循环内部，即其他两个部分和循环体内部。

2.  然后是*条件*部分。这个就像在 `while` 循环中一样，这个部分决定了什么时候停止循环。每次循环开始的时候，包括第一次，都会检查这个条件。如果条件成立（结果为真），那就继续执行循环里的内容。如果条件不成立（结果为假），那就停止循环。

3.  最后一个子句是*递增子句*。它是一个任意的表达式，会在每次循环结束的时候做一些工作。因为表达式的结果会被丢弃，所以它必须有副作用才能有用。在实践中，它通常会对变量进行递增。

这些子语句都可以忽略。在右括号之后是一个语句作为循环体，通常是一个代码块。

### 语法脱糖

这一堆东西看起来很复杂，但要注意的是，它们其实并没有做什么我们已经有的语句做不到的事情。如果 `for` 循环不支持初始化器，你可以直接在循环前面写初始化的代码。如果没有递增子句，你也可以自己在循环体的最后写上递增的代码。

换句话说，Lox并不*需要* `for` 循环，只是让一些常见的代码模式更容易编写而已。这些被称为<span  name="sugar">**语法糖**</span>的特性。举个例子，之前的 `for` 循环可以这样重写：

<aside name="sugar">

这个有趣的说法是由彼得·J·兰丁在1964年创造的，用来形容一些像ALGOL这样的编程语言所支持的优雅表达形式，就像是在更基础但可能不那么可口的λ演算之上撒了一些糖。

<img class="above" src="image/control-flow/sugar.png" alt="Slightly more than a spoonful of sugar." />

</aside>

```lox
{
  var i = 0;
  while (i < 10) {
    print i;
    i = i + 1;
  }
}
```

这段代码和之前的代码的意思完全一样，只是看起来没有那么好看。像Lox的`for`循环这样的语法糖特性可以让编程语言更加好用和高效。但是，特别是在复杂的语言实现中，每个需要后台支持和优化的语言特性都是很费神的。

通过<span name="caramel">**desugaring**(语法脱糖)</span>，我们可以既拥有蛋糕又吃掉它。这个有趣的词描述了一个过程，即前端将使用语法糖的代码转换成后端已经知道如何执行的更基本形式。

<aside name="caramel">

哦，我多么希望这个过程被称为“焦糖化”。如果引入了一个比喻，为什么不坚持使用呢？

</aside>

我们将对`for`循环进行去糖化，转换为`while`循环和其他已由解释器处理的语句。在我们的简单解释器中，脱糖并没有节省太多的工作量，但它给了我一个机会来向您介绍这项技术。因此，与之前的语句不同，我们*不会*添加新的语法树节点，而是直接进行解析。首先，添加一个我们即将需要的导入语句。

^code import-arrays (1 before, 1 after)

就像每个语句一样，我们在解析`for`循环时首先匹配关键字。

^code match-for (1 before, 1 after)

这里就变得有趣了。脱糖化将在这里进行，因此我们将逐步构建这个方法，从子句之前的开括号开始。

^code for-statement

接下来的第一个子句是初始化式。

^code for-initializer (2 before, 1 after)

如果紧跟在 `(` 后面的令牌是分号，则说明初始化部分被省略了。否则，我们会检查是否存在 `var` 关键字来确定是否为<span name="variable">变量</span>声明。如果以上两种情况都不匹配，则它必定是一个表达式。我们解析该表达式并将其包装在一个表达式语句中，以确保初始化部分始终为Stmt类型。

<aside name="variable">

在前面的章节中，我提到我们可以将表达式和语句的语法树分成两个独立的类层次结构，因为在语法中没有一个地方同时允许表达式和语句。不过，我想这并不*完全*准确。

</aside>

接下来是条件表达式。

^code for-condition (2 before, 1 after)

再次，我们寻找分号来判断是否省略了该子句。最后一个子句是递增子句。

^code for-increment (1 before, 1 after)

它类似于条件式子句，只是这个子句是由右括号终止的。剩下的就是<span name="body">循环主体</span>了。

<aside name="body">

是我多心了，或许听起来有些不妥?剩下的只有... *body*(尸体)了。

</aside>

^code for-body (1 before, 1 after)

我们已经解析了 `for` 循环的各个部分，生成的AST节点存储在几个Java局部变量中。这就是脱糖的过程。我们使用这些变量来合成语法树节点，以表达 `for` 循环的语义，就像之前我给你展示的手动脱糖的例子一样。

如果我们逆向思考，代码会更加简洁，因此我们从递增子句开始。

^code for-desugar-increment (2 before, 1 after)

如果存在递增子句的话，会在循环的每个迭代中在循环体结束之后执行。我们用一个代码块来代替循环体，这个代码块中包含原始的循环体，后面跟一个执行递增子语句的表达式语句。

^code for-desugar-condition (2 before, 1 after)

接下来，我们将条件和循环体结合起来，使用基本的`while`循环构建循环。如果条件被省略，我们会插入`true`来创建一个无限循环。

^code for-desugar-initializer (2 before, 1 after)

最后，如果存在初始化器，在整个循环之前会运行一次。为了实现这一点，我们再次用一个块来替换整个语句，该块会运行初始化器，然后执行循环。

到此为止。我们的解释器现在已经支持了C风格的 `for` 循环，而且我们完全没有必要修改Interpreter类。由于我们将其转换为了节点，解释器已经知道如何访问这些节点，因此不需要再做任何额外的工作。

最后，Lox已经足够强大，至少能够让我们娱乐一段时间。下面是一个小程序，用于打印斐波那契数列的前21个元素：

```lox
var a = 0;
var temp;

for (var b = 1; a < 10000; b = temp + b) {
  print a;
  temp = a;
  a = b;
}
```

<div class="challenges">

## Challenges

1.  在未来的几章中，当Lox支持一级函数和动态调度时，从技术上讲，我们将不再*需要*语言内置的分支语句。展示如何使用这些功能来实现条件执行。请提供一个使用这种技术来控制流程的语言的名称。

2.  同样地，使用相同的工具可以实现循环，前提是我们的解释器支持一项重要的优化。这是什么优化，为什么它是必要的？请给出一个使用这种技术进行迭代的语言的名称。

3.  与Lox不同，大多数其他C风格的语言还支持在循环内部使用 `break` 和 `continue` 语句。添加对 `break` 语句的支持。

    语法是一个关键字`break`后跟一个分号。如果在任何封闭循环之外出现`break`语句，应该报语法错误。在运行时，`break`语句会导致执行跳转到最近的封闭循环的末尾，并从那里继续执行。请注意，`break`语句可能嵌套在其他块和if语句中，这些块和`if`语句也需要退出。

</div>

<div class="design-note">

## Design Note:  几勺语法糖

编程语言的发展常常面临两种压力：一方面，人们希望在语言中添加新功能，但又需要保持简洁和专注，避免过度臃肿。一旦添加了某种语法，就很难改变，因此谨慎选择语法糖是明智的选择。

与此同时，大多数成功的编程语言在广泛使用之前，它们的语法通常都相对复杂。程序员在自己选择的编程语言中花费大量时间，一些小的便利措施确实可以提高他们的工作效率和舒适度。

这就像设计甜点一样，你可以选择做一个没有太多甜味的健康食品，每种味道都对应一个食材，或者你可以做一个甜蜜的甜点，每一种味道都可以用十种不同的方式表达。成功的编程语言在这两个极端之间找到了平衡。

在极酸涩的一端，有像Lisp、Forth和Smalltalk这样的语言，它们极力地将语法最小化。Lisp的支持者声称他们的语言“没有语法”，而Smalltalk的支持者则以将整个语法放在一张索引卡上为荣。这些语言的哲学是，语言不需要语法糖。相反，它们提供了足够强大的最小语法和语义，使得库代码能够像语言本身一样表达丰富的含义。

接近这些语言的是C、Lua和Go等语言。它们注重简洁和清晰，而不是追求最小化。有些语言，比如Go，故意避免了语法糖和前一类语言的语法可扩展性。它们希望语法不妨碍语义，因此专注于保持语法和库的简单性。代码应该是明显的而不是华丽的。

在中间位置，有像Java、C＃和Python这样的语言。它们在语法糖的使用上更加灵活，但仍然保持相对简洁。

最后，有像Ruby、C++、Perl和D等语言，它们在语法中嵌入了大量的语法糖，以至于标点符号字符都不够用了。

在某种程度上，语法糖的使用与语言的年龄有关。在后续版本中添加一些语法糖相对容易。新的语法对用户来说更具吸引力，并且与改变语义相比，它更不可能破坏现有的程序。一旦添加了语法，就无法再删除，所以语言往往会随着时间的推移而变得更甜。从零开始创建一个新的语言的主要好处之一是可以清除那些累积的糖霜层，并重新开始。

在编程语言界，语法糖在编程语言专家中声誉不佳。他们非常追求简洁主义。这种观点有一定的道理。设计不好、不必要的语法会增加认知负荷，而没有足够的表达力来弥补它的重量。因为一直会有向语言中添加新特性的压力，所以需要自律并专注于简单，以避免臃肿。一旦添加了一些语法，你就无法摆脱它，所以精简是明智的选择。

与此同时，大多数成功的编程语言确实具有相当复杂的语法，至少在被广泛使用时是如此。程序员在他们选择的语言中花费了大量的时间，一些小的便利措施确实可以提高他们工作的舒适度和效率。

找到合适的平衡——为您的编程语言选择适度的甜度水平——依赖于您自己的品味。

</div>
