> 你是我的创造者，但我是你的主人；服从我！
>
> <cite>Mary Shelley, <em>Frankenstein</em></cite>

如果你想为这一章节适当地营造气氛，试着想象一场雷暴，那种喜欢在故事高潮时猛拉百叶窗的打旋的暴风雨。或许再加上几道闪电。在这一章节中，我们的解释器将呼吸，睁开眼睛，并执行一些代码。

<span name="spooky"></span>

<img src="image/evaluating-expressions/lightning.png" alt="A bolt of lightning strikes a Victorian mansion. Spooky!" />

<aside name="spooky">

一个破旧的维多利亚式洋房不是必须的，但可以增添氛围。

</aside>

语言实现可以通过多种方式让计算机执行用户源代码命令。它们可以将其编译为机器代码，将其翻译成另一种高级语言，或将其转换为某些字节码格式，以便虚拟机运行。然而，对于我们的第一个解释器，我们将采取最简单、最短的路径，直接执行语法树本身。


现在，我们的解析器只支持表达式。因此，为了“执行”代码，我们将计算一个表达式并产生一个值。对于我们可以解析的每种表达式语法 - 字面量、运算符等 - 我们都需要相应的代码块，知道如何计算该语法树并产生结果。这引发了两个问题：


1. 我们要生成什么类型的值？

2. 我们如何组织这些代码块？

让我们一步步来...

## 值描述

在Lox中， <span name="value">值</span>由字面量创建，由表达式计算，并存储在变量中。用户将其视为Lox对象，但它们是用编写解释器的底层语言实现的。这意味着要在 *Lox* 的动态类型和Java的静态类型之间架起桥梁。Lox中的变量可以存储任何（Lox）类型的值，甚至可以在不同的时间存储不同类型的值。我们可以使用哪种Java类型来表示它呢？


<aside name="value">

这里，“值”和“对象”基本上可以互换。

稍后在C解释器中，我们会对它们进行细微区分，但这主要是为了在两个不同实现的角落中具有唯一的术语——原地数据和堆分配数据。从用户的角度来看，这些术语是同义的。

</aside>

给定一个具有静态类型的Java变量，我们还必须能够在运行时确定它所持有的值的类型。当解释器执行 `+` 运算符时，它需要确定它是将两个数字相加还是将两个字符串连接起来。是否有一种Java类型可以容纳数字、字符串、布尔值等等？是否有一种类型可以告诉我们它的运行时类型是什么？有的！那就是老朋友： `java.lang.Object`  。

在解释器中需要存储Lox值的地方，我们可以使用Object作为类型。Java有其原始类型的封装版本，这些版本都是Object的子类，因此我们可以将它们用于Lox的内置类型：

<table>
<thead>
<tr>
  <td>Lox type</td>
  <td>Java representation</td>
</tr>
</thead>
<tbody>
<tr>
  <td>Any Lox value</td>
  <td>Object</td>
</tr>
<tr>
  <td><code>nil</code></td>
  <td><code>null</code></td>
</tr>
<tr>
  <td>Boolean</td>
  <td>Boolean</td>
</tr>
<tr>
  <td>number</td>
  <td>Double</td>
</tr>
<tr>
  <td>string</td>
  <td>String</td>
</tr>
</tbody>
</table>


给定一个静态类型为Object的值，我们可以使用Java内置的 `instanceof` 运算符确定运行时值是数字、字符串还是其他类型。换句话说，<span name="jvm">JVM</span>自己的对象表示方便地为我们提供了实现Lox内置类型所需的一切。当我们添加Lox的函数、类和实例概念时，我们将需要做更多的工作，但Object和箱装基元类已足以满足我们当前所需的类型。



<aside name="jvm">

我们需要对值进行的另一件事是管理它们的内存，而Java也可以做到这一点。一个方便的对象表示和一个非常好的垃圾回收器是我们在Java中编写第一个解释器的主要原因。

</aside>

## 表达式求值

接下来，我们需要一些代码块来实现我们可以解析的每种表达式的计算逻辑。我们可以将该代码块插入到语法树类中，例如 `interpret()` 方法中。实际上，我们可以告诉每个语法树节点：“解释你自己”。这就是Gang of Four(GoF)的[解释器设计模式][Interpreter_pattern]。这是一个很好的模式，但正如我之前提到的那样，如果我们将各种逻辑塞入树类中，它会变得混乱。

[Interpreter_pattern]: https://en.wikipedia.org/wiki/Interpreter_pattern

因此，我们将沿用我们优雅的[访问者模式][visitor_pattern]。在上一章中，我们创建了一个AstPrinter类。它接收一个语法树并递归遍历它，构建一个字符串，最终返回它。这几乎就是一个真正的解释器所做的事情，只不过它计算值而不是连接字符串。

[visitor_pattern]: representing-code.html#the-visitor-pattern

我们从一个新类开始。

^code interpreter-class

该类声明它是一个访问者。visit方法的返回类型将是Object，这是我们在Java代码中用来引用Lox值的基类。为了满足Visitor接口，我们需要为解析器生成的四个表达式树类中的每一个定义visit方法。我们将从最简单的开始...

### 字面量求值

表达式树的<span name="leaf">字面量</span>叶子节点是语法的原子位，所有其他表达式都由它们组成。字面量和值差不多，但有很重要的区别。字面量是产生值的语法位。字面量总是出现在用户的源代码中。许多值是通过计算产生的，不会存在于代码本身中。这些不是字面量。字面量来自解析器的领域。值是解释器的概念，是运行时世界的一部分。

<aside name="leaf">

在[接下来的章节][vars]中，当我们实现变量时，我们将添加标识符表达式，它们也是叶子节点。

[vars]: statements-and-state.html

</aside>

因此，就像我们在解析器中将字面 *标记* 转换为字面 *语法树节点* 一样，现在我们将字面树节点转换为运行时值。实现起来不难。

^code visit-literal

我们在扫描期间急切地生成了运行时值，并将其放入标记中。解析器将该值放入字面树节点中，因此要对字面量求值，我们只需将其取回即可。

### 括号求值

下一个最简单的节点是分组——使用显式括号在表达式中得到的节点。

^code visit-grouping

<span name="grouping">分组</span>节点引用包含在括号内的表达式的内部节点。要评估分组表达式本身，我们递归地评估子表达式并返回它。

我们依赖于这个帮助方法，它简单地将表达式发送回解释器的访问者实现：

<aside name="grouping">

有些解析器不为括号定义树节点。相反，在解析括号表达式时，它们只返回内部表达式的节点。我们在Lox中为括号创建节点，因为我们稍后需要它来正确处理赋值表达式的左值。

</aside>

^code evaluate

### 一元表达式求值

和分组一样，一元表达式有一个我们必须首先对子表达式求值。不同之处在于一元表达式本身还有一些后处理工作。

^code visit-unary

首先，我们计算操作数表达式。然后我们将一元运算符本身应用于该结果。有两种不同的一元表达式，由运算符令牌的类型确定。

这里显示的是  `-` , 它对子表达式的结果取反。子表达式必须是数字。由于我们在Java中不知道*静态类型* ，因此在执行操作之前对其进行<span name="cast">强制转换</span>。这种类型转换在计算 `-` 时发生运行时。那就是使语言动态类型化的核心。

<aside name="cast">

你可能想知道如果类型转换失败会发生什么。不用担心，我们很快就会讨论这个问题。

</aside>

您可以开始看到计算过程如何递归地遍历树。我们不能在计算操作数子表达式之前计算一元运算符本身。这意味着我们的解释器正在进行 **后序遍历** ——每个节点在执行自己的工作之前评估其子节点。

另一个一元运算符是逻辑非。

^code unary-bang (1 before, 1 after)

实现很简单，但是“truthy”是什么意思呢？为了理解这个概念，我们需要先回答一个西方哲学的重要问题：什么才是真实？

### 真和假

好吧，也许我们不会真正涉及到宇宙的问题，但至少在Lox的世界里，我们需要决定当您在逻辑操作中使用除 `true` 或 `false` 之外的内容时会发生什么，例如 `!` 或任何其他需要布尔值的地方。

我们 *可以* 说这是一个错误，因为我们没有使用隐式转换，但大多数动态类型语言并不那么严格。相反，它们将所有类型的值的宇宙分成两组，其中一组被定义为“true”或“truthful”或（我最喜欢的）“truthy”，其余的则被定义为“false”或“falsey”。这种分区有些武断，在一些语言中变得有些<span name="weird">奇怪</span>。

<aside name="weird" class="bottom">

在JavaScript中，字符串是 `truthy` 的，但空字符串不是。数组是 `truthy` 的，但空数组也是 `truthy` 的。数字0是 `falsey` 的，但字符串“0”是 `truthy` 的。

在Python中，空字符串与JS中一样是 `falsey` ，但其他空序列也是 `falsey`。

在PHP中，数字0和字符串“0”都是 `falsey` 的。大多数其他非空字符串是 `truthy` 的。

明白了吗？

</aside>

Lox遵循Ruby的简单规则：`false` 和 `nil` 是 `falsey`，其他所有东西都是 `truthy` 。我们这样实现它：

^code is-truthy

### 二元运算符

现在我们来看最后一个表达式树类——二元运算符。二元运算符很多，我们将从算术运算符开始。

^code visit-binary

<aside name="left">

你有没有注意到我们在这里涉及到了语言语义的微妙细节呢？在二元表达式中，我们按照从左到右的顺序对操作数进行评估。如果这些操作数具有副作用，那么这个选择将会对用户产生影响，所以这不仅仅是一个实现细节。

如果我们希望我们的两个解释器保持一致（提示：我们确实希望如此），就需要确保clox也执行同样的操作。

</aside>

我想你能理解这里的实现。与一元取负运算符的主要区别是，我们有两个操作数要计算。

我漏了了一个算术运算符，因为它有点特殊。

^code binary-plus (3 before, 1 after)

`+` 运算符也可以用于连接两个字符串。为此，我们不能只是假设操作数是某种类型并将其强制转换，而是要动态地检查操作数类型并选择适当的操作。这就是为什么我们需要对象表示能支持instanceof。

<aside name="plus">

我们本可以为字符串连接定义一个特定的运算符。这就是Perl（.），Lua（..），Smalltalk（，），Haskell（++）等所做的。

我认为使用与Java、JavaScript、Python等相同的语法会使Lox更容易理解。这意味着 `+` 运算符被重载以支持数字相加和字符串连接。即使在不使用 `+` 字符串的语言中，它们仍经常重载它以操作整数和浮点数。

</aside>

接下来是比较运算符。

^code binary-comparison (1 before, 1 after)

它们基本上与算术运算符相同。唯一的区别是算术运算符产生与操作数（数字或字符串）相同类型的值，而比较运算符总是产生布尔值。

最后一对运算符是相等。

^code binary-equality

与需要数字的比较运算符不同，相等运算符支持任何类型的操作数，甚至是混合类型的操作数。你不能问Lox 3是否小于“three”，但你可以问它是否<span name="equal">等于</span>它。

<aside name="equal">

剧透警告：不是的。

</aside>

和真实性一样，相等逻辑被提到一个单独的方法中。

^code is-equal

这是那些关于如何用Java表示Lox对象的细节很重要的角落之一。我们需要正确地实现Lox的相等概念，这可能与Java的概念不同。

幸运的是，两者非常相似。Lox在相等性中不进行隐式转换，Java也不进行隐式转换。我们必须特别处理nil/null，以便如果我们尝试在null上调用equals()时不抛出NullPointerException。其它情况下，都是没问题的。Java的Boolean、Double和String上的<span name="nan">equals()</span>方法是我们想要的行为。

<aside name="nan">

你猜猜下面的表达式的计算结果是什么？

```lox
(0 / 0) == (0 / 0)
```

双精度数字行为标准[IEEE 754][]中规定，零除以零会给出特殊的NaN（“不是一个数字”）值。令人奇怪的是，NaN不等于自己。

在Java中，原始双精度上的 `==` 运算符保留该行为，但Double类上的equals()方法不保留该行为。Lox使用后者，因此不遵循IEEE。这些微妙的不兼容性占据了语言实现者生活中令人沮丧的相当大的一部分。

[ieee 754]: https://en.wikipedia.org/wiki/IEEE_754

</aside>

就是这样！这是我们要正确解释有效的Lox表达式的所有代码。但是无效的表达式呢？尤其是，当一个子表达式的计算结果类型与待执行的操作不符时会发生什么？

## 运行时错误

每当子表达式产生一个对象并且操作符需要它是一个数字或字符串时，我总是随意地将其转换成数字或字符串。这些转换可能会失败。虽然用户的代码是错误的，但如果我们想要制作一个<span
name="fail">可用的</span>语言，我们有责任优雅地处理这个错误。

<aside name="fail">

我们可以完全不检测或报告类型错误。这就是C语言所做的，你可以将指针转换为某种与实际指向的数据不匹配的类型。C语言通过允许这种转换获得灵活性和速度，但也非常危险。一旦您搞错了内存中的位，将会失去所有的赌注。

很少有现代语言接受这样的不安全操作。相反，大多数语言都是 **内存安全** 的，并通过静态和运行时检查的组合来确保程序永远不会错误地解释存储在内存中的值。

</aside>

现在是时候谈论 **运行时错误** 了。在之前的章节中，我花了很多笔墨谈论错误处理，但那些都是 **语法** 或 **静态错误** 。这些在执行 *任何* 代码之前都会被检测和报告。运行时错误是语言语义所要求我们在程序运行时检测和报告的失败（因此得名）。

现在，如果操作数对于正在执行的操作来说是错误的类型，那么Java转换将失败，JVM将抛出一个ClassCastException。这将跳脱出整个调用堆栈并退出应用程序，然后向用户抛出Java堆栈跟踪信息。这可能不是我们想要的。*Lox* 是用Java实现的这一事实应该是一个对用户隐藏的细节。相反，我们希望他们理解此时发生的是Lox运行时错误，并给他们一个与我们的语言和他们的程序相关的错误信息。

不过，Java的行为确实有一个优点。当错误发生时，它会正确地停止执行代码。比方说，用户输入了一些表达式，比如：


```lox
2 * (3 / -"muffin")
```

你无法对<span name="muffin">"muffin"</span>取负，所以我们需要在内部的 `-` 表达式中报告一个运行时错误。这又意味着我们无法计算 `/` 表达式，因为它的右操作数无意义，对于 `*` 表达式也是如此。因此，当某个表达式深处出现运行时错误时，我们需要一直跳出到最外层。

<aside name="muffin">

我不知道，伙计，你能对一个松饼取负吗？

<img src="image/evaluating-expressions/muffin.png" alt="A muffin, negated." />

</aside>

我们可以打印一个运行时错误，然后中止进程并完全退出应用程序。这具有某种戏剧性的风味。有点像编程语言解释器中的扔话筒（在辩论或讨论中，人们多以恰当的总结性评论来结束对话。这时，人们就可以说 “mic drop”，以此来表明 “到此为止，没什么可说的了”）。

尽管这很诱人，但我们应该做一些较少灾难性的事情。虽然运行时错误需要停止计算*表达式*，但它不应该杀死*解释器*。如果用户正在运行REPL并在一行代码中有一个打字错误，他们仍然应该能够继续会话并在此之后输入更多代码。

###  检测运行时错误


我们的树遍历型解释器通过递归方法调用计算嵌套的表达式，而且我们需要解开所有这些嵌套。在Java中抛出异常是一个很好的方法来实现这一点。但是，我们将定义一个特定于Lox的异常，而不是使用Java自己的类型转换失败，以便我们可以按照我们的方式处理它。

在进行强制转换之前，我们先自己检查对象的类型。因此，对于一元操作符`-`,我们需要添加代码：

^code check-unary-operand (1 before, 1 after)

检查操作数的代码是：

^code check-operand

当检查失败时，代码会抛出一个以下的错误：

^code runtime-error-class

与Java转换异常不同，我们的<span name="class">类</span>会跟踪语法标记，可以指明用户代码中抛出运行时错误的位置9。与静态错误一样，这有助于用户知道去哪里修复代码。

<aside name="class">

我承认 "RuntimeError "这个名字令人困惑，因为Java定义了一个RuntimeException类。关于构建解释器的一件恼人的事情就是，您使用的名称经常与实现语言中已经使用的名称冲突。等我们支持Lox类就好了。

</aside>

我们需要对二元运算符进行类似的检查。既然我答应了要展示实现解释器所需的每一行代码，那么我就把它们逐一介绍一遍。

大于:

^code check-greater-operand (1 before, 1 after)

大于等于:

^code check-greater-equal-operand (1 before, 1 after)

小于:

^code check-less-operand (1 before, 1 after)

小于等于:

^code check-less-equal-operand (1 before, 1 after)

减法:

^code check-minus-operand (1 before, 1 after)

除法:

^code check-slash-operand (1 before, 1 after)

乘法:

^code check-star-operand (1 before, 1 after)

所有这些都依赖于下面这个验证器，它实际上与一元验证器相同

^code check-operands

<aside name="operand">

另一个微妙的语义选择：在检查*两个*操作数的类型之前，我们先计算这两个操作数。假设我们有一个函数 `say()` ，它会打印其介绍的参数，然后返回。 我们使用这个函数写出表达式：

```lox
say("left") - say("right");
```

我们的解释器在报告运行时错误之前会先打印"left"和"right"。相对地，我们也可以指定在计算右操作数之前先检查左操作数。

</aside>

剩下的最后一个运算符，也是最奇怪的一个，就是加法。由于 `+` 已经对数字和字符串进行重载，其中已经有检查类型的代码。我们需要做的就是在这两种情况都不匹配时失败。

^code string-wrong-type (3 before, 1 after)

这样我们就可以在计算器的内部检测运行时错误。错误已经被抛出了。下一步就是编写能捕获这些错误的代码。为此，我们需要将Interpreter类连接到驱动它的Lox主类中。

## 连接解释器

visit方法是Interpreter类的核心部分，真正的工作是在这里进行的。我们需要给它们包上一层皮，以便与程序的其他部分对接。解释器的公共API只是一种方法。

^code interpret

该方法会接收一个表达式对应的语法树，并对其进行计算。如果成功了，`evaluate()` 方法会返回一个对象作为结果值。`interpret()` 方法将结果转为字符串并展示给用户。要将Lox值转为字符串，我们要依赖下面的方法：

^code stringify

这是一段像 `isTruthy()` 一样的代码，它连接了Lox对象的用户视图和它们在Java中的内部表示。

这很简单。由于Lox的设计旨在使Java使用者熟悉，因此Boolean之类的东西在两种语言中看起来是一样的。只有两种边界情况是nil(我们用Java的null表示)和数字。

Lox即使对整数值也使用双精度数字。在这种情况下，打印时应该不带小数点。 由于Java同时具有浮点型和整型，它希望您知道正在使用的是哪一种类型。它通过在整数值的双数上添加一个明确的 `.0` 来告知用户。我们不关心这个，所以我们把它<span name="number">去掉</span>。

<aside name="number">

我们又一次需要处理这些数字的边缘情况，以确保jlox和clox的工作方式相同。处理这种语言的奇怪角落会让您发疯，但这是工作的重要部分。

用户依赖于这些细节-无论是故意还是无意地-如果实现不一致，他们在不同的解释器上运行程序时将会出错。

</aside>

### 报告运行时错误

如果在计算表达式时出现了运行时错误，`interpret()`方法会将其捕获。这样我们可以向用户报告这个错误，然后优雅地继续执行。我们现有的所有错误报告代码都在Lox类中，所以我们也把这个方法放在其中：

^code runtime-error-method

我们使用与RuntimeError相关联的token来告诉用户发生错误时正在执行哪行代码。更好的做法是给用户一个完整的调用堆栈，以显示他们如何执行该代码。但是我们还没有函数调用，所以我想我们不必担心这个问题。

展示错误之后， `runtimeError()` 会设置以下字段：

^code had-runtime-error-field (1 before, 1 after)

这个字段担任着很小但很重要的角色。

^code check-runtime-error (4 before, 1 after)

如果用户正在从文件中运行Lox<span name="repl">脚本</span>并且发生运行时错误，我们在进程退出时设置退出代码，以便通知调用进程。并非每个人都关心shell礼仪，但我们在乎。

<aside name="repl">

如果用户正在运行REPL，我们不关心跟踪运行时错误。在报告后，我们只需循环并让他们输入新代码并继续执行。

</aside>

### 运行解释器

现在我们有了解释器，Lox类可以开始使用它了。

^code interpreter-instance (1 before, 1 after)

我们将该字段设置为静态，以便在REPL会话中连续调用o `run()` 时重用同一个解释器。现在并没有什么区别，但当解释器存储全局变量时，这将在稍后发挥作用。这些变量应该在整个REPL会话中持续存在。

最后，我们删除[上一章][last chapter]中用于打印语法树的临时代码行，并替换为以下内容：

[last chapter]: parsing-expressions.html

^code interpreter-interpret (3 before, 1 after)

我们现在拥有了完整的语言流程：扫描、解析和执行。恭喜您，现在拥有了自己的算术计算器。

如您所见，这个解释器是非常简陋的。但是我们今天建立的解释器类和访问者模式构成了一个骨架，后面的章节中将填充入有趣的内容（变量，函数等）。现在，解释器的功能并不多，但它活了!

<img src="image/evaluating-expressions/skeleton.png" alt="A skeleton waving hello." />

<div class="challenges">

## Challenges

1.  允许对数字之外的类型进行比较可能是个有用的特性。操作符可能对字符串有合理的解释。即使是混合类型之间的比较，如 `3 < "pancake"` ，也可以方便地支持异构类型的有序集合。否则可能导致错误和混乱。

    你是否会扩展Lox以支持对其他类型的比较？如果是，您允许哪些类型间的比较，以及如何定义它们的顺序？证明你的选择并将其与其他语言进行比较。

2.  许多语言中的 `+` 操作符，如果其中一个操作数是字符串，则将另一个转换为字符串，然后将结果连接起来。例如， `"scone" + 4` 将产生 `scone4`。扩展`visitBinaryExpr()` 中的代码以支持此功能。

3.  如果你用一个数除以0会发生什么？你认为应该发生什么？证明你的选择。你知道的其他语言是如何处理除零的，为什么他们会做出这样的选择？

    更改 `visitBinaryExpr()` 中的实现代码，以检测并报告运行时错误。

</div>

<div class="design-note">

## 设计笔记：静态类型和动态类型

有些语言，如Java，是静态类型的，这意味着在任何代码运行之前，会在编译时检测和报告类型错误。其他语言，如Lox，是动态类型的，将类型错误的检查推迟到运行时尝试执行具体操作之前。我们倾向于认为这是一个非黑即白的选择，但实际上它们之间是连续统一的。

事实证明，大多数静态类型的语言也会在运行时进行*一些*类型检查。类型系统会静态地检查多数类型规则，但在生成的代码中插入了运行时检查以支持其它操作。

例如，在Java中，*静态*类型系统会假定强制转换表达式总是能安全地成功执行。在转换某个值之后，可以将其静态地视为目标类型，而不会出现任何编译错误。但向下转换显然会失败。静态检查器之所以能够在不违反语言的合理性保证的情况下假定转换总是成功的，唯一原因是，强制转换操作会在*运行时*进行类型检查，并在失败时抛出异常。

一个更微妙的例子是Java和c#中的[协变数组][covariant arrays]。数组的静态子类型规则允许不健全的操作。考虑以下代码：

[covariant arrays]: https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)#Covariant_arrays_in_Java_and_C.23

```java
Object[] stuff = new Integer[1];
stuff[0] = "not an int!";
```

这段代码在编译时没有任何错误。第一行代码将整数数组向上转换并存储到一个对象数组类型的变量中。第二行代码将字符串存储在其中一个单元格里。对象数组类型静态地允许该操作——字符串也是对象——但是 `stuff` 在运行时引用的整数数组中不应该包含字符串！为了避免这种灾难，当你在数组中存储一个值时，JVM会进行运行时检查，以确保该值是允许的类型。如果不是，则抛出ArrayStoreException。

Java可以通过禁止对第一行进行强制转换来避免在运行时检查这一点。它可以使数组保持不变，这样整型数组就不是对象数组。这在静态类型角度是合理的，但它禁止了只从数组中读取数据的常见安全的代码模式。如果你从来不向数组写入内容，那么协变是安全的。在Java 1.0之前，这些模式对于可用性特别重要，因为之前没有支持泛型。James Gosling和其他Java设计师牺牲了一点静态安全和性能（这些数组存储检查需要花费时间）来换取一些灵活性。

几乎所有的现代静态类型语言都在*某些方面*做出了权衡。即使Haskell也允许您运行非穷举性匹配的代码。如果您自己正在设计一种静态类型语言，请记住，有时你可以通过将一些类型检查推迟到运行时来给用户更多的灵活性，而不会牺牲静态安全的*太多*好处。

另一方面，用户选择静态类型语言的关键原因之一是因为语言给他们带来的信心，即在运行程序时某些类型的错误永远不会发生。如果将太多的类型检查推迟到运行时，就会削弱这种信心。

</div>
